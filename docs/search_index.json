[["index.html", "R Markdown クックブック はじめに", " R Markdown クックブック (著者) Xie, Yihui (著者) Dervieux, Christophe (著者) Riederer, Emily (翻訳者) Katagiri, Satoshi (片桐 智志)1 2021/09/15 14:24:25 JST, ver. 1.0.0, 本家の更新確認時刻: 2021/08/17 19:34:48 JST はじめに 本書の原著はChapman &amp; Hall/CRCより出版されました. 本書のオンライン版は (Chapman &amp; Hall/CRC の厚意により) ここで無料で読むことができます. 本書はクリエイティブ・コモンズ 表示 - 非営利 - 継承 4.0 国際ライセンスのもとで提供されています. ご意見は GitHubで いつでも受け付けています. いつもありがとうございます. 訳注 オリジナルはこちらで読むことができます. 本翻訳版に関するご意見はこちらで受け付けています. また, ご覧になっているのが Web 版であれば, 上部ツールバーからプルリクエストを作成することもできます. ただし修正依頼は翻訳メモの内容を確認してからしていただけると助かります. This is an unofficial Japanese translation of the online version of “R Markdown Cookbook” by Xie, Dervieux, and Riederer, which is licensed under CC BY-NC-SA 4.0. The tranlator is Katagiri, Satoshi. The original document is here. R Markdown は分析とレポート作成を1つのドキュメントとして結びつけるパワフルなツールです. 2014年初頭に rmarkdown パッケージ (Allaire, Xie, McPherson, et al. 2021) が誕生して以来, R Markdown はいくつかの出力フォーマットをサポートするだけの単なるパッケージから, 書籍・ブログ・科学論文・ウェブサイト, そして講義資料の作成までをもサポートする拡張性と多様なエコシステムを持つパッケージへと成長を遂げました. R Markdown: The Definitive Guide (Xie, Allaire, and Grolemund 2018) という, ほんの数年前に書かれた情報の詰まったガイドブックがあります. これは rmarkdown パッケージやその他の拡張パッケージの組み込みフォーマットのリファレンスを詳説しています. しかし読者や出版社から, 作りたい内容を実現できるのかを見つけるまでが大変なので, より実践的で, 面白く役に立つ小規模な使用例を豊富に掲載したものがあればいいのに, というコメントをいただきました (言い換えるなら, 前書は無機質すぎるということです). これが本書の生まれた経緯です. 公式ドキュメントが存在するにも関わらず, R Markdown のユーザーは有名な Q&amp;A フォーラム『スタック・オーバーフロー』でしょっちゅう助けを求めています. 本書の執筆時点では, r-markdown タグのついた質問 が 6,000 件以上ありました. あなたが探すべき問題が何であるか特定していないと, この膨大な件数の中ではフォーラムを利用するのが難しくなります. よって R Markdown を使ってできること, そしてどうすればできるか, の可能性の全てを把握することが難しいものとなるかもしれません. 本書の狙いはスタック・オーバーフローやその他のオンラインリソース (ブログの投稿やチュートリアル) から有名な質問を取り上げ, 多くのユーザーが毎日こぞって検索している問題に対して最新のソリューションを提供することです. 実際, 本書で扱うトピックを決めるのに役立つよう, 第二著者の Christophe はスタックオーバーフローの日々の最も人気のある投稿をスクレイピングする R Markdown のダッシュボートを作成しました. 幸運にも, 我々のクックブックはこれらの人気の投稿を含むことでより一層役に立つものになったに違いありません. 本書は R Markdown 文書の機能を活用する多くの例を掲載しています. クックブックとしてこのガイドは, R Markdown をより効率よく使いたい, そして R Markdown の力をもっと知りたい新規または初心者ユーザーにおすすめです. 参考文献 "],["How-to-read-this-book.html", "本書の読み方", " 本書の読み方 本書は R Markdown の基礎を理解している読者におすすめです. R Markdown: The Definitive Guide (Xie, Allaire, and Grolemund 2018) の Chapter 2 は R Markdown の基礎を解説しており, 新規ユーザーが読むのにおすすめです. たとえば, 本書では Markdown の構文はカバーしていませんので, 読者が他の手段でそれを学んでいる想定です. 特に, 最低でも一度は Pandoc の完全なマニュアル2 に目を通すことを強くお薦めします. このマニュアルはかなり長大ですが, 金の鉱脈のようなものでもあります. 全てを覚えなくてもかまいませんが, Markdown の機能をどう応用できるかを知っていればとても役に立つでしょう. 多くの人々が3連続バッククォートを verbatim なコードブロックに書こうとして失敗したり, 子要素を持つリストを作ろうとして失敗したりするのを, 私は数え切れないほど見てきました. マニュアルに書いてある Markdown の構文を全て読まなければ, 「N 連続バッククォートに対して外側に N + 1 連続でバッククォートを書く」「子要素を表現するには適切なインデントをつける」といったことに, きっと気づかないままでしょう. このクックブックは R Markdown の技術的なリファレンスを網羅することを意図したものではありません. 本書はこれまでにある資料に対する補足となることを目的としています. よって読者は, さらに詳細な情報を知るために以下のような本を参考にすればよいでしょう. R Markdown: The Definitive Guide (Xie, Allaire, and Grolemund 2018) は rmarkdown パッケージやその他いくつかの拡張パッケージでの R Markdown の出力フォーマットに関する技術的資料です. R for Data Science (Wickham and Grolemund 2016b)3 の Part V “Communicate”.: このパートは上記の “Definitive Guide” よりも技術的なことは少ないので, より平易な R Markdown の入門になるでしょう. Dynamic Documents with R and knitr (Xie 2015) は knitr パッケージ (Xie 2021c) の網羅的な入門書です (補足しますと, R Markdown は knitr パッケージのサポートする文書形式の1つにすぎません). 短縮版を読みたい場合, Karl Broman による最小限のチュートリアル “knitr in a knutshell” が役に立つでしょう. 訳注: これらは日本語訳が存在しませんが, Yihui 氏によるドキュメント knitr Elegant, flexible, and fast dynamic report generation with R の日本語訳は既に用意してあります4. bookdown: Authoring Books and Technical Documents with R Markdown (Xie 2016) は bookdown パッケージ (Xie 2021a) の公式ドキュメントとして書かれた小冊子です. bookdown パッケージは長大なフォーマットのドキュメントを R Markdown で簡単に書くために設計されました. blogdown: Creating Websites with R Markdown (Xie, Hill, and Thomas 2017) は blogdown パッケージ (Xie, Dervieux, and Presmanes Hill 2021) によって R Markdown でウェブサイトを作成する方法を紹介してます. 関連性に応じて本書は既存の参考資料を紹介します. それとは別に, R Markdown の公式ウェブサイトにも役立つ情報が多く含まれています: https://rmarkdown.rstudio.com 本書は最初から順に読む必要はありません. 以降の各章はそれより前の章よりも難解になることはありません. 各章と各セクションのうち, 他よりも発展的と思われるものに対しては, タイトルにアスタリスク (*) を付けています. R Markdown でやりたい具体的なタスクがあるとき, あるいは目次に目を通していたら興味のある箇所が見つかった, という使い方が最も効率的な読み方でしょう. いくつかの箇所で相互参照を免れないところがありますが, 用例集を理解するのに必要な予備知識への参照のつもりです. 自分で用例集に挑戦したいならば, 本書の完全なソースコードと用例集は Github の https://github.com/yihui/rmarkdown-cookbook で自由に見ることができます5. 本書の電子書籍版をお読みの場合, 掲載されているコードをお好きなテキストエディタにコピー&amp;ペーストして実行することになるでしょう. 参考文献 "],["Structure-of-the-book.html", "本書の構成", " 本書の構成 本書はそれぞれ単独のコンセプトを実演するため, 小規模な「レシピ」に細分化されています. 1 章では必要なソフトウェアツールのインストール方法を紹介しています. 2 章では R Markdown のコンセプトを概観します. 3 章では R Markdown の基本的な構成要素を紹介し, R Markdown 文書と R スクリプトの変換方法を紹介します. 4 章では, 改ページ, 参考文献リストの掲載, 番号付きの図, アニメーション, ダイアグラムといった文書の要素を作成する方法の話をします. 5 章では図の大きさやアラインメントといった文書の整形方法を紹介します. 6 章では LaTeX/PDF のみ出力したい場合に使える豆知識と小ワザを紹介します. 同様に 7 章では HTML ユーザーに対して, 8 章では Word ユーザーに対して豆知識や小ワザを紹介します. 同時に複数の出力フォーマットで生成したい場合 (これはしょっちゅう小ワザを駆使します), 9 章の記述が役に立つでしょう. 10 章は, 正直に言えば私が最も気に入らなかった箇所ですが, 私は多くのユーザーが表の作成方法を本当に欲していることを理解しています. 私はゴテゴテした装飾過多な表の専門家ではありませんが, その役に立つパッケージのリストを知ることはできるでしょう. 11 章では, あなたがまだ知らないであろう knitr のチャンクオプションのいくつかの応用をお教えします. 12, 13 章は knitr の出力とカスタムフック関数の挙動をうまく扱えるようになることのすばらしさをお教えしますので, 少し発展的ですがこれまたとても役に立つはずです. 14 章ではいろいろな knitr の小ワザを紹介します. 15 章では R Markdown で他のプログラミング言語を扱う例をお見せします. そう, R Markdown は R のためだけのものではありません. また, knitr がまだサポートしていない新しい言語でも動作させる方法も紹介します. 16 章は R Markdown とプロジェクトを関連付けて管理するための豆知識を紹介します. 17 はあなたのワークフローを改善する豆知識をいくつか提示します. 本書のレシピはそれぞれ独立した項目になっているので, あなたに決まった目的がなくてもこれらの中から適当に取り上げて読むことができます. "],["software-info.html", "ソフトウェア情報と表記のルール", " ソフトウェア情報と表記のルール 本書をコンパイルした時点での基本的な R セッション情報は以下のとおりです6. xfun::session_info(c( &#39;bookdown&#39;, &#39;knitr&#39;, &#39;rmarkdown&#39;, &#39;rmdja&#39;, &#39;xfun&#39; ), dependencies = FALSE) ## R version 4.1.1 (2021-08-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.3 LTS ## ## Locale: ## LC_CTYPE=ja_JP.UTF-8 ## LC_NUMERIC=C ## LC_TIME=ja_JP.UTF-8 ## LC_COLLATE=ja_JP.UTF-8 ## LC_MONETARY=ja_JP.UTF-8 ## LC_MESSAGES=ja_JP.UTF-8 ## LC_PAPER=ja_JP.UTF-8 ## LC_NAME=C ## LC_ADDRESS=C ## LC_TELEPHONE=C ## LC_MEASUREMENT=ja_JP.UTF-8 ## LC_IDENTIFICATION=C ## ## Package version: ## bookdown_0.24 knitr_1.34 rmarkdown_2.11 ## rmdja_0.4.6.9 xfun_0.26 ## ## Pandoc version: 2.14.2 上記のセッション情報を見て分かるように, 本書では R ソースコードにプロンプト記号 (&gt; や +) を付けたりしません. またテキスト出力は2連続ハッシュ ## でコメントアウトしています. これはコードをコピーして実行する際の利便性のためです (テキスト出力はコメントアウトされているので無視されます). パッケージ名は太字 (例: rmarkdown) で表記し, 本文中のコードやファイル名はタイプライタフォントで表記します (例: knitr::knit('foo.Rmd')). 関数名の末尾には括弧を付けます (例: blogdown::serve_site()). 二重コロン演算子 :: はパッケージのオブジェクトへのアクセスを意味します. “Rmd” は R Markdown のファイル拡張子名であり, 本書では R markdown の略称としても使用します. 訳注: 日本語版作成にあたって, rmdja パッケージの開発版を使用しているため, 完全に同一のファイルを作成できる保証はないことをご容赦ください.↩︎ "],["acknowledgments.html", "謝辞", " 謝辞 いつものことですが, まず本書の執筆作業の自由を与えていただいた雇用主である RStudio 社に感謝の意を表します. 執筆作業が始まってから, 上司である Tareef Kawaf との毎週のミーティング当初15分から5分に削減され, それから完全になくなりました. 私は複数の友人から所属先で耐えられないほど多くのミーティングがあり, 時間の浪費になっていると聞いていました. 集中力の維持の観点から, 最近ある友人は「5分間 Slack をミュートすることができるかもしれないが, 1日中ミュートできないのか?」と嘆きました「もちろんできる!」と私は答えました. 私は1ヶ月でも好きなだけ Slack をミュートできるようになったようです. 誤解しないでください — Tareef や同僚が邪魔だという意味ではありません. 皆の提供してくれた自由がどれだけ価値あることかを伝えたいだけです. R Markdown Definitive Guide を刊行したのち, このクックブックを執筆することを思いつきましたが, アイディアはまだ貧弱でした. 困難で高く付く作業でした. 最初に Michael Harper の後押しがなければ, この作業にまじめに取り組むことはなかったでしょう. Christophe Dervieux は助けが必要なときにいつも近くにいました. 彼の R と R Markdown のスキルにより作成されたダッシュボード ( flexdashboard パッケージによるもの) は人々が興味を持つであろうもの, 役に立つであろうトピックを本書に記載する助けになりました. 同時に多数の Github issues を手伝ってくれたため, 最小限の再現例も添付してないバグ報告と格闘する時間を執筆作業に割くことができました. 同様に, Martin Schmelzer, Marcel Schilling, Ralf Stubner をはじめ数名がスタック・オーバーフロー上の R Markdown の質問に答えるのを手伝ってくれました. おそらく意図してのことではないと思いますが, 彼らの努力は私の多くの持ち時間を節約してくれました. 最近のスタック・オーバーフローでは Johannes Friedrich の活動が注意を引きます. これまでに何度か, スタック・オーバーフローの質問を開いたら彼がもう回答していた, ということがありました. 10.3 節では David Keyes が私を救ってくれました. 私は彼のことをあまり知りませんでしたが, 表を作成するためのパッケージをいくつか紹介する すばらしいブログ記事を彼が書いていたおかげで助かりました. Holtz Yan の R Markdown の豆知識に関する投稿, Nicholas Tierney の本 R Markdown for Scientists Maëlle Salmon の R Markdown の講座, Jennifer Thompson の R Markdown の講座, Emi Tanaka の R Markdown のワークショップ, Alison Hill の R Markdown ワークショップ (私も講師の1人です), Alison Hill と Emi Tanaka’s R Markdown のワークショップ といったそれ以外のオンライン上の資料もまた, たいへん助けになりました. Maria Bekker-Nielsen Dunbar, Nathan Eastwood, Johannes Friedrich, Krishnakumar Gopalakrishnan, Xiangyun Huang, Florian Kohrt, Romain Lesur, Jiaxiang Li, Song Li, Ulrik Lyngs, Matt Small, Jake Stephen, Atsushi Yasumoto, Hao Zhu, John Zobolas といった方々がプルリクエストを送ったり, issues を埋めたりして多くの方が本書の Github リポジトリに貢献してくれました. 本書の素晴らしい表紙絵は Allison Horst によってデザインされ, 全体のデザインは Kevin Craig によって完成されました. 本書の当初のアイディアの一部は 2018年の RaukR Summer School で knitr のあまり知られていない機能について のリモート講演で生まれたものでした. 視聴者は knitr の機能についてレシピ形式のような手短な入門を好んでいるようでした. 私を招待していただいた, Marcin Kierczak と Sebastian Dilorenzo をはじめとするサマースクールのオーガナイザたちに感謝したいです. Genentech と DahShu. でものちに同様の講演を行いました. 招待していただいた Michael Lawrence と Yuqing Zhang, そしてフィードバックをくれた視聴者のみなさんにも感謝したいです. Paul Johnson からは2020年刊の The American Statistician に掲載された R Markdown: The Definitive Guide に対するとても有意義な批評をいただきました. 彼がこの本には詳細な例が欠けていると批判してくれたため, この「決定版ガイド」は十分に決定的とはいえないことになりました. 彼の論評には心から称賛と賛意を送ります. この新しいクックブックがこの溝を埋めてくれることを願います. これは編集者の John Kimmel との仕事で5番目になる本です. 彼と Chapman &amp; Hall/CRC のチームとの共同作業は常に喜びに満ちていました. 他の著者たちに bookdown が広く利用されるのは bookdown の成功だと John が言ってくれるたびに私は興奮しました. 私の以前の著作の プロダクションエディターであった Suzanne Lassandro が, 他にも多くの責任ある立場にあり著者と直接の接点がほとんどなくなった今も, 本書の手助けになるよう熱心に取り組んでいると John から聞いて私は誇りに思いました. Suzanne と校正担当 (Rebecca Condit) は初稿から「たったの」377箇所の問題を見つけ出してくれました. 実は次の本のミスは30箇所くらいだろうという以前の私の予想は楽観的すぎました. LaTeX の専門家 Shashi Kumar は PDFを印刷する直前の最後の障害となった, 厄介な LaTeX の問題を解決する手助けをしてくれました. John は原稿へのフィードバックのために数名の査読を用意してくれました. 実質的に9人の偉大な査読を得ることになりました. 彼らの1人は共同著者として迎えられれば良かったのにと思うほど偉大でした! 9人の査読との作業は膨大でしたが, 間違いなく苦労に見合った価値がありました. Carl Boettiger, John Blischak, Sharla Gelfand, Johannes Friedrich, Atsushi Yasumoto, そして残りの匿名の査読たちの有意義なフィードバックに感謝の意を送りたいと思います. 本書の最後のパートの作業は私の昔なじみの友人, Dong Guo と Qian Jia が引っ越した後の空き家 (ネット回線なし!) で行いました. 私が疲労困憊しとにかく静かな環境を必要としていた時, 家を一時的なオフィスとして使わせてくれた彼らに感謝します. 彼らに別れを告げるのは悲しいです. 私にとって, この本を彼らの家で仕上げられたことは, 両親とかわいらしい娘のいる彼ら家族とともに良き思い出となるでしょう. 最後に絶対に逃せないユニークなこととしては, COVID-19 のパンデミックの下で自宅にいた2人の小さな「超役に立つ同僚」 (5歳と3歳)に感謝することです. もし2人がいなければ, 5ヶ月は早く刊行できたでしょう. 今となっては託児所 (Small Miracle) の先生が懐かしいですし, 料金もきっと高くはないと感じています… Yihui Xie ネブラスカ州エルクホーンにて "],["author.html", "著者について", " 著者について Yihui が本書のほとんどの文を書きました. これが第一著者であることを正当化する唯一の根拠です. Christophe は全ての Github issues をまとめ, そしていくつかのセクションを書いたというはっきりした貢献があります. Emily は本来は本書の査読者でした. Yihui が彼女を共同著者として招いたのは, Yihuiが彼女と長いコメントでやり取りできるほどがまん強くないので, 自分でとてもうまく書けたと思っていたものに大量の追加注文を付けられることの苦しみを分からせるため (つまり仕返しのため) でした. いいえ, これは冗談です. 彼女のコメントはとても有意義でしたが, Yihui には提案された全ての改善案に対処する時間がなかったため, 全幅の評価で彼女を招待したのです. 本書で「私」という表現があれば, それは Yihui のことを指します. 「我々」ではなく「私」を使うのは, 共著者のことを忘れてしまったからではなく, 完全に Yihui の独自の意見を表明したいことを意味しています. 彼は賢く見られたいと思っていますが, 実は愚かであるというのなら, それは自分だけであってほしいと思っています. "],["yihui-xie.html", "Yihui Xie", " Yihui Xie Yihui Xie (https://yihui.org) は RStudio (https://www.rstudio.com) のソフトウェアエンジニアです. アイオワ州立大学の統計学部で PhD を取得しました. インタラクティブな統計的グラフィックと統計的コンピューティングに関心があります. 活動的な R ユーザーとして, knitr, bookdown, blogdown, xaringan, tinytex, rolldown, animation, DT, tufte, formatR, fun, xfun, testit, mime, highr, servr, Rd2roxygen といった R パッケージを開発しています. その中でも animation パッケージは 2009年の John M. Chambers Statistical Software Award (ASA) を受賞しています. また, shiny, rmarkdown, pagedown, leaflet といったパッケージの開発メンバーにも加わっています. 彼は2つの本を書いています, Dynamic Documents with knitr (Xie 2015), と bookdown: Authoring Books and Technical Documents with R Markdown (Xie 2016), です. そして2つの本の共著者です, blogdown: Creating Websites with R Markdown (Xie, Hill, and Thomas 2017), と R Markdown: The Definitive Guide (Xie, Allaire, and Grolemund 2018) です. 2006年, 彼は Capital of Statistics (https://cosx.org) を設立しました. これは中国国内の大きな統計学のオンラインコミュニティに成長しました. 彼はまた 2008年に Chinese R conference を開始し, 以降, 中国での R カンファレンスの企画に関わってきました. アイオワ州立大学での PhD のトレーニングの間に, 彼は学部で Vince Sposito Statistical Computing Award (2011年) と Snedecor Award (2012)7を受賞しました. 彼はたいていの場合, twitter のメッセージを週に1度確認します (https://twitter.com/xieyihui). ほとんどの時間, 彼は Github (https://github.com/yihui) で見かけることができます. 彼には4つの趣味があります. 読むこと, 書くこと (ほとんどはブログ), 料理, そしてバドミントンをすることです. 彼は実際食べるより料理する方に関心があります. 食べるのを我慢できないほど好きな料理はそう多くありませんが, その一例は激辛料理でしょう. 料理がさらに楽しくなったので, レストランに行くことがまれになっています. レストランに行って「料理はどれくらい辛くしたらよろしいでしょうか」と訊かれれば, 彼はたいてい「シェフができる限界まで辛くして」と答えます. 参考文献 "],["christophe-dervieux.html", "Christophe Dervieux", " Christophe Dervieux Christophe Dervieux は R コミュニティの活動的なメンバーであり, 現在はフランス在住です. エネルギーと経済に関する修士号を取得しており, アナリストとして R を使った最初の仕事はマーケットデザインに関する経済研究です. これは developer advocate および R 管理者となって R の布教と職場での R ユーザーへのサポートをするようになる前のことです. 彼は人々が R を 最大限活用できるように手助けすることに関心があり, 彼が RStudio Community で sustainer として, あるいはいくつかの R パッケージの Github issues で動き回る姿を目にすることができるでしょう. どちらの場でも, “cderv” という短縮ハンドルネームで彼だと認識できるでしょう. R開発者としての彼は, bookdown, rmarkdown, knitr といったいくつかの R パッケージのコントリビューターです. crrri パッケージの開発メンバーの一人でもあります. 彼自身のプロジェクトは GitHub (https://github.com/cderv) で確認できますし, ときどき Twitter でアイディアを共有することもあります. 彼は辛い料理は苦手ですが, 毎週バドミントンを楽しんでいます. "],["emily-riederer.html", "Emily Riederer", " Emily Riederer Emily Riederer は消費者金融業界でデータサイエンスの仕事をしており, R を使った分析ツールを構築するチームを率い, この業界でオープンサイエンスの文化を育てています. それ以前は, 彼女はチャペルヒルのノースカロライナ大学で数学と統計学を専攻していました. Emily は頻繁に Twitter (https://twitter.com/emilyriederer) や自分のブログ (https://emily.rbind.io) で R について議論し, プロジェクトを共有します. その中には GitHub (https://github.com/emilyriederer) にある projmgr パッケージも含まれます. rOpenSci のパッケージレビュアーとしても活動し, さらに satRday Chicago R conference の発起メンバーの一人でもあります. Emily の他の関心は読書とウェイトリフティングです. 彼女は自分で辛い料理が好きだと考えていますが, 合衆国内にしか住んだことがないため, その言葉が実際に意味するところをよく分かっていないのだと言われています. "],["translators.html", "翻訳者情報 (About Translators)", " 翻訳者情報 (About Translators) この日本語版ページ, および PDF ファイルを作成した人間の情報です. "],["片桐智志-katagiri-satoshi.html", "片桐智志 (Katagiri, Satoshi)", " 片桐智志 (Katagiri, Satoshi) 山田工業所の中華鍋 (両手鍋) を使用しています. 私も四川料理のような辛いものは好きです. I am the main translator, which means the most of this text is translated by me. Thus I am the mainly responsible person for this translation. I use a southern-style wok. I also like spicy dishes like Sichuan cuisine. "],["翻訳協力者への謝辞.html", "翻訳協力者への謝辞", " 翻訳協力者への謝辞 加えて, 日本語版の修正提案に協力していただいた方を以下にクレジットします. R Markdown クックブックなので R を使って機械的に掲載してみます. 以下に Github でのPRがマージされた方のアカウント名が表示されます. nnawata これは以下のようなプログラムで出力しています. contributors &lt;- rbind(read.csv(textConnection(system(&quot;git shortlog -s master JP&quot;, intern = T)), header = F, sep = &quot;\\t&quot;), read.csv(textConnection(system(&quot;git shortlog -s work JP&quot;, intern = T)), header = F, sep = &quot;\\t&quot;)) contributors &lt;- aggregate(contributors[, 1], by = list(contributors$V2), sum) contributors &lt;- subset(contributors, !charmatch(contributors$Group.1, c(&quot;Katagiri, Satoshi&quot;, &quot;S-Katagiri&quot;), F)) cat(paste0(&quot;* [&quot;, contributors[order(contributors$x), ]$Group.1, &quot;](&quot;, &quot;https://github.com/&quot;, contributors[order(contributors$x), ]$Group.1, &quot;)&quot;), sep = &quot;, &quot;) "],["installation.html", "1 インストール方法", " 1 インストール方法 R Markdown を使うにはR (R Core Team 2021) と R パッケージである rmarkdown (Allaire, Xie, McPherson, et al. 2021) のインストールが必要です. # CRAN から rmarkdown パッケージを R にインストール install.packages(&quot;rmarkdown&quot;) # または, 開発版をインストールしたければ GitHub # からインストール if (!requireNamespace(&quot;remotes&quot;)) install.packages(&quot;remotes&quot;) remotes::install_github(&quot;rstudio/rmarkdown&quot;) こだわりのあるテキストエディタや IDE (統合開発環境) がなければ, RStudio IDE (https://www.rstudio.com) のインストールも推奨します. RStudio は必須ではないですが, エディタに強力な R Markdown 支援機能があるので平均的なユーザーにとっては作業がより簡単になります. RStudio IDE を使わない選択をしたなら, Markdown を他の形式の文書に変換するために rmarkdown が使用する Pandoc(1.1 節参照)をインストールする必要があります. PDF として作成する必要があるなら, LaTeX (1.2 節) およびいくつかのパッケージ (1.3) のインストールも必要になるかもしれません. 参考文献 "],["install-pandoc.html", "1.1 RStudio IDE にバンドルされていないバージョンの Pandoc を使う", " 1.1 RStudio IDE にバンドルされていないバージョンの Pandoc を使う RStudio IDE は特定のバージョンの Pandoc を同梱しているため, RStudio IDE を使用する場合は自分で Pandoc をインストールする必要はありません. しかし同梱されたバージョンが最新でないことはよくありますし, 必要なバージョンでないかもしれません. 別の Pandoc を自分でインストールすることができます. ほとんどの RStudio ユーザーは同梱されたバージョンを使用しているでしょうから, このバージョンの Pandoc は R Markdown での徹底的なテストを乗り越えていることを覚えておいてください. 異なるバージョン (特に新しいバージョン) を使う場合, 他の R Markdown ユーザーや開発者が解決できない問題にぶつかるかもしれません. Pandoc のサイトに, プラットフォームごとの Pandoc のインストール方法の詳細なインストラクション https://pandoc.org/installing.html があります. 特定のバージョンを使うために Pandoc を自分でインストールしたのなら, 例えば以下のように rmarkdown::find_pandoc() 関数を呼び出して rmarkdown パッケージにそのことを知らせることになるでしょう. # 特定のバージョンを検索 rmarkdown::find_pandoc(version = &quot;2.9.1&quot;) # 特定のディレクトリから検索 rmarkdown::find_pandoc(dir = &quot;~/Downloads/Pandoc&quot;) # 以前発見した Pandoc を無視して再検索する rmarkdown::find_pandoc(cache = FALSE) 上記のコードチャンクのように, Pandoc のバージョンを特定する方法はいくつかあります. デフォルトでは rmarkdown::find_pandoc() はお使いのシステムの最新の Pandoc を発見しようとします. 発見できたなら, バージョン情報はキャッシュされ cache = FALSE でキャッシュは無効化されます. pandoc 実行ファイルの発見されるであろうディレクトリがどこにある可能性があるかは, ヘルプページの ?rmarkdown::find_pandoc を見てください. この関数は Rmd 文書内でも外部でも呼び出される可能性があります. あなたのコンピュータにインストールした特定のバージョンの Pandoc で Rmd 文書をコンパイルしたい場合, この関数を文書内のチャンクのどれかで呼び出すことになるでしょう. 例えばセットアップ用のチャンクで以下のように. ```{r, setup, include=FALSE} rmarkdown::find_pandoc(version = &#39;2.9.1&#39;) ``` "],["install-latex.html", "1.2 PDF レポートの作成に LaTeX (TinyTeX) をインストールする", " 1.2 PDF レポートの作成に LaTeX (TinyTeX) をインストールする R Markdown から PDF 文書を作りたいなら, LaTeX がインストール済みである必要があります. 伝統的な選択肢として MiKTeX, MacTeX, そして TeX Live がありますが, R Markdown ユーザーに対しては TinyTeX のインストールを推奨します. TinyTeX は TeX Live をもとにカスタムされた LaTeX ディストリビューションで, 比較的サイズが小さく, それでいて, 特に R ユーザーが使うようなほとんどの機能を備えています. TinyTeX のインストールや起動にはシステム管理者権限は不要です8. TinyTeX は R パッケージの tinytex (Xie 2021e) でインストールできます. tinytex::install_tinytex() # TinyTeX をアンインストールするなら, # tinytex::uninstall_tinytex() を実行してください “tinytex” は R パッケージのことを指し, “TinyTeX” は LaTeX ディストリビューションを指すことに注意してください. TinyTeX を使う利点は2つあります. TinyTeX は (他の LaTeX ディストリビューションと比べて) 軽量であり, クロスプラットフォームでありポータブルです. 例えば USB ドライブや他のポータブルデバイスに TinyTeX のコピーを保存し, 同じオペレーティングシステムの別のコンピュータで使用することができます. R Markdown を PDF へ変換する時, Pandoc はまず Markdown を中間ファイルとして LaTeX 文書に変換します. tinytex パッケージは LaTeX 文書を PDF にコンパイルするヘルパー関数を提供します (主な関数は tinytex::latexmk() です). TinyTeX を使っていて, インストールされていない LaTeX パッケージが必要ならば, tinytex は自動でインストールしようとします. LaTeX ファイルに対するコンパイルも, 全ての相互参照を確実に解決するために十分な回数だけ行おうとします. 技術的に詳しい話に興味があるなら, Xie (2019) の論文と https://yihui.org/tinytex/faq/ の FAQ を確認するとよいかもしれません. 訳注 上記の FAQ を含む tinytex パッケージのドキュメントの日本語版も翻訳者により作成されています https://gedevan-aleksizde.github.io/tinytex-doc-ja/index.html 参考文献 "],["install-latex-pkgs.html", "1.3 足りない LaTeX パッケージをインストールする", " 1.3 足りない LaTeX パッケージをインストールする 文書を LaTeX を通して PDF にコンパイルしたい時, これらのようなエラーに遭遇するかもしれません. ! LaTeX Error: File `ocgbase.sty&#39; not found. !pdfTeX error: pdflatex (file 8r.enc): cannot open encoding file for reading !pdfTeX error: /usr/local/bin/pdflatex (file tcrm0700): Font tcrm0700 at 600 not found 1.2 節で紹介した TinyTeX を使用しているなら, だいたいの場合このようなエラーに対処する必要はありません. tinytex (Xie 2021e) が自動で対処してくれるからですが, 何らかの理由でこのようなエラーに遭遇した場合でもやはり, tinytex::parse_install() で足りない LaTex パッケージをインストールするのは簡単です. この関数は LaTeX ログファイルのパスを引数として, 足りないパッケージの問題を自動的に解決し, CTAN (the Comprehensive TEX Archive Network, https://ctan.org) で見つけられたものをインストールしようとします. LaTeX ログファイルは典型的には入力文書ファイルとおなじ基底名と, .log という拡張子名を持ちます. このログファイルを見つけられない場合, エラーメッセージをこの関数の text 引数に与えることができます. どちらの方法でも動作するはずです. # ログファイルが filename.log だとする tinytex::parse_install(&quot;filename.log&quot;) # または `text` 引数を使う tinytex::parse_install( text = &quot;! LaTeX Error: File `ocgbase.sty&#39; not found.&quot; ) # &quot;ocgx2&quot; パッケージがインストールされる TinyTeX を使わない場合, tinytex パッケージはやはりエラーログから LaTeX パッケージ名を解決しようとします. tinytex::parse_packages() を例えばこのように使用してください. # ログファイル名が filename.log だったとする tinytex::parse_packages(&quot;filename.log&quot;) # または `text` 引数を使う tinytex::parse_packages( text = &quot;! LaTeX Error: File `ocgbase.sty&#39; not found.&quot; ) # &quot;ocgx2&quot; と返ってくるはず パッケージ名が判明したら, あなたの LaTeX ディストリビューションのパッケージマネージャでインストールすることができます. 代わりに MiKTeX を使っているなら, これも自動で足りないパッケージをインストールできます. MikTeX のインストール中に “Always install missing packages on-the-fly” の設定に必ずチェックしてください. この設定をせずにインストールしていても, まだ MiKTeX Console で変更できます. 訳注 日本語文書を作成する場合, いくらか追加の作業が必要かもしれません. 例えばコンパイル時, 毎回翻訳ファイルがないという旨の警告が出るかもしれません. これは出力に影響しませんが, 煩わしく感じるなら以下のようにして対応する LaTeX パッケージ (R のパッケージではないことに注意してください) をインストールすることで解決できます. tinytex::tlmgr_install(&quot;texlive-msg-translations&quot;) 一方で以前から TeX Live を使用しているがここ数年は更新していない, という方にとっては, 手動でパッケージをインストールする必要があるかもしれません. 2021年現在は, haranoaji, bxjscls luatex-ja といった LaTeX パッケージが日本語文書の作成に広く使われます. 既に書かれているように, tinytex はかなりの精度で必要なパッケージを自動でインストールしてくれますが, インストール済みの TeX を使用する場合は tinytex を使わず手動でインストールする必要があるかもしれません. 上記の tinytex::tlmgr_install() 関数は tlmgr のコマンドを実行するための関数なので, tinytex を使用していない環境では tlmgr install ... を代わりに実行することになります. PDF 出力のためのセットアップは翻訳者が独自に書いた補足資料 https://rpubs.com/ktgrstsh/755893 も参考になるかもしれません. 参考文献 "],["conceptual-overview.html", "2 コンセプトについての概論", " 2 コンセプトについての概論 このテキストの目標は R Markdown を最大限活用するために多くの豆知識と小ワザを見せることです. 以降の各章ではより効率的で簡潔なコードを書き, 出力をカスタマイズする技術を実演します. これを始める前に, これらを理解し, 覚え, 応用し, 「リミックス」できる助けになるよう, R Markdown の動作がどうなっているかを少しだけ学んでおくと役に立つでしょう. この節では文書を knit する処理と出力を変更する「重要な切り替えレバー」について簡潔に概観します. この資料は後に続く章の内容理解に必要ではありません. 読み飛ばすのは自由です. しかし全てのピースをどう当てはめるかについて, より豊かなメンタルモデルを構築する助けになるかもしれません. "],["rmarkdown-process.html", "2.1 レンダリング時に何が起こっているのか", " 2.1 レンダリング時に何が起こっているのか R Markdown はいくつかの異なるプロセスを合わせて文書を作成しています. これが R Markdown の全てのパーツがどう連動してるか理解するのに混乱する主な元凶です.9 幸運にも, ユーザーが文書を作成できるようになるためにはこれらの処理の内部の挙動を全て理解することは必須ではありません. しかし, 文書の挙動を変えようとするだろうユーザーにとっては, どのパーツがどの挙動を担当しているかを理解することは重要です. あなたが検索する適切な範囲を絞れるようになれば, ヘルプを探すのがより簡単になります. R Markdown 文書に対する基本的なワークフローの構造を図2.1に示します. ステップ (矢印) と, 出力ファイルが生成される前に作成される中間ファイルを強調しています. 全ての処理は rmarkdown::render() 関数内に実装されています. 以降は各ステップを詳細に説明します. 図 2.1: R Markdown 文書がどのように最終的な出力文書に変換されるかを表すダイアグラム .Rmd 文書は, 文書の本来の形式です. YAML (メタデータ), テキスト (ナラティブ), コードチャンク を含んでいます. 最初に knitr (Xie 2021c) の knit() 関数が .Rmd ファイルに埋め込まれた全てのコードを実行し, 出力文書に出力コードを表示します. 全ての結果は, 一時的に作られた .md ファイルに含まれるよう, 適正なマークアップ言語へと変換されます. その後 .md ファイルは, あるマークアップ言語のファイルから別のものへと変換するための多用途なツールである Pandoc によって処理されます. Pandoc は文書の YAML フロントマターで指定された何らかのパラメータ (例: title, author, date) を受け取り, 文書を output パラメータで指定された出力フォーマット (HTML へ出力する html_document のような) へ変換します. 出力フォーマットが PDF ならば, さらに処理が1層追加され, Pandoc が中間ファイルの .md を もう一つの中間ファイル .tex に変換します. このファイルはその後, 最終的な PDF 文書を形成するため LaTeX によって処理されます. 1.2 節で話したように, rmarkdown パッケージは tinytex パッケージ (Xie 2021e) の latexmk() 関数を呼び出し, これが次々に LaTeX を呼び出して .tex をコンパイルし .pdf にします. 簡潔にまとめると, rmarkdown::render() = knitr::knit() + Pandoc (PDF の場合のみ + LaTeX) ということです. Robin Linacre が https://stackoverflow.com/q/40563479/559676 で R Markdown と knitr と Pandoc の関係について良い要約を書いてくれました. この投稿には上記の概観よりも技術的に細かい話も含まれています. 全ての R Markdown 文書が常に Pandoc を通してコンパイルされるわけではないことに注意してください. 中間ファイル .md は他の Markdown レンダラによってもコンパイルできます. 例えば2つ例を挙げます. xaringan パッケージ (Xie 2021f) は出力された .md をウェブブラウザ上で Markdown コンテンツを表示するための JavaScript ライブラリに渡します.10 blogdown パッケージは (Xie, Dervieux, and Presmanes Hill 2021) .Rmarkdown 文書形式をサポートし, .Rmarkdown を knit して .markdown にします. 通常であれば, Markdown 文書は外部のサイトジェネレータによって HTML にレンダリングされます. 参考文献 "],["rmarkdown-anatomy.html", "2.2 R Markdown の解剖学", " 2.2 R Markdown の解剖学 R Markdown にあるいくつかの部品を考慮することで, 我々はさらに1レベル深く掘り下げることができます. では, この部品がレンダリング作業中にいつどのように処理を変化させるかに注目してみましょう. 2.2.1 YAML メタデータ YAML metadata (YAML ヘッダとも呼びます) はレンダリング作業中の多くのステージで処理され, 様々な形で最終的な文書に作用することができます. YAML メタデータは Pandoc, rmarkdown, そして knitr のそれぞれで読み込まれます. その過程で, YAML メタデータに含まれる情報は, コード, コンテンツ, そしてレンダリング処理に影響をあたえます. 典型的な YAML ヘッダは以下のような形をしており, 文書とレンダリング操作指示の基礎となるメタデータを含んでいます. --- title: My R Markdown Report author: Yihui Xie output: html_document --- 上記の場合, title, author フィールドは Pandoc によって処理され, テンプレートの変数の値が設定されます. デフォルトのテンプレートでは, title と author の情報は得られた文書の冒頭に現れます. Pandoc が YAML ヘッダの情報をどう扱うかのより詳細な話は, Pandoc マニュアルの YAML metadata block. に関するセクションで見られます.11 対照的に output フィールドは rmarkdown によるレンダリング処理中に出力フォーマット関数 rmarkdown::html_document() に適用されます. output に指定した出力フォーマットに引数を与えることで, 以降のレンダリング処理に影響させることができます. 例えばこのように書きます. output: html_document: toc: true toc_float: true これは rmarkdown::render() に, rmarkdown::html_document(toc = TRUE, toc_float = TRUE) と指示することと同じです. これらのオプションが何をするのか知るために, あるいは使える他のオプションを知るためには, R コンソールで ?rmarkdown::html_document を実行してヘルプページを読むとよいでしょう. output: html_document は output: rmarkdown::html_document と等価であることに注意してください. 出力フォーマットが rmarkdown:: のような修飾子を持たない場合, R Makrodown はこれを rmarkdown パッケージ由来のものと想定します. そうでないなら, R パッケージ名のプレフィックスが必要です. 例えば bookdown::html_document2 のような. 17.4 節に書いたように, YAML ヘッダ内でパラメータを選択したのなら, コンテンツとコードにも影響することができます. 簡潔に言うと, R Markdown ドキュメント全体で参照可能な変数や R 評価式をヘッダに含めることができるということです. 例えば以下のヘッダでは start_date と end_date パラメータを定義することで, 以降の R Markdown 文書内で params というリスト内に反映されます. つまり, R コード内でこれらの値を使いたければ, params$start_date と params$end_date でアクセスできるということです. --- title: My RMarkdown author: Yihui Xie output: html_document params: start_date: &#39;2020-01-01&#39; end_date: &#39;2020-06-01&#39; --- 2.2.2 ナラティブ ナラティブ (物語術) としてのテキスト要素は YAML メタデータやコードチャンクよりは理解が簡単でしょう. 典型的には, これはテキストエディタで書いているような感覚でしょう. しかし Markdown コンテンツは, どのようにコンテンツが作られるか, そこからどうやって文書の構造が作られるか, の両方に関して, 単純なテキストよりも強力で面白いものに違いありません. 世のナラティブの多くは人の手で書かれていますが, 多くの R Markdown 文書では, 用いられているコードと分析を参照しようとします. この理由として, 4 章において, コードがテキストの一部を生成するのを助ける様々な方法が実演されています. 例えば単語を結合してリストにしたり (4.11節), 参考文献リストを書いたり (4.5節)といった方法です. この変換は .Rmd から .md への変換と同様に knitr で制御されます. Markdown のテキストは文書に構造を与えることもできます. Markdown の構文をこの場で復習するには紙面が足りませんが,12 特に関連深い概念の1つとしてセクション見出しがあります. これは 1つ以上の, 対応したレベルの数のハッシュ (#) で表現されます. 例えば, 以下のように. # 第1水準の見出し ## 第2水準の見出し ### 第3水準の見出し これらの見出しは rmarkdown が .md を最終的な出力フォーマットに変換する際に文書全体に構造を与えます. この構造は, ある属性を付与することで章や節を参照し整形するのに役立ちます. 例えば以下のように, Pandoc 構文は見出しの記述に {#id} の表記にしたがってユニークな識別子をつけることで参照が作成できますし, {.クラス名} のように書くことで, セクションに一つないし複数のクラスを付与できます. ## 第2水準の見出し {#introduction .important .large} これから学ぶいくつもの方法で, 例えば ID やクラスを参照することで, このセクションにアクセスすることができるようになります. 具体例として, 4.7節ではセクションIDを使って文書内のどこでも相互参照する方法を実演していますし, 7.6節では小節を再構成させる .tabset クラスを紹介しています. R Markdown のテキスト部分で見られる最後の興味深いコンテンツのタイプとして, 特定の出力したいフォーマットに対して「生のコンテンツ」をそのまま書き出す方法, 例えば LaTeX 出力に対して LaTeX コードを直接書く (6.11 節), HTML 出力に対して HTML コードを直接書く (9.5 節), 等を挙げます. 生のコンテンツは基本的な Markdown ではできないことが達成できますが, 出力フォーマットが異なるとたいていは無視されてしまうことに留意してください. 例えば生の LaTeX コマンドは出力が HTML の場合, 無視されます. 2.2.3 コードチャンク コードチャンクは R Markdown にとっての心臓の鼓動です. チャンク内のコードは knitr によって実行され, 出力は Markdown に翻訳され, レポートは現在のスクリプトとデータに動的に同期します. 各コードチャンクは言語エンジン (15章), 任意に指定できるラベル, チャンクオプション (11章), そしてコードで構成されます. コードチャンクに対してできるいくつかの修正について理解するためには, knitr の処理を少しだけ詳しく知ることが有意義です. 各チャンクでは, knitr 言語エンジンは3つの入力の部品を得ます. knit 環境 (knitr::knit_global()), 入力されたコード, そしてチャンクオプションのリストです. コードチャンクはコードの出力とともに見た目も整形して返します. 副作用として, knit 環境も修正されます. 例えばコードチャンク内のソースコードを介してこの環境内で新しい変数がつくられます. この処理は図2.2のように表せます. 図 2.2: 言語エンジンへの入出力フローチャート この処理は以下の方法で修正できます. 言語エンジンを変更する チャンクオプションを, グローバル, ローカル, あるいは言語エンジンに特定のものに修正する フックやチャプターを使用して, 入出力にさらなる処理を追加する 例えば12.1節で, 後処理をするフックを加えてソースコードの特定行を編集する方法を学べるでしょう. コードチャンクには2.2.2節でつぶさに見てきたナラティブのクラスと識別子に類似するコンセプトがあります. コードチャンクは識別子 (よく「チャンクラベル」と呼ばれます) を言語エンジンの直後に任意で指定することができます. チャンクオプション class.source と class.output でそれぞれコードブロックとテキスト出力ブロックに対するクラスを設定することもできます (7.3節参照). 例えばチャンクヘッダ ```{r summary-stats, class.output = 'large-text'} はチャンクラベルに summary-stats を与え, テキスト出力ブロックに large-text というクラスを与えています. チャンクのラベルは1つだけですが, クラスは複数持つことができます. 2.2.4 文書の本文 文書を執筆し編集する際に理解すべき重要なことは, コードとナラティブの小片が文書内のいくつもの節やコンテナを作る方法です. 例えばこのような文書があったとします. # タイトル ## X 節 ここから導入文 ```{r chunk-x} x &lt;- 1 print(x) ``` ### 第1小節 ここに詳細な話 ### 第2小節 ここにさらに詳しい話 ## Y 節 ここから新しい節 ```{r chunk-y} y &lt;- 2 print(y) ``` この文書を書いていると, それぞれの小片は, テキストとコードを含む独立した節を一直線上に並べたものだとみなせるでしょう. しかし我々が実際にしているのは, 概念としては図2.3でより細かく描いているように, 入れ子 (ネスト) になったコンテナの作成です13 図 2.3: 入れ子状のコンテナとして表現された単純な R Markdown 文書の例 この図に関する2つの重要な特徴は (1) テキストやコードのどのセクションも個別のコンテナであり, (2) コンテナは他の別のコンテナを入れ子にできる, ということです. この入れ子は R Markdown 文書を RStudio IDE で執筆し, 文書のアウトラインを展開14しているとはっきりと分かります. 図2.3では同じレベルのヘッダは同じレベルの入れ子を表していることに注意してください. より低いレベルのヘッダはより高レベルなヘッダのコンテナ内部にあります. この場合, 通常は高レベルの節を「親」といい, 低レベルの節を「子」といいます. 例えば「小節」は「節」の子です. 5.8節で実演するように, ヘッダだけでなく ::: を使ってまとまりの単位を作ることができます. このテキストで説明されているフォーマットやスタイルのオプションを適用するとき, この構造は重要な意味を持ちます. 例えば, Pandoc が抽象構文木 (AST) でどのように文書を表現するかを我々が学ぶ時 (4.20節) や, HTML出力のスタイルを決めるために CSS セレクタを使用する時 (7.1節ほか), 入れ子構造の概念が現れます. フォーマットとスタイルは類似するいずれのタイプのコンテナ (例えばコードブロック) や, あるコンテナの内部にある全てのコンテナ (例: 「Y 節」以下にある全てのコンテナ) に対して適用できます. 加えて2.2.2節で説明したように, 同一のクラスを特定の節に対して適用し同様のものとして扱うよう明示できますが, この場合の共通するクラス名は, 節と節に共通のプロパティや共通の意図を示すようになります. 本書を読みながら, 特定の「レシピ」がどんな種類のコンテナに対して作用しているのかを自問し思いを馳せることは役に立つでしょう. 訳注: 日本語訳での対応箇所はこちら: https://pandoc-doc-ja.readthedocs.io/ja/latest/users-guide.html#metadata-blocks↩︎ Markdown の復習には, 代わりに, https://bookdown.org/yihui/bookdown/markdown-syntax.html をご覧になってください.↩︎ 実際にはここで見えているよりも多くのコンテナがあります. 例えば knit されたコードチャンクや, コードと出力がそれぞれ別のコンテナとして存在し, そしてこれらは親要素を共有しています.↩︎ 訳注: エディタ右上にあるボタンで表示を切り替えることができます.↩︎ "],["what-to-change.html", "2.3 結果を変えるために変更できるのはなにか?", " 2.3 結果を変えるために変更できるのはなにか? では, ここまでで概観してきたものを要約し, これから何をすべきかを下見していきましょう. rmarkdown で R Markdown 文書をレンダリングする処理は knitr で .Rmd を .md で変換する処理, それから (典型的には) Pandoc で .md を望む出力に変換する処理で構成されます. .Rmd から .md への変換のステップではレポート内の全てのコードの実行と「翻訳」を取り扱うことから, ここでの「コンテンツ」への変更はほぼ, .Rmd のうち knitr が翻訳するコードを編集する作業に絡んできます. これらのステップ全体を操作するツールには knitr チャンクオプションおよびフックがあります. .md はフォーマットされていないプレーンテキストです. ここで Pandoc が登場し, HTML や PDF, Word といった最終的な出力フォーマットへ変換されます. この流れに沿って構造とスタイルを付与します. この処理では スタイルシート (CSS), 生 LaTeX または HTML コード, Pandoc テンプレート, Lua フィルタといった様々なツールが助けになります. R Markdown 文書の入れ子構造を理解し, よく考えて識別子とクラスを使うことで, これらのツールを取捨選択して出力の目標となる箇所に応用することができます. 最後に, YAML メタデータはこれらのステップの切り替えに役に立つことでしょう. パラメータを変更することでコードがどう動作するかを変更でき, メタデータを変更すればテキストの内容を変化させ, 出力オプションの変更は異なる命令のセットを備える render() 関数を与えます. もちろんこれらは全て大まかな経験則であり, 絶対的な事実として扱うべきでありません. 究極的には, 機能を完璧にきれいに分類することはできません. 本書全体を通じて, 説明されている結果の多くは, しばしば実現までの道筋が複数あり, さらにそのパイプラインの様々なステージの説明に立ち入ることになることが分かるでしょう. 例えば文書内に画像を挿入する作業では, .Rmd から .md への変換の段階で R コード knitr::include_graphics() を使うこともあれば, Markdown 構文 (![]()) を直接使うこともあるでしょう. ややこしく思えるかもしれませんし, アプローチごとに異なる利点を持つこともあります. しかし悩まないでください. なんにせよ, あなたの問題を解決する多くの有効な方法が存在し, あなたはその中から自分にとって最も理にかなうアプローチに従うことができます. さあこの辺にしておきましょう. 本書の残りの部分で, これまで議論してきた R Markdown を最大限活用するための, あらゆるコンポネントを変更する方法のより具体的な例を使って, あなたの絵の下書きに色をつけることができます. "],["basics.html", "3 基本", " 3 基本 この章では, R Markdown の重要な概念をいくつか提示します. まず「テキスト」「コード」という R Markdown の基本的なコンポネントを紹介します. 次に, R Markdown 文書をどうやって R スクリプトへ変換するか, あるいは逆の変換はどうやるかを提示します. もっと基本的な話を求める方は, R Markdown Definitive Guide (Xie, Allaire, and Grolemund 2018) の2章を見てください. 参考文献 "],["r-code.html", "3.1 コードチャンクとインライン R コード", " 3.1 コードチャンクとインライン R コード R Markdown 文書はテキスト (ナラティブ) とコードが混合してできています. Rmd 文書には2種類のコード, コードチャンクとインライン (行内) R コードです. 以下は簡単な例です. ```{r} x &lt;- 5 # 円の半径 ``` 半径 `r x` の円に対し, その面積は `r pi * x^2` である. 通常コードチャンクは ```{} で始まり, ``` で終わります. コードチャンク内ではコードを何行でも書いてかまいません. インライン R コードは `r ` という構文を使って文書のナラティブの中に埋め込まれます. 上記の例ではコードチャンク内で円の半径として変数 x を定義し, 次のパラグラフでこの円の面積を計算しています. チャンクオプションを通してコードチャンクの挙動と出力をカスタマイズできます (オプションはカーリー・ブレイス {} 内に与えます). 例のいくつかは11章で見つかるでしょう. コードチャンクに別のプログラミング言語のコードを書くこともできます (15 章を見てください). "],["rstudio-visual.html", "3.2 RStudio のビジュアルエディタで R Markdown を書く", " 3.2 RStudio のビジュアルエディタで R Markdown を書く あなたがまだ Markdown の書き方に慣れていないか, Markdown コードを書きたくなければ, RStudio ver. 1.4 には実験的ですが Markdown 文書用のビジュアルエディタがあります. これは図3.1で示すように Word のような伝統的な WYSIWYG なエディタと似ていると感じるでしょう. この完全なドキュメントは https://rstudio.github.io/visual-markdown-editing/ で見ることができます. 図 3.1: RStudio のビジュアル Markdown エディタ ビジュアルエディタによって, ヘッダ, 図, 表, 脚注などといった Pandoc でサポートされているほとんどあらゆる Markdown 要素を視覚的に編集できます. あなたは全ての構文を覚えなくてもよいのです. ある要素の構文を忘れた場合, RStudio ツールバー (図3.1参照) を使うかキーボードショートカットを使って, 要素を追加したり編集したりできます. 既に Markdown に熟練しているなら, ツールバーの一番右端のボタンを右クリックしてソースモードとビジュアルモードを切り替えられるので, 文書をソースモードのままで書くこともできます. "],["spin.html", "3.3 R スクリプトをレポートにレンダリングする", " 3.3 R スクリプトをレポートにレンダリングする 長らく RMarkdown を使っていても, 別の選択肢があることを見落としていることがあります. Dean Attali はこれを“knitr の秘宝と読んでいます. 純粋な R スクリプトを直接レンダリングできるということです. RStudio IDE をお使いなら, R スクリプトをレンダリングするキーボードショートカットは Rmd 文書を knit するときと同じ (Ctrl / Cmd + Shift + K) です. R スクリプトをレポートにレンダリングすると, まず knitr::spin() 関数が呼ばれスクリプトが Rmd ファイルに変換されます. この関数こそ Dean Attali が「knitrの秘宝」と呼んでいるものです. レポートには全てのテキストとグラフィックの出力が掲載されます. レポートの要素を細かく管理したいなら, 以下のような構文が役に立ちます. Roxygen コメントはテキストとして扱われます. roxygen コメントは #' で始まる R のコメントで, レポートにナラティブを書くのに役立ちます. コメント内ではあらゆる Markdown 構文を使うことができます. #+ で始まるコメントは knitr のチャンクヘッダとして扱われます. 例えば, knitr::spin() は #+ label, fig.width=5 というコメントを, R Markdown の ```{r label, fig.width=5} というチャンクヘッダへ翻訳します. {{ code }} で囲まれた R コードは R Markdown のインライン R コードへ翻訳されます. {{ code }} は1行で書かなければならないことに注意してください. YAML フロントマターも, R スクリプトの冒頭の roxigen コメント内に書くことができます. YAML フィールドのインデントには, 特に気をつけてください. これはとても大事なところです. YAML のインデントを省くとYAMLに記述したデータ構造は別の正しくないものになります. 例えば keep_tex: true というフィールドは, 後の例のように pdf_document 以下に2つ以上のスペースでインデントするべきです. /* と */ の間の任意のテキストは無視されます (つまり, 完全にコメントとして扱われます) 上記のルールの全ての例を表現したのが以下です. #&#39; --- #&#39; title: &quot;純粋な R script から生成したレポート&quot; #&#39; output: #&#39; pdf_document: #&#39; keep_tex: true #&#39; --- #&#39; #&#39; これは `knitr::spin()` によって生成されたレポートです. #&#39; #&#39; **knitr** オプションをいくつか試してみましょう: #+ echo=FALSE, fig.width=7 # これは通常の R コメント文です. plot(cars) #&#39; ここにインラインの値を書きましょう. $\\pi$ の値は {{ pi }} #&#39; であると知られています. #&#39; #&#39; 最後に, 全ての roxygen コメントは任意だということを書いておきます. #&#39; プロットの大きさなど出力要素をコントロールしようと思わない限り #&#39; チャンクオプションも必要でありません # /* C 言語のコメントのように /* と */ の間にコメントを書きましょう: Sys.sleep(60) # */ このスクリプトがレポートにレンダリングされた時, knitr::spin() はこれを R Markdown へと変換します. --- title: &quot;純粋な R script から生成したレポート&quot; output: pdf_document: keep_tex: true --- これは `knitr::spin()` によって生成されたレポートです. **knitr** オプションをいくつか試してみましょう: ```{r echo=FALSE, fig.width=7} # これは通常の R コメント文です. plot(cars) ``` ここにインラインの値を書きましょう. $\\pi$ の値は ``r pi `` であると知られています. 最後に, 全ての roxygen コメントは任意だということを書いておきます. プロットの大きさなど出力要素をコントロールしようと思わない限り チャンクオプションも必要でありません このレポート生成方法は, 主に R スクリプトを使って作業していて多くのナラティブを必要としないときに, 特に役立つでしょう. レポートの中でテキストの割合が高いなら, 全てのテキストを roxygen コメントに入れなくてもいい R Markdown がより良い選択でしょう. "],["purl.html", "3.4 Markdown から R script への変換", " 3.4 Markdown から R script への変換 R Markdown から全ての R コードを取り出したい時は, knitr::purl() 関数を呼ぶことができます. 以下は purl.Rmd というファイル名の簡単な Rmd の例です. --- title: R コードを取りだすために `purl()` を使いましょう --- `knitr::purl()` 関数は **knitr** 文書から R コードチャンクを取り出しコードを R スクリプトに保存します. 以下は簡単なチャンクです. ```{r, simple, echo=TRUE} 1 + 1 ``` `r 2 * pi` のようなインライン R 式はデフォルトでは無視されます. 特定のコードチャンクを取り出してほしくない場合は, 以下の例のようにチャンクオプション `purl = FALSE` を設定できます. ```{r, ignored, purl=FALSE} x = rnorm(1000) ``` knitr::purl(\"purl.Rmd\") を呼び出したら, 以下の R スクリプト (デフォルトのファイル名は purl.R) が生成されます. ## ---- simple, echo=TRUE------------------------------ 1 + 1 上記の R スクリプトでは, チャンクオプションがコメントとして書かれています. 純粋な R コードが欲しい場合, knitr::purl() を documentation = 0 という引数を与えて呼べば, 以下のような R スクリプトが生成されます. 1 + 1 テキストを全て残したいときは documentation = 2 引数を使えば, 以下のような R スクリプトを生成します. #&#39; --- #&#39; title: R コードを取りだすために `purl()` を使いましょう #&#39; --- #&#39; #&#39; `knitr::purl()` 関数は **knitr** 文書から R コードチャンクを取り出しコードを R スクリプトに保存します. #&#39; #&#39; 以下は簡単なチャンクです. #&#39; ## ---- simple, echo=TRUE------------------------------ 1 + 1 #&#39; #&#39; `r 2 * pi` のようなインライン R 式はデフォルトでは無視されます. #&#39; #&#39; 特定のコードチャンクを取り出してほしくない場合は, 以下の例のようにチャンクオプション `purl = FALSE` を設定できます. #&#39; purl = FALSE というオプションのあるコードチャンクは R スクリプトから除外されることに注意してください. インライン R コードはデフォルトでは無視されます. R スクリプトにインライン表現も含めたいなら, knitr::purl() を呼ぶ前に R のグローバルオプション options(knitr.purl.inline = TRUE) を設定する必要があります. "],["notebook.html", "3.5 R Markdown Notebook", " 3.5 R Markdown Notebook R Markdown Definitive Guide (Xie, Allaire, and Grolemund 2018) の Section 2.2 で言及したように, Rmd 文書をコンパイルする方法はいくつかあります. その1つは次の例のように html_notebook という出力フォーマットで R Markdown Notebook を使うことです. --- title: An R Markdown Notebook output: html_notebook --- RStudio でこの出力フォーマットを使うと, ツールバー上の Knit ボタンが Preview ボタンになります. notebook を使う主な利点は Rmd 文書を同じRセッションで繰り返し作業できることです. コードチャンクにある緑色の矢印ボタンを押せばチャンクを個別に随時実行でき, エディタ上でテキストやグラフの出力を見られます. ツールバー上の Preview ボタンを押すと, Rmd 文書を既に実行したコードチャンクの出力を含む HTML 文書へレンダリングするだけです. Preview ボタンは一切のコードチャンクを実行しません. これと比較して, 他の出力フォーマットを使い knit ボタンを押したときには, RStudio は文書全体をコンパイルする (つまり全てのコードチャンクが一気に実行されます) ために R セッションを新規で立ち上げますので, たいていはもっと時間がかかります. コードチャンクを個別に実行した時に出力がインライン表示されるという RStudio のデフォルトの挙動が気に入らないなら, Tools -&gt; Global Options -&gt; R Markdown から “Show output inline for all R Markdown documents” というオプションのチェックを外すことができます. 以降, コードチャンクを実行すると出力はソースエディタ内ではなく R コンソールに表示されます. このオプションは以下のように YAML メタデータで個別の Rmd 文書ごとに設定することもできます. editor_options: chunk_output_type: console 参考文献 "],["document-elements.html", "4 文書の要素", " 4 文書の要素 本章では, 改ページ, YAML メタデータ, セクションヘッダ, 引用, 相互参照, 数式, アニメーション, 対話的プロット, ダイアグラム, コメントといった R Markdown 文書の要素をカスタマイズしたり生成したりするのに使える豆知識と小ワザを紹介します. "],["pagebreaks.html", "4.1 改ページ (改段) を挿入する", " 4.1 改ページ (改段) を挿入する 改ページしたい場合, \\newpage を文書に挿入できます.15 これは LaTeX コマンドですが, rmarkdown パッケージは LaTeX 出力フォーマットでも, 以下のような HTML, Word, ODT などのいくつかの非 LaTeX 出力フォーマットでも認識することができます.16 --- title: Breaking pages output: pdf_document: default word_document: default html_document: default odt_document: default --- # 第一節 \\newpage # 第二節 これは Pandoc の Lua フィルタ に基づく機能です (4.20 節参照). 技術的なことに興味のある方はこのパッケージのビネットを見てください. vignette(&quot;lua-filters&quot;, package = &quot;rmarkdown&quot;) 訳注: 正確には \\newpage コマンドは改「段」です. 二段組の場合, 次の段に改めるため, 必ずページを改めるわけではありません.↩︎ HTML 出力では, 改ページは HTML ページの印刷時のみ意味をなし, それ以外では HTML は単一の連続したページになるため, 改ページを見ることはありません.↩︎ "],["dynamic-yaml.html", "4.2 文書タイトルを動的に設定する", " 4.2 文書タイトルを動的に設定する インライン R コード (3.1節)は, Rmd 文書内のどこでも, YAML メタデータの部分であっても, 使うことができます. つまり次の例のように, インライン R コードによって文書のタイトルなどの YAML メタデータを動的に生成できるということです. --- title: &quot;自動車 `r nrow(mtcars)` 台の分析&quot; --- 文書タイトルが後の文書内で作成される R の変数に依存する場合, 以下の例のように変数の後にくる YAML セクションに title フィールドを書き加えることができます. --- author: &quot;利口なアナリスト&quot; output: pdf_document --- 我々の市場シェアを頑張って計算してみました. ```{r} share &lt;- runif(1) ``` --- title: &quot;我々の市場シェアは今や `r round(100 * share, 2)`% です!&quot; --- これはとても `r if(share &gt; 0.8) &quot;喜ばしい&quot; else &quot;悲しい&quot;` ことです. 上記の例では, 変数 share を生成してから文書のタイトルを追加しています. このような場合であってもうまくいくのは, Pandoc は文書内に YAML セクションをいくつ書いても読み込み, そして全てをマージすることができるためです. タイトルだけでなくどの YAML フィールドも, パラメータ化されたレポートから動的に生成することができます (17.4 節参照). 例えばこのように. --- title: &quot;`r params$doc_title`&quot; author: &quot;利口なアナリスト&quot; params: doc_title: &quot;デフォルトのタイトル&quot; --- タイトルを動的なパラメータにしておくと, タイトルだけ異なるレポートを簡単に一括で生成できます. この節ではタイトルを例にしましたが, このアイディアは YAML セクションのどのメタデータのフィールドにも適用可能です. "],["document-metadata.html", "4.3 R コード内で文書メタデータにアクセスする", " 4.3 R コード内で文書メタデータにアクセスする Rmd 文書をコンパイルする際には, YAML セクションの全てのメタデータはリストオブジェクト rmarkdown::metadata に格納されます. 例えば rmarkdown::metadata$title には文書のタイトルが与えられます. この metadata オブジェクトは R コード内で使うことができるので, YAML メタデータに与えられた情報をハードコードしなくてすみます. 例えば以下のように blastula パッケージ (Iannone and Cheng 2020) で Eメールを送る時, 文書のタイトルをメールの件名に, 著者フィールドを送信者情報に使うことができます. --- title: 重要なレポート author: John Doe email: john@example.com --- 重要な分析ができましたので結果をメールで送りたいと思います. ```{r} library(rmarkdown) library(blastula) smtp_send( ..., from = setNames(metadata$email, metadata$author), subject = metadata$title ) ``` 参考文献 "],["unnumbered-sections.html", "4.4 番号のない節", " 4.4 番号のない節 ほとんどの出力フォーマットは number_sections オプションをサポートしています. これを true に設定すれば, 以下の例のように節への番号付けを有効にできます. output: html_document: number_sections: true pdf_document: number_sections: true 特定の節に番号を付けたくないならば, number_sections オプションは true のままにして, その節のヘッダの直後に {-} を加えます. 例えばこのように. # この節には番号がつきません {-} 全く同じことを, {.unnumbered} を使ってもできます. 例えば {.unnumbered #section-id} のように, 他の属性を追加することもできます. 詳細は https://pandoc.org/MANUAL.html#extension-header_attributes を確認してください. 付番されていない節は記述に特記情報を追加するのに使われます. 例えば本書では, 「はじめに」と「著者について」 の章は本文ではないため付番されていません. 図4.1を見ればわかるように, 実際の本文は番号の付いていない2つの章の後から始まり, 本文の章は付番されています. 図 4.1: 付番された章とされていない章を示すための目次のスクリーンショット 節番号は1つづつ増えます. もし付番した節の後に付番されていない節を挿入し, その後さらに付番した節が始まると, 節番号は再び増加していきます. "],["bibliography.html", "4.5 参考文献と引用", " 4.5 参考文献と引用 参考文献目録を出力文書に含める方法の概要は, Xie (2016) の Section 2.8 を見るとよいでしょう. 基本的な使用法として, YAML メタデータの bibliography フィールドに文献目録ファイルを指定する必要があります. 例えばこのようにします. --- output: html_document bibliography: references.bib --- この BibTeX データベースは *.bib という拡張子の付いたプレーンテキストとして与えられ, ファイルに文献アイテムがこのようなエントリで含まれています. @Manual{R-base, title = {R: A Language and Environment for Statistical Computing}, author = {{R Core Team}}, organization = {R Foundation for Statistical Computing}, address = {Vienna, Austria}, year = {2019}, url = {https://www.R-project.org}, } 文書内では @key という構文で文献アイテムを直接引用することができます. key 部分はエントリの最初の行にある引用キーのことです. 上記の例なら @R-base です. 括弧で囲んで引用したいなら, [@key] を使います. 複数のエントリを同時に引用するなら, [@key-1; @key-2; @key-3] のようにセミコロンでキーを区切ります. 著者名を表示しないのなら, [-@R-base] のように @ の前にマイナス記号を付けます. 4.5.1 引用スタイルの変更 Pandoc は Chicago 式の著者名-出版年形式の引用スタイルと参考文献スタイルをデフォルトで使います. 他のスタイルを使うには, 例えば例のように, メタデータフィールドの csl で CSL (Citation Style Language) ファイルを指定します. --- output: html_document bibliography: references.bib csl: biomed-central.csl --- 必要としているフォーマットを見つけるには, Zotero Style Repository, を使うことをおすすめします. これは必要なスタイルの検索とダウンロードが簡単にできます. CSL ファイルは個別のフォーマット要件に合うようにを修正できます. 例えば “et al.” の前に表示する著者の人数を変更して短縮できます. これは https://editor.citationstyles.org にあるようなビジュアルエディタを使って簡単にできます. 4.5.2 引用していない文献を参考文献に追加する デフォルトでは参考文献には文書で直接参照されたアイテムのみ表示されます. 本文中に実際に引用されていない文献を含めたい場合, notice というダミーのメタデータフィールドを定義し, そこで引用します. --- nocite: | @item1, @item2 --- 4.5.3 全てのアイテムを参考文献に掲載する 文献目録のすべてのアイテムを明示的に言及したくないが, 参考文献には掲載したいというなら, 以下のような構文が使えます. --- nocite: &#39;@*&#39; --- これは全てのアイテムを参考文献として強制的に掲載させます. 4.5.4 参考文献の後に補遺を掲載する (*) デフォルトでは参考文献は文書全体の最後に掲載されます. しかし参考文献一覧の後に追加のテキストを置きたいこともあるでしょう. 一番よくあるのは文書に補遺 (appendix) を含めたいときです. 以下に示すように, &lt;div id=\"refs\"&gt;&lt;/div&gt; を使うことで参考文献一覧の位置を強制変更できます. # 参考文献 &lt;div id=&quot;refs&quot;&gt;&lt;/div&gt; # 補遺 &lt;div&gt; は HTML タグですが, この方法は PDF など他の出力フォーマットでも機能します. さらによい方法としては以下の例のように bookdown パッケージ (Xie 2021a) を使い, 補遺の開始前に special header # (APPENDIX) Appendix {-} が挿入できます. # 参考文献 &lt;div id=&quot;refs&quot;&gt;&lt;/div&gt; # (APPENDIX) 補遺 {-} # 追加情報 これは「補遺 A」になる. # さらにもう1つ これは「補遺 B」になる. LaTeX/PDF および HTML フォーマットでは補遺の付番スタイルは自動的に変更されます (たいていは A, A.1, A.2, B, B.1, … という形式です). 参考文献 "],["write-bib.html", "4.6 R パッケージの引用を生成する", " 4.6 R パッケージの引用を生成する R パッケージを引用するには, base R の citation() を使うことができます. BibTeX 用の引用エントリを生成したいなら, citation() の返り値を toBibtex() を与えることができます. 例えばこうです. toBibtex(citation(&quot;xaringan&quot;)) @Manual{, title = {xaringan: Presentation Ninja}, author = {Yihui Xie}, year = {2021}, note = {R package version 0.22}, url = {https://CRAN.R-project.org/package=xaringan}, } toBibtex() で生成されたエントリを使うには, 出力を .bib ファイルにコピーし, 引用キーを追加しなければなりません (例えば @Manual{, の部分を @Manual{R-xaringan, と書き換える). これは knitr::write_bib() 関数によって自動化できます. この関数は引用エントリを生成し, 自動的にキーを加えてファイルに書き込みます. 例えばこのようにします. knitr::write_bib(c(.packages(), &quot;bookdown&quot;), &quot;packages.bib&quot;) 第1引数はパッケージ名の文字列ベクトルで, 第2引数は .bib ファイルのパスであるべきです. 上記の例では, .packages() は現在の R セッションが読み込んでいる全てのパッケージ名を返します. これらのパッケージのいずれかが更新された (例えば著者, タイトル, 年, あるいはバージョンが変更された) とき, write_bib() は自動的に .bib を更新できます. 引用エントリには2つのタイプが選択肢としてあります. 1つはパッケージの DESCRIPTION ファイルをもとに生成したもので, もう1つは, もしパッケージに CITATION ファイルが存在するなら, そこから生成したものです. 前者のタイプは引用キーが R-(パッケージ名) という形式 (例えば R-knitr) になり, 後者のタイプはパッケージ名と公開年を結合したもの (例: knitr2015) がキーとなります . 同じ年に複数のエントリがあるときは, 接尾文字が追加されます. 例えば knitr2015a と knitr2015b のように. 前者のタイプはしばしばパッケージ自体を引用 (つまり, ソフトウェアとして) するのに使われますが, 後者のタイプは論文や書籍のようなパッケージと関連する出版物といったものが多いです. knitr::write_bib(c(&quot;knitr&quot;, &quot;rmarkdown&quot;), width = 60) @Manual{R-knitr, title = {knitr: A General-Purpose Package for Dynamic Report Generation in R}, author = {Yihui Xie}, year = {2021}, note = {R package version 1.34}, url = {https://yihui.org/knitr/}, } @Manual{R-rmarkdown, title = {rmarkdown: Dynamic Documents for R}, author = {JJ Allaire and Yihui Xie and Jonathan McPherson and Javier Luraschi and Kevin Ushey and Aron Atkins and Hadley Wickham and Joe Cheng and Winston Chang and Richard Iannone}, year = {2021}, note = {R package version 2.11}, url = {https://CRAN.R-project.org/package=rmarkdown}, } @Book{knitr2015, title = {Dynamic Documents with {R} and knitr}, author = {Yihui Xie}, publisher = {Chapman and Hall/CRC}, address = {Boca Raton, Florida}, year = {2015}, edition = {2nd}, note = {ISBN 978-1498716963}, url = {https://yihui.org/knitr/}, } @InCollection{knitr2014, booktitle = {Implementing Reproducible Computational Research}, editor = {Victoria Stodden and Friedrich Leisch and Roger D. Peng}, title = {knitr: A Comprehensive Tool for Reproducible Research in {R}}, author = {Yihui Xie}, publisher = {Chapman and Hall/CRC}, year = {2014}, note = {ISBN 978-1466561595}, url = {http://www.crcpress.com/product/isbn/ 9781466561595}, } @Book{rmarkdown2018, title = {R Markdown: The Definitive Guide}, author = {Yihui Xie and J.J. Allaire and Garrett Grolemund}, publisher = {Chapman and Hall/CRC}, address = {Boca Raton, Florida}, year = {2018}, note = {ISBN 9781138359338}, url = {https://bookdown.org/yihui/rmarkdown}, } @Book{rmarkdown2020, title = {R Markdown Cookbook}, author = {Yihui Xie and Christophe Dervieux and Emily Riederer}, publisher = {Chapman and Hall/CRC}, address = {Boca Raton, Florida}, year = {2020}, note = {ISBN 9780367563837}, url = {https://bookdown.org/yihui/rmarkdown-cookbook}, } ファイルパスの引数がないと, knitr::write_bib() は上記の例のように引用エントリをコンソールに出力します. write_bib() は既存の文献目録ファイルを上書きするように設計されていることに注意してください. 文献目録に手動で他のエントリを追加したい場合, 2つ目の .bib ファイルを作成して, この例のように bibliography フィールドで参照してください. --- bibliography: [packages.bib, references.bib] --- ```{r, include=FALSE} knitr::write_bib(file = &#39;packages.bib&#39;) ``` 上記の例では packages.bib は自動で生成されたものなので, 手動で変更すべきではありません. それ以外の全ての引用エントリは references.bib に手動で書き込むことができます. ここまでは R パッケージの引用を生成する方法を1つだけ紹介しています. それ以外のタイプの文献で動的に引用を生成するには, knitcitations パッケージ (Boettiger 2021) を見てください. 参考文献 "],["cross-ref.html", "4.7 文書内の相互参照", " 4.7 文書内の相互参照 相互参照 はあなたの文書を通して読者を誘導するのに役に立つ方法であり, R Markdown ではこれを自動的に行なえます. これは bookdown 本の Chapter 2 で既に説明されていますが, 以下で簡潔な説明をします. 相互参照を使用するにあたって, 以下が必要になります. bookdown 出力フォーマット: 相互参照は基本となる rmarkdown パッケージでは直接提供されず, bookdown (Xie 2021a) による拡張機能として提供されています. よって YAML の output フィールドで bookdown のフォーマット (例: html_document2, pdf_document2, word_document2 など) を使用しなければなりません. 図 (または表) に対するキャプション: キャプションのない図は単なる画像として直接埋め込まれるたあめ, 付番された図 (figure) にはなりません. ラベルの設定されたコードチャンク: チャンクが生成した図を参照する識別子を提供してくれます. これらの条件が整って初めて, テキスト内で \\@ref(type:label) という構文を使って相互参照を作成できます. label はチャンクラベルであり, type は参照される環境 (例:, tab, fig, eqn) です. 以下に例を示します. --- title: 図, 表, 数式を相互参照する author: bookdown による生成 output: bookdown::pdf_document2: latex_engine: lualatex bookdown::html_document2: default documentclass: ltjsarticle --- 図 \\@ref(fig:cars-plot) を見よ. ```{r cars-plot, fig.cap=&quot;自動車のデータ&quot;, echo=FALSE} par(mar = c(4, 4, .2, .1)) plot(cars) # a scatterplot ``` 次に数式\\@ref(eq:mean) を見よ. \\begin{equation} \\bar{X} = \\frac{\\sum_{i=1}^n X_i}{n} (\\#eq:mean) \\end{equation} さらに表 \\@ref(tab:mtcars) を見よ. ```{r mtcars, echo=FALSE} knitr::kable(mtcars[1:5, 1:5], caption = &quot;mtcars データ&quot;) ``` この文書の出力を図 4.2 に示します. 図 4.2: R Markdown 文書内の相互参照の例 数式, 定理, 節の見出しにも相互参照することができます. これらのタイプの参照の方法は bookdown 本の 2.2, 2.6節でより詳しく説明されています. 参考文献 "],["update-date.html", "4.8 日付を自動的に更新する", " 4.8 日付を自動的に更新する 出力されたレポートに Rmd 文書がコンパイルされた日付を表示したいなら, YAML メタデータの date フィールドにインライン R コードを追加し, 現在の日付を得るために Sys.Date() or Sys.time() 関数を使用できます. date: &quot;`r Sys.Date()`&quot; もっと人間にとって読みやすい, 特定の日次フォーマットを指定したいかもしれません. 例えば以下のようにします. date: &quot;`r format(Sys.time(), &#39;%x&#39;)`&quot; 例えば 2021年9月15日 といったコードはあなたが文書を knit するごとに, 日付を動的に生成します. 日付のフォーマットをカスタマイズしたいならば, ご自分でフォーマット文字列を与えて変更できます. いくつか例をお見せしましょう. %Y %B: 2021 9月 %y/%m/%d: 21/09/15 %b%d (%a): 9月15 (水) 表 4.1 は POSIXct フォーマットの一覧です. 表 4.1: Rにおける日付と時刻のフォーマット コード 意味 コード 意味 %a 曜日の略称 %A 曜日の名称 %b 月の略称 %B 月の名称 %c ロケール依存の時刻フォーマット %d 数値表記の日 %H 数値表記の時間 (24 時間) %I 数値表記の時間 (12 時間) %j 1年の何日目か %m 数値表記の月 %M 数値表記の分 %p ロケール依存の午前/午後フォーマット %S 数値表記の秒 %U 年の何週目か (日曜日始まり) %w 数値表記の曜日 (0=日曜日) %W 年の何週目か (月曜日始まり) %x ロケール依存の日付フォーマット %X ロケール依存の時刻フォーマット %y 下2桁表記の年 %Y 4桁表記の年 %z GMT との時差 %Z タイムゾーン (文字表記) 最後に, 説明文を日付に含めたいときのことを書いておきます. このように Rコードの前に「最終コンパイル日」のような何らかの文を追加することができます. date: &quot;最終コンパイル日 `r format(Sys.time(), &#39;%Y/%m/%d&#39;)`&quot; "],["multiple-authors.html", "4.9 文書に複数の著者を表記する", " 4.9 文書に複数の著者を表記する R Markdown 文書のYAML フロントマターに複数の著者を加える方法は複数あります. 単純に, 全員を同列に並べたい場合, 1つの文字列を与えることでできます. 例えばこのように. --- title: &quot;無題&quot; author: &quot;John Doe, Jane Doe&quot; --- 別の方法として, 各エントリごとに行を分けたいならば, YAML フィールドにエントリのリストを与えることができます. これは著者ごとにEメールアドレスや所属情報を加えたいときに役に立ちます. 例えばこのように. --- author: - John Doe, 組織1 - Jane Doe, 組織2 --- 追加情報を文書の脚注として追記したい時, Markdown 構文の ^[] を利用できます. これは著者ごとに連絡先Eメールや住所といった多くの情報を含めたい場合により便利です. 厳密な動作は出力フォーマットに依存します. --- author: - John Doe^[組織1, john@example.org] - Jane Doe^[組織2, jane@example.org] --- 特定の R Markdown テンプレートを使うと YAML に追加パラメータを直接指定できます. 例えば Distill 出力フォーマットは url, affiliation, affiliation_url を指定することが可能です. まずは distill パッケージ (Allaire, Iannone, et al. 2021) をインストールします. install.packages(&quot;distill&quot;) Distill フォーマットは詳細な著者情報を与えて使うことができます. 例えばこのように. --- title: &quot;R Markdown のための Distill&quot; author: - name: &quot;JJ Allaire&quot; url: https://github.com/jjallaire affiliation: RStudio affiliation_url: https://www.rstudio.com output: distill::distill_article --- 参考文献 "],["figure-number.html", "4.10 図のキャプションへの付番", " 4.10 図のキャプションへの付番 以下の例のように, bookdown (Xie 2021a) 出力フォーマット を, 図のキャプションに図番号を追加するのに使うことができます. --- output: bookdown::html_document2 --- ```{r cars, fig.cap = &quot;すごいプロット&quot;} plot(cars) ``` ```{r mtcars, fig.cap = &quot;これもすごいプロット&quot;} plot(mpg ~ hp, mtcars) ``` 4.7 節では表や数式といった他の要素でどのように動くか, そして付番された要素をテキスト内で相互参照する方法を実演しています. html_document2 の他にも, pdf_document2, word_document2 といった他の出力に対する同様のフォーマット関数もあります. bookdown 以外の R Markdown 出力フォーマットにもこの機能を追加できます. 鍵となるのはこれらが bookdown 出力フォーマットの「基本フォーマット」であることです. 例えば, rticles::jss_article フォーマットで図に付番と相互参照をするために以下が使えます. output: bookdown::pdf_book: base_format: rticles::jss_article bookdown 出力フォーマット関数のヘルプページを読んで, base_format 引数があるかどうか確認してみてください (例: ?bookdown::html_document2). 参考文献 "],["combine-words.html", "4.11 単語をコンマ区切りで結合する", " 4.11 単語をコンマ区切りで結合する 文字列ベクトルを人間の読みやすい形で出力したいとします. 例えば x &lt;- c(\"apple\", \"banana\", \"cherry\") について, きっとあなたは [1] \"apple\" \"banana\" \"cherry\" のような R が通常ベクトルを出力する形式は好まず, 代わりに “apple, banana, and cherry” という文字列がほしいのではないでしょうか. R 基本関数には文字列ベクトルを連結して1つにまとめる paste() があります. 例えば paste(x, collapse = ', ') とすれば, 出力は \"apple, banana, cherry\" となるでしょう. この方法の困ったところは (1) 接続詞 “and” が欠けており, (2) ベクトルの要素が2つだけの場合はコンマを使うべきでない (\"apple, banana\" ではなく \"apple and banana\" という出力になるべき) ということです. knitr::combine_words() 関数は文字列ベクトルの長さにかかわらず, 要素を連結して文にできます. 基本的に, 単語1つに対してはそのまま同じものを返し, “A and B” という2つの単語に対しては \"A and B\" と返し, 3つ以上なら \"A, B, C, ..., Y, and Z\" というふうに返します. この関数はさらに出力をカスタマイズするいくつかの引数を持っています. 例えば出力される単語をバッククオートで囲みたいなら, knitr::combine_words(x, before = '`') を使うこともできます. 以下に他の引数についてもさらなる例を示します. これらの出力例から引数の意味がよくわからないのであれば, ヘルプページ ?knitr::combine_words もご覧ください. v &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) knitr::combine_words(v) ## apple, banana, and cherry knitr::combine_words(v, before = &quot;`&quot;, after = &quot;&#39;&quot;) ## `apple&#39;, `banana&#39;, and `cherry&#39; knitr::combine_words(v, sep = &quot;、&quot;, and = &quot;そして&quot;) ## apple、banana、そしてcherry knitr::combine_words(v, sep = &quot; / &quot;, and = &quot;&quot;) ## apple / banana / cherry knitr::combine_words(v[1]) # 単語1つ ## apple knitr::combine_words(v[1:2]) # 単語2つ ## apple and banana knitr::combine_words(LETTERS[1:5]) ## A, B, C, D, and E この関数はインライン R コードを使うときに特に使いやすいでしょう. 例えばこのように. 今朝は`r knitr::combine_words(v, sep = &#39;、&#39;, and=&#39;&#39;)`を食べた. "],["linebreaks.html", "4.12 複数の改行コードを維持する", " 4.12 複数の改行コードを維持する Markdown ユーザは, verbatim 環境 (コードブロック) 以外の場所では空白 (改行コード含む) は大抵の場合意味を持たないことに気づき, 驚くでしょう. 2つ以上のスペースはスペース1つと同じであり, 改行1つはスペース1つと同じです. LaTeX や HTML を使ったことがあるなら, これらの言語と同じルールであるため驚くことはないかもしれません. Markdown では, 空白行はしばしば段落などの要素の分離に使われます. 新しい段落に入らずに改行をするには, 末尾にスペース2つを追加しなければなりません. 特に詩や歌詞を引用したいときなど, 複数回改行したいときもあるかもしれません. 各行の末尾にスペース2つを手動で書き加えるのはうんざりする作業です. blogdown:::quote_poem() はこの作業を自動でやってくれます. 例えばこのように. blogdown:::quote_poem(c(&quot;かたつむり&quot;, &quot;そろそろ登れ&quot;, &quot;富士の山&quot;)) ## [1] &quot;&gt; かたつむり \\nそろそろ登れ \\n富士の山&quot; RStudio IDE と blogdown パッケージ (Xie, Dervieux, and Presmanes Hill 2021) をインストールして使っているなら, 改行を維持したいテキストを選択し, ツールバーの “Addins” から RStudio アドインの “Quote Poem” をクリックすることができます. 例えば以下のテキスト (fenced code block 記法内) は末尾にスペースが付いていません. 田子の浦ゆ うち出でてみれば 真白にそ 富士の高嶺に 雪は降りける --- 山部赤人 上記の詩句を選択肢, RStudio アドインの “Quote Poem” をクリックすれば, こう出力されます. 田子の浦ゆ うち出でてみれば 真白にそ 富士の高嶺に 雪は降りける — 山部赤人 たまに「fenced code block は空白を維持するのに, 詩句をコードブロックに書くのはなぜですか」と質問があります. コードは詩的でありますが, 詩はコードではありません. コーディング中毒にならないようにしましょう. :::{.infobox .caution data-latex”{caution}“} 訳注 上記の例では, 最終行の出典の右寄せが再現できません. 右寄せには Pandoc の fenced Div blocks の機能が使用されています (9.6節). 詳細はこの文書のソース (Rmd と CSSファイル) を確認してください. HTML 版をご覧ならば上部ツールバーの “Edit” ボタンからソースのURLを辿ることができます. ::: 参考文献 "],["equatiomatic.html", "4.13 モデルを数式に変換する", " 4.13 モデルを数式に変換する Daniel Anderson らによって開発された equatiomatic パッケージ (Anderson, Heiss, and Sumners 2021) (https://github.com/datalorax/equatiomatic) は R で当てはめたモデルに対応する数式を表示するための便利な自動化された手段です. 簡単な例を以下に示します. fit &lt;- lm(mpg ~ cyl + disp, mtcars) # 理論モデルを表示 equatiomatic::extract_eq(fit) \\[ \\operatorname{mpg} = \\alpha + \\beta_{1}(\\operatorname{cyl}) + \\beta_{2}(\\operatorname{disp}) + \\epsilon \\] # 実際の係数を表示 equatiomatic::extract_eq(fit, use_coefs = TRUE) \\[ \\operatorname{\\widehat{mpg}} = 34.66 - 1.59(\\operatorname{cyl}) - 0.02(\\operatorname{disp}) \\] 実際の数式を表示するには, チャンクオプション results = \"asis\" (オプションの意味は11.11節参照) が必要です. そうしないと, テキスト出力がそのまま表示されてしまいます. このパッケージについてより詳しく知りたいならば, ドキュメントを読み, Github 上での開発状況を追ってください. 参考文献 "],["animation.html", "4.14 複数の R プロットからアニメーションを作成する", " 4.14 複数の R プロットからアニメーションを作成する 1つのコードチャンクで連続したプロットを生成したとき, これらを結合して1つのアニメーションを生成できます. 出力フォーマットが HTML なら, これは簡単です. gifski パッケージ (Ooms 2021a) をインストールし, チャンクオプション animation.hook = \"gifski\" 設定するだけです. 図4.3 はシンプルな「パックマン」のアニメーションで, これは以下のコードで作成しました. ```{r, animation.hook=&quot;gifski&quot;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&#39;red&#39;, &#39;yellow&#39;), labels = NA) } ``` 図 4.3: パックマンのアニメーション アニメーションのフォーマットは GIF で, HTML 出力ではうまく動作しますが, LaTeX は GIF を直接サポートしていません. あなたが本書の PDF または印刷版を読んでいるなら, 図4.3 が2つの動かない画像になっているのはこれが理由です. 本書のオンライン版を読めば, 実際のアニメーションが見られるでしょう. PDF でもアニメーションを動作させることはできますが, 事前準備が2つ必要です. 第1に, LaTeX パッケージの animate を読み込む必要があります (方法は6.4節参照). 第2に, Acrobat Reader でのみアニメーションを見ることができます. 第2位に, Acrobat Reader でのみアニメーションの動作を見ることができます. その上で以下の例のように, チャンクオプション fig.show = \"animate\" で animate パッケージ を使いアニメーションを作成できるようにします. --- title: PDF でのアニメーション output: pdf_document: extra_dependencies: animate --- 以下のアニメーションは Acrobat Reader でのみ見ることができます. ```{r, fig.show=&#39;animate&#39;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&#39;red&#39;, &#39;yellow&#39;), labels = NA) } ``` アニメーションのイメージフレーム間の表示間隔はチャンクオプション interval で設定できます. デフォルトでは interval = 1 (つまり1秒) です. R パッケージ animation (Xie 2018) には, 統計的計算の方法やアイディアを表現するアニメーションの例がいくつか入っています. gganimate パッケージ (Pedersen and Robinson 2020) は ggplot2 (Wickham, Chang, et al. 2021) に基づいた滑らかなアニメーションの作成を可能にします. どちらも R Markdown で動作します. 参考文献 "],["diagrams.html", "4.15 ダイアグラムを作成する", " 4.15 ダイアグラムを作成する ダイアグラムやフローチャートを生成する, R とは独立したプログラム (例: Graphviz) は多くありますが, これらは Rmd 文書内のコードチャンク内で直接取り扱うほうが簡単です. R ではいくつかのパッケージが使用可能ですが, その中で DiagrammeR (Iannone 2020) とその他いくつかを最後に簡単に解説します. 完全なデモは https://rich-iannone.github.io/DiagrammeR/ で見ることができます. この節では基本的な使用法とダイアグラム内で R コードを使う方法を紹介します. 4.15.1 基本的なダイアグラム DiagrammeR はいくつかの異なるグラフ言語を使ってグラフを作成する方法を提供します. この節では Graphviz の例を提示しますが,17 DiagrammeR は純粋に R コードだけでグラフを作ることもできます. RStudio IDE は Graphviz (.gv) および mermaid (.mmd) ファイルをネイティブにサポートしています. これらのタイプのファイルを RStudio で編集すると, シンタックスハイライトされるという利点があります. RStudio のツールバーの “Preview” ボタンをクリックすると, ダイアグラムをプレビューすることができます. 図4.4 は, 4つのステップを表す４つの矩形で構成された, フローチャートの単純な例です. これは以下のコードで生成されています. DiagrammeR::grViz(&quot;digraph { graph [layout = dot, rankdir = TB] node [shape = rectangle] rec1 [label = &#39;ステップ 1. 起床する&#39;] rec2 [label = &#39;ステップ 2. コードを書く&#39;] rec3 [label = &#39;ステップ 3. ???&#39;] rec4 [label = &#39;ステップ 4. 収入を得る&#39;] # ノードIDでエッジを定義 rec1 -&gt; rec2 -&gt; rec3 -&gt; rec4 }&quot;, height = 500) 図 4.4: プログラマの絵空事を表したダイアグラム ノードの形状, 色, 線のタイプを定義したり, パラメータを追加したりできる拡張的な操作も用意されています. 4.15.2 図にパラメータを追加する Graphviz の置換機能は可読性を損なうことなく, R コードを Graphviz のグラフ設定に混ぜ込むことができます. @@ を伴う置換を指定するには, そこに置換されるのは有効な R 評価式であることを確実にせねばなりません. 評価式は脚注として置かれ, そして R ベクトルオブジェクトを返すものでなくてはなりません. @@ という記法のすぐ後には数字が続き, これは R 評価式の脚注番号に対応します. 図4.5はダイアグラムへの R コードの埋め込みと評価の例です. DiagrammeR::grViz(&quot; digraph graph2 { graph [layout = dot, rankdir = LR] # node definitions with substituted label text node [shape = oval] a [label = &#39;@@1&#39;] b [label = &#39;@@2&#39;] c [label = &#39;@@3&#39;] d [label = &#39;@@4&#39;] a -&gt; b -&gt; c -&gt; d } [1]: names(iris)[1] [2]: names(iris)[2] [3]: names(iris)[3] [4]: names(iris)[4] &quot;, height = 100) 図 4.5: R から入力されたパラメータを使用したダイアグラム 4.15.3 その他のダイアグラム作成パッケージ ダイアグラム作成に使えるパッケージとして, nomnoml (de Vries and Luraschi 2020), diagram (Soetaert 2020), dagitty (Textor, van der Zander, and Ankan 2021), ggdag (Barrett 2021), plantuml (https://github.com/rkrug/plantuml) といったものも見ておくとよいでしょう. 参考文献 "],["special-chars.html", "4.16 特殊文字をエスケープする", " 4.16 特殊文字をエスケープする Markdown 構文で特殊な意味を持つ文字がいくつかあります. これらの文字を直接使いたい場合, エスケープしなければなりません. 例えばテキストを囲むアンダースコアの組はたいていの場合テキストをイタリック体にします. イタリック体ではなく, アンダースコアをそのまま表示させたいなら, アンダースコアをエスケープする必要があります. 特殊な文字をエスケープする方法は, その直前にバックスラッシュを付けることです. 例えば「ここは\\_イタリックに\\_したくない.」というふうに. 同様に, # をセクションヘッダを表してほしくないなら, \\# これは見出しではない などと書くこともできます. 4.12 節で言及したように, 連続した空白文字は1つの正規スペースとして表示されます. 書いたとおりに連続した空白文字を表示させたいならば, 1つ1つにエスケープが必要です. 例えば ソーシャル \\ \\ \\ ディスタンス維持 というふうに. 空白がエスケープされた時, 空白は「改行しない空白」に変換されます. これは, そのスペースの位置では行が折り返されないということです. 例えば Mr.\\ Dervieux と言うふうに. "],["comments.html", "4.17 テキストのコメントアウト", " 4.17 テキストのコメントアウト ソース文書内のテキストを最終的な出力文書に表示させないようコメントアウトするのはとても便利です. この用途のため, HTML の構文である &lt;!-- ここにコメント --&gt; を使えます. コメントはどの出力フォーマットにも表示されません. コメントは1行でも, 複数行にも広げられます. これは草稿を書くのに便利でしょう. RStudio を使っているなら, 1行丸ごとコメントアウトするのにキーボードショートカット Ctrl + Shift + C (MacOS ならCommand + Shift + C) を使えます. "],["toc-unlisted.html", "4.18 目次から見出しを省略する", " 4.18 目次から見出しを省略する 目次に特定のセクションの見出しを表示させたくないなら, 見出しに2つのクラスを追加できます. unlisted と unnumbered です. 例えばこのように # 見出し {.unlisted .unnumbered} この機能は Pandoc 2.10 以降のバージョンが必要です. rmarkdown::pandoc_version() で Pandoc のバージョンを確認しましょう. バージョンが 2.10 より古いなら, 新しいバージョンをインストールすることになるでしょう (1.1節参照). "],["code-appendix.html", "4.19 全てのコードを補遺に置く (*)", " 4.19 全てのコードを補遺に置く (*) 対象読者がレポートを読む時, 計算の詳細に強く関心があるのでない限り, あなたはレポートにソースコードブロックを表示させたくないかもしれません. この用途で, チャンクオプション echo = FALSE を設定してソースコードを隠し, 読者がプログラムコードで気が散らないようにすることができます. しかしそれでも, ソースコードは再現可能性のある研究のために重要です. 読者はレポートを読み終わった後に計算の正しさを検証したいと思うかも知れません. この場合, 本文中の全てのコードブロックをまとめ, 文書の末尾 (例えば補遺として) に表示するというのは良い考えでしょう. チャンクオプションの ref.label と knitr::all_labels() 関数を使い, 文書内の全てのコードチャンクを取り出して1つのコードチャンクにまとめる簡単な方法があります. 例えばこのように. # 補遺: 本稿で使ったコード全文 ```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE} ``` チャンクオプション ref.label について詳しく知らないならば, 14.1.3節を読んでください. knitr::all_labels() 関数は文書内の全てのチャンクラベルを返すため, ref.label = knitr::all_labels() は全てのソースコードチャンクを回収しこのチャンクに持ってくることを意味します. チャンクオプション echo = TRUE (コードを表示させる) と eval = FALSE (全てのコードはすでに実行されているため, このコードチャンクは実行してはいけません) を付与すれば, 1つのコードチャンクに全てのソースコードのコピーを表示させられます. ref.label は任意のチャンクラベルの文字列ベクトルであるため, 補遺に表示するコードチャンクを一部だけにするようにラベルをフィルタリングできます. 以下はその例 (Ariel Muldoon によるものです) として setup と get-labels というラベルを排除しています. ```{r get-labels, echo = FALSE} labs = knitr::all_labels() labs = setdiff(labs, c(&quot;setup&quot;, &quot;get-labels&quot;)) ``` ```{r all-code, ref.label=labs, eval=FALSE} ``` knitr::all_labels() の引数を使ってコードチャンクをフィルタリングできます. 例えば Rcpp エンジン (engine == \"Rcpp\") を使用した全てのコードチャンクを得て, かつ文書に表示しない (echo = FALSE) ようにするには knitr::all_labels(engine == \"Rcpp\", echo == FALSE) を使えます. どのコードチャンクを補遺に表示したいのか, 正確にコントロールしたいならば, 指定したいコードチャンクに特殊なチャンクオプション appendix = TRUE を使い, それらのチャンクのラベルを得るのに ref.label = knitr::all_labels(appendix == TRUE) を使えます. "],["lua-filters.html", "4.20 Pandoc の Lua フィルタから操作する (*)", " 4.20 Pandoc の Lua フィルタから操作する (*) 技術的にはこの節は少し発展的ですが, Markdown の内容が Pandoc 抽象構文木 (AST) にどのように翻訳されるかを一度学べば, Lua というプログラミング言語を使ってどのような Markdown の要素も操作する力を得ることになります. 基本として, Pandoc は Markdown ファイルを読み取り, その内容が AST にパースされます. Pandoc はこの AST をLua スクリプトを使って修正することを可能にします. AST の意味するものを示すため, 以下のような簡単な Markdown ファイル (ast.md) を使います. ## 第1節 Hello world! このファイルは見出し1つとパラグラフ1つを持っています. Pandoc がこの内容をパースした後にファイルを JSON 形式に変換すれば, R ユーザーにとっては 結果として現れる AST を理解するよりも簡単でしょう. pandoc -f markdown -t json -o ast.json ast.md そして JSON ファイルを R に読み込み, データ構造を書き出します. この操作をしたら, Markdown の内容は再帰的なリストで表現されていることが分かるでしょう. その構造を以下に表します. ラベル t は “type”, c は “content” を表します. 例として見出しを取り上げてみましょう. タイプは “Header” で, その中身は3つの要素が含まれています. 見出しのレベル (2), 属性 (例えば ID が section-one であること), そしてテキストの内容です. xfun:::tree( jsonlite::fromJSON(&#39;ast.json&#39;, simplifyVector = FALSE) ) List of 3 |-pandoc-api-version:List of 2 | |-: int 1 | |-: int 22 |-meta : Named list() |-blocks :List of 2 |-:List of 2 | |-t: chr &quot;Header&quot; | |-c:List of 3 | |-: int 2 | |-:List of 3 | | |-: chr &quot;第1節&quot; | | |-: list() | | |-: list() | |-:List of 1 | |-:List of 2 | |-t: chr &quot;Str&quot; | |-c: chr &quot;第1節&quot; |-:List of 2 |-t: chr &quot;Para&quot; |-c:List of 3 |-:List of 2 | |-t: chr &quot;Str&quot; | |-c: chr &quot;Hello&quot; |-:List of 1 | |-t: chr &quot;Space&quot; |-:List of 2 |-t: chr &quot;Str&quot; |-c: chr &quot;world!&quot; あなたが AST に気づけば, Lua によって修正することができます. Pandoc は組み込みの Lua インタプリタを持っているので, 追加でツールをインストールする必要はありません. Lua スクリプトは Pandoc では「Lua フィルタ」と呼ばれます. 次に見出しのレベルを1上げる, 例えばレベル3の見出しを2に変換する簡単な例を見せます. これは文書のトップレベルの見出しがレベル2で, 代わりにレベル1から始めたい場合に便利です. 最初に raise-header.lua という名前の Lua スクリプトファイルを作ります. これには Header という名前の関数が含まれており, “Header” タイプの要素を修正したいということを意味しています (一般に, あるタイプの要素を処理するためにタイプ名を関数名として使うことができます). function Header(el) -- 見出しのレベルは要素の持つ &#39;level&#39; 属性でアクセスできます. -- 後述の Pandoc ドキュメントを見てください. if (el.level &lt;= 1) then error(&quot;h1 のレベルを上げる方法がわかりません&quot;) end el.level = el.level - 1 return el end そしてこのスクリプト Pandoc の --lua-filter 引数に与えることができます. 例えばこうです. pandoc -t markdown --atx-headers \\ --lua-filter=raise-header.lua ast.md [WARNING] Deprecated: --atx-headers. Use --markdown-headings=atx instead. # 第1節 Hello world! ## Section One を # Section One へ変換することに成功したのがお分かりかと思います. この例は些細なものだと思うかも知れませんし, どうして次のように単に正規表現を使って ## を # に置き換えないのかと思うことでしょう. gsub(&quot;^##&quot;, &quot;#&quot;, readLines(&quot;ast.md&quot;)) たいていの場合, 構造化された文書を操作するのに正規表現はロバストな手段ではありません. 例えば ## が R コード内でコメントに使われているというように, ほぼいつも例外があるためです. AST は構造化されたデータを与えてくれるので, 確実に意図した要素を修正していることが分かります. Pandoc の Lua フィルタに関する追加ドキュメントが https://pandoc.org/lua-filters.html にあり, ここで多くの例を見つけることができます. GitHub リポジトリ https://github.com/pandoc/lua-filters のコミュニティで書かれたフィルタを見つけることもできます. R Markdown の世界では Lua フィルタを活用しているパッケージの例の一部が以下になります (たいていは inst/ ディレクトリにあります). rmarkdown パッケージ (https://github.com/rstudio/rmarkdown) は改行 (4.1節参照) を挿入するフィルタとカスタムブロック (9.6節参照)を生成するフィルタを含んでいます. pagedown パッケージ (Xie et al. 2021) には脚注を実装するのを助けるフィルタと HTML ページに図のリストを表示するフィルタがあります. govdown パッケージ (Garmonsway 2021) には Pandoc の Div による囲みを適切な HTML タグに変換するフィルタがあります. 本書の5.1.2節でも Lua フィルタでテキストの色を変更する方法を紹介する例を見ることができます. Lua フィルタを (上記のパッケージのように) 導入するために R パッケージ を作りたくない R Markdown ユーザーは, これらの Lua スクリプトをコンピュータのどこかに保存し, R Markdown 出力フォーマットの pandoc_args オプションを次の例のように適用することもできます. --- output: html_document: pandoc_args: - --lua-filter=raise-header.lua --- 参考文献 "],["formatting.html", "5 書式", " 5 書式 Markdown 言語の最大の強みは, その簡潔さが初心者にとっても読み書きを非常に簡単にさせていることです. これはオリジナルの Markdown 言語の考案者も次のようにまとめている設計原理の鍵です. Markdown 形式の文書は見たままに, タグや整形の指示文でマークアップされず, プレーンテキストとして出力されるべきである. — John Gruber しかし, これはカスタマイズのコストとして跳ね返ります. 典型的なワードプロセッサの多くの機能は Markdown でそのまま使うことができません. 例えば以下のような機能です. テキストの一部のフォントサイズを変更する ある単語のフォント色を変更する テキストアラインメントを指定する こういった機能があなたの努力に見合うかどうかはあなたの判断に委ねます. Markdown は「自然界」はプレーンテキストからなり, (見た目上の) 面白さを欲求して作為すべきではない, という禁欲主義者たちの哲学をいくらか反映しています. いずれにせよ, この章では R Markdown 文書の見た目や要素のスタイルをカスタマイズをどうやればできるかの豆知識をいくつか提示します. Markdown 言語の基礎の復習が必要ならば, https://www.rstudio.com/resources/cheatsheets/ にある R Markdown チートシート18には基本構文の概観がうまく盛り込まれています. 訳注: 同ページで日本語版も公開されています.↩︎ "],["font-color.html", "5.1 フォント色", " 5.1 フォント色 Markdown 構文にはテキストの色を変更する方法は組み込まれていません. HTML と LaTeX の構文で単語の書式を変更できます. HTML では, テキストを &lt;span&gt; タグで囲み CSS で色を設定します. 例えば &lt;span style=\"color: red;\"&gt;text&lt;/span&gt; というふうに. PDF では, LaTeX コマンドの \\textcolor{}{} が使えます. これには LaTeX パッケージの xcolor が必要で, Pandoc のデフォルトの LaTex テンプレートに含まれています. PDF でテキストの色を変更する例として, 以下のようなものを挙げます. --- output: pdf_document --- 薔薇は \\textcolor{red}{赤い}, 菫は \\textcolor{blue}{青い}. 上記の例では, カーリー・ブレイス（{}）のペアの１番目には指定するテキスト色が含まれ, 2番めには色を適用したいテキストが含まれています. 複数の出力フォーマットに対応する R Markdown の文書をデザインしたいときは, 生の HTML または LaTeX コードを文書の中に埋め込むべきではありません. それは, 出力フォーマットがかわると無視される (例: LaTeX コードは HTML では無視され, HTML タグは LaTeX 出力時には失われます.) ためです. 次に, この問題に対処する方法を2つ提示します. 5.1.1 生の HTML/LaTeX コードを書く関数を使う 以下のようなカスタム R 関数を書くことで knitr パッケージの is_latex_output() および is_html_output() 関数を使って, 出力フォーマットに依存した適切な構文を挿入することができます. colorize &lt;- function(x, color) { if (knitr::is_latex_output()) { sprintf(&quot;\\\\textcolor{%s}{%s}&quot;, color, x) } else if (knitr::is_html_output()) { sprintf(&quot;&lt;span style=&#39;color: %s;&#39;&gt;%s&lt;/span&gt;&quot;, color, x) } else x } そうするとインライン R コード内で `r colorize(\"文の一部を赤色にする\", \"red\")` ように使うことができます. これは 文の一部を赤色にする でしょう (モノクロで印刷されたものを読んでいるなら, 赤色には見えないはずです). 5.1.2 Lua フィルタを使う (*) Lua という他のプログラミング言語が関わるこの方法は, R ユーザにとっては少し発展的ですが, きわめて強力です. Pandoc の Lua フィルタ(4.20節参照)を使って Markdown 要素をプログラムで修正することができます. 以下は使用例の全容です. --- title: &quot;Color text with a Lua filter&quot; output: html_document: pandoc_args: [&quot;--lua-filter=color-text.lua&quot;] pdf_document: pandoc_args: [&quot;--lua-filter=color-text.lua&quot;] keep_tex: true --- First, we define a Lua filter and write it to the file `color-text.lua`. ```{cat, engine.opts = list(file = &quot;color-text.lua&quot;)} Span = function(el) color = el.attributes[&#39;color&#39;] -- if no color attribute, return unchange if color == nil then return el end -- transform to &lt;span style=&quot;color: red;&quot;&gt;&lt;/span&gt; if FORMAT:match &#39;html&#39; then -- remove color attributes el.attributes[&#39;color&#39;] = nil -- use style attribute instead el.attributes[&#39;style&#39;] = &#39;color: &#39; .. color .. &#39;;&#39; -- return full span element return el elseif FORMAT:match &#39;latex&#39; then -- remove color attributes el.attributes[&#39;color&#39;] = nil -- encapsulate in latex code table.insert( el.content, 1, pandoc.RawInline(&#39;latex&#39;, &#39;\\\\textcolor{&#39;..color..&#39;}{&#39;) ) table.insert( el.content, pandoc.RawInline(&#39;latex&#39;, &#39;}&#39;) ) -- returns only span content return el.content else -- for other format return unchanged return el end end ``` Now we can test the filter with some text in brackets with the `color` attribute, e.g., &gt; Roses are [red and **bold**]{color=&quot;red&quot;} and &gt; violets are [blue]{color=&quot;blue&quot;}. この例では, bracketed_spans という名称の Pandoc Markdown 拡張機能をこっそり使っています. これはテキストに属性を付けて書くことを可能にします. 例えば [text]{.class attribute=\"value\"} のように. cat コードチャンク19内で定義された Lua フィルタは, 出力が HTML ならば &lt;span style=\"color: ...\"&gt;&lt;/span&gt; という形でテキストを配置し, LaTeX なら \\textcolor{...}{} として配置します. color-text.lua というファイル名で書き出しコマンドラインオプション --lua-filter で有効になった Lua フィルタは出力フォーマットの pandoc_args オプションを経由して Pandoc に与えられます. 従来の方法と比較して, Lua フィルタを使う利点はパーレン (()) の中でも Markdown 構文が使えることですが, 以前の節で紹介した R の colorize() 関数は Markdown 構文を使うことができません (例えば colorize('**太字**') と書いても太字にはなりません). cat コードチャンクを詳しく知らないのなら, 15.6節を見てください. ここでは, チャンクを .lua ファイルに書き出す便利な方法としてこのエンジンを使っています. そのため Lua スクリプトを color-text.lua という別のファイルとして管理しなくてもよいわけです. cat エンジンを使いたくなというなら, コードチャンクに Lua コードを埋め込む代わりに Lua コードを正しくコピーして別のファイルに保存することができます.↩︎ "],["indent-text.html", "5.2 テキストをインデントする", " 5.2 テキストをインデントする 4.12節で話したように, Markdown では空白文字はしばしば意味をなさなくなります. さらに Markdown は, デフォルトでインデントの空白を無視します. しかしインデントを維持したいことがあります. 例えば詩や演説文などです. このような場合は垂直線 (|) で始まる罫線ブロックを使うことができます. 改行と行頭のスペースは出力でも維持されます. 例えばこのように20 | When dollars appear it&#39;s a sign | that your code does not quite align | Ensure that your math | in xaringan hath | been placed on a single long line 出力はこうなります. When dollars appear it’s a sign   that your code does not quite align Ensure that your math   in xaringan hath   been placed on a single long line 各行は Markdown のソースでは改行コードが使われています (ハードラップ). 次に続く行をスペースで始めれば, 1つ前の行の改行と行頭のスペースは通常は無視されます. 例えばこのように入力します. | 採用責任者 | ニンジャの学校, ハッカーの大学 | 404 Not Found Road, Undefined 0x1234, NA 出力はこうなります. 採用責任者 ニンジャの学校, ハッカーの大学 404 Not Found Road, Undefined 0x1234, NA 「ニンジャの学校」の直後の改行が無視されているのがわかると思います. Claus Ekstrøm: https://yihui.org/en/2018/06/xaringan-math-limerick/ 作のリメリックです.↩︎ "],["text-width.html", "5.3 テキスト出力の幅を制御する", " 5.3 テキスト出力の幅を制御する R コードから表示されたテキスト出力の幅が広すぎることがたまにあります. 出力文書のページ幅が固定 (例えば PDF 文書) ならばテキスト出力がページ余白をはみ出すことがあります. その例が図5.1です. R グローバルオプションの width は R 関数からのテキスト出力の印字幅を制御するのに使うことができます. デフォルトが大きすぎるなら, 値を小さくしてみてください. このオプションは典型的には, おおまかに1行ごとの文字数を表しています (東アジア言語は例外です). 例えばこのように. このチャンクの出力は幅広すぎる ```{r} options(width = 300) matrix(runif(100), ncol = 20) ``` このチャンクの出力のほうが良い ```{r} options(width = 60) matrix(runif(100), ncol = 20) ``` 全ての R 関数が width オプションを尊重しているわけではありません. このオプションが動作しないなら, 唯一の選択は長いテキスト行を折り返しすることです. 実際これは html_document 出力フォーマットのデフォルトの挙動です. あなたの使っている HTML 出力フォーマットが長い行の折返しをしないのなら, 以下の CSS コード を適用してみてください (解説は7.1節を参照). pre code { white-space: pre-wrap; } PDF 出力では, 行の折返しはよりトリッキーになります. 解決策の1つは, Pandoc 引数の --listing を使うことで有効になる LaTeX パッケージの listings を使うことです. そうしたなら, このパッケージに対するオプションを設定しなければならず, またその設定コードは外部 LaTeX ファイルに含めることができます (方法は6.1節参照) 例えばこのように. --- output: pdf_document: pandoc_args: --listings includes: in_header: preamble.tex --- preamble.tex 内では, listings パッケージのオプションを設定しています. \\lstset{ breaklines=true } listings によるコードブロックの見た目が気に入らないなら, \\lstset{} で他の listings オプションを設定することができます. 例えば basicstyle=\\ttfamily でフォントファミリを変更できます. このパッケージのより詳細な情報はドキュメント https://ctan.org/pkg/listings で見つけることができます. 図 5.1 は長い行のあるデフォルトの pdf_document 出力で, ページ余白をはみ出しています. 図5.2 は listings パッケージでテキストを折り返したときの PDF 出力です. 図 5.1: 幅が広すぎる通常のテキスト出力 図 5.2: listings パッケージで折り返されたテキスト出力 訳注 listings には多くのオプションがありますが, それだけでデフォルトのシンタックスハイライトを再現するのは難しいです. コードブロックの折返しは knitr の styler オプションである程度制御できます. Pandoc は出力ブロックをほとんど表示オプションのない verbatim 環境として出力し, これが問題の主な原因です. フィルタや LaTeX マクロを使うなどしてこの環境を置き換えればデフォルトのシンタックスハイライトと折返しを両立することができます. "],["figure-size.html", "5.4 グラフ・画像のサイズを制御する", " 5.4 グラフ・画像のサイズを制御する R が作成するグラフのサイズはチャンクオプションfig.width と fig.height でインチ単位で制御できます. 同様に fig.dim オプション に長さ2のベクトルで幅と高さを指定できます. 例えば fig.dim = c(8, 6) は fig.width = 8 と fig.height = 6 を指定したのと同じです. これらのオプションはグラフの物理的なサイズを設定し, さらに out.width と out.heightを使い出力時に異なるサイズで, 例えば out.width = \"50%\" のように表示することが出来ます. R コードチャンクで生成されないグラフや画像は, 2通りの方法で掲載できます. Markdown 構文 ![キャプション](画像ファイルパス) を使う. この場合は width, height 属性でサイズを設定できます 例えばこのように. 次のパラグラフに画像を掲載する. ![すてきな画像](なんとか.png){width=50%} コードチャンクで knitr 関数 knitr::include_graphics() を使う. そのチャンクで out.width と out.height というオプションを設定することもできます. 例えばこのように. R function を使って外部画像ファイルを掲載します ```{r, echo=FALSE, out.width=&quot;50%&quot;, fig.cap=&quot;良い画像&quot;} knitr::include_graphics(&quot;なんとか.png&quot;) ``` 上記の例では幅 50% が使われており, 画像コンテナの半分の幅にすることを意味します (もし画像がページの子要素ではなく, ページに直接含まれていると仮定すると, これはページ幅の半分を意味します). 特定の出力フォーマットに対してのみ画像を生成することが分かっているのなら, 単位を特定することもできます. たとえば出力フォーマットが HTML なら 300px と書けるでしょう. "],["fig-align.html", "5.5 図のアラインメント", " 5.5 図のアラインメント チャンクオプション fig.align は図のアラインメントを指定します. 例えば fig.align = 'center' で中央揃え, あるいは fig.align = 'right' で右揃えができます. このオプションは HTML と LaTeX 出力の両方で機能しますが, 他の出力フォーマット (残念ですが Word といったものは) では機能しないかもしれません. R コードチャンクで描画されたグラフも, knitr::include_graphics() で取り込まれた外部イメージに対しても機能します. "],["verbatim-code-chunks.html", "5.6 コードチャンクをそのまま (verbatim) 表示", " 5.6 コードチャンクをそのまま (verbatim) 表示 典型的には, 私達がコードチャンクとインラインコードを書くときには knitr によってパースされ評価してほしいと思って書きます. しかし knitr を使ったチュートリアルを書きたいなら, knitr にパースされないコードチャンクやインラインコードを生成する必要があり, そしてチャンクヘッダの中身も掲載したいということもあるでしょう. 残念なことにコードチャンクをさらに別のバッククオートのレイヤで囲むことは出来ませんので, 代わりにチャンクヘッダに `r ''` を挿入して, ソースコード内でコードチャンクを無効化しなければなりません. これは knitr によって, 空の文字列のインラインコードであるものと評価されます. 次のソース文書の中にある「コードチャンク」 ```{r, eval=TRUE}`r &#39;&#39;` 1 + 1 ``` は出力時にはこのようにレンダリングされます. ```{r, eval=TRUE} 1 + 1 ``` 空の文字列で置き換えられるため, インラインコードは消え去ります. しかしこれは第1歩にすぎません. 出力時になんらかの無加工のコードを表示するには, Markdown の構文はコードブロックで包まれているべきです (スペース4つ分のインデントかバッククオートによる囲みで). 上記の出力を見たいとき, 実際のソースは以下のようになります. ```` ```{r, eval=TRUE}`r &#39;&#39;` 1 + 1 ``` ```` なぜバッククオートが4つなのでしょうか. これは N 個のバッククオートを包むには, 少なくとも N+1 個のバッククオートを使わなければならないからです. 5.6.1 インライン R コードをそのまま表示 行内のコードをそのまま表示する方法はいくつかあります. 最初の方法は `r の直後でインラインコードを改行することです. 例えばこのように. これは出力時にインライン R コードをそのまま表示します `` `r 1+1` ``. これが出力文書ではこうなっているはずです. これは出力時にインライン R コードをそのまま表示します `r 1+1`. この小ワザは2つの理由で動作します. (1) Markdown パーサはしばしば単独の改行文字を単なるスペース1つとして扱う (2連続の改行は新しい段落を始めることと比べてみてください) ということと, (2) knitr は `r をパースするのに直後にスペース1つを要求する, つまりここにスペースがないとインラインコードとして扱われないということです. インライン R コードをそのまま表示する別の方法は, R コードを knitr::inline_expr() で包むことです. 例えば. これで出力時にインライン R コードがそのまま表示されます `` `r knitr::inline_expr(&quot;1+1&quot;)` ``. 私 (Yihui) は2つ目の方法をお薦めします. 1つ目の方法は多かれ少なかれ Markdown 構文と knitr パーサに対するハック的なものだからです. "],["number-lines.html", "5.7 コードブロックに行番号を表示する (*)", " 5.7 コードブロックに行番号を表示する (*) attr.source = \".numberLines\" でソースコードブロックにも行番号を付けることも, attr.output = \".numberLines\" でテキスト出力ブロックに行番号を付けることもできます (これらのオプションの詳細は11.13節参照). 例えば. ```{r, attr.source=&#39;.numberLines&#39;} if (TRUE) { x &lt;- 1:10 x + 1 } ``` 出力はこうなります. if (TRUE) { x &lt;- 1:10 x + 1 } HTML 出力では, Pandoc が提供するシンタックスハイライト のテーマ を選ぶ必要があることに注意してください. これは出力フォーマットの highlight オプションを default や textmate にすべきではないということを意味します. ヘルプページ ?rmarkdown::html_document でこのオプションの他の値の一覧を見ることができます. 例えばこう設定できます. output: html_document: highlight: tango bookdown の gitbook 出力フォーマットでは, コードの左側の適切な位置に行番号を表示するために CSS を多少調整する必要があるかもしれません. 以下は本書で使用しているものです (行番号がページ左余白に近すぎると思ったら, left の値を -0.2em などに増やして調整してください).21 pre.numberSource code &gt; span &gt; a:first-child::before { left: -0.3em; } revealjs の revealjs_presentation 出力フォーマット (El Hattab and Allaire 2017) に対しても CSS の調整が必要かもしれません. .reveal pre code { overflow: visible; } カスタム CSS スタイルを HTML 出力に適用する方法がわからないなら, 7.1節を見てください. startFrom 属性で開始する数字を指定することもできます. 例えば. ```{r, attr.source=&#39;.numberLines startFrom=&quot;5&quot;&#39;} if (TRUE) { 1:10 } ``` 現時点では Word 出力での行番号はサポートしていません. 参考文献 "],["multi-column.html", "5.8 多段組み (*)", " 5.8 多段組み (*) Pandoc の Markdown はスライド文書に対する多段レイアウトをサポートしていますが, 他のタイプの文書ではサポートしていません. このレシピでは通常の HTML 文書や LaTeX 文書での多段レイアウトを使う方法を紹介します22. これは knitr の issue https://github.com/yihui/knitr/issues/1743 での Atsushi Yasumoto23 の解決策に着想を得ました. 考慮する必要があるのが HTML 出力のみなら話はかなり単純です. 任意の HTML 要素を横に並べて表示するのはCSS を使えば比較的簡単にできるからです. コードチャンクのテキスト出力を横に並べるだけならば, もっと簡単になります. 以下は1つ目の例です. --- output: html_document --- ```{r attr.source=&quot;style=&#39;display:inline-block;&#39;&quot;, collapse=TRUE} 1:10 # 1 から 10 の数列 10:1 # その逆順 ``` CSS 属性 display: inline-block; は, コードブロックの出力 (つまり HTML タグの &lt;pre&gt; です) をインライン要素として表示しなさいという意味です. デフォルトではこれらのブロックはブロックレベル要素 (つまり display: block;) として表示され, 行を丸ごと占有します. チャンクオプション collapse = TRUE はテキスト出力を R ソースコードブロックと結合することを意味するので, ソースとテキスト出力が同じ &lt;pre&gt; ブロックに配置されます. HTML 出力時に任意の順で横に並べたい場合, Pandoc の fenced Div. を使うことができます. “Div” は HTML タグの &lt;div&gt; に由来しますが, 任意のブロックやコンテナと解釈できます. Div の開始と終了は は3つ以上のコロン (例: :::) です. より多くのコロンの Div は, よりコロンの少ない Div を含むことができます. fenced Div の重要で有用な機能は, これに属性を付与できるということです. 例えば CSS 属性 display: flex; を外側のコンテナに適用できるので, 内側のコンテナは横並びに配置されます. --- output: html_document --- :::: {style=&quot;display: flex;&quot;} ::: {} ここは **最初の** Div です. ```{r} str(iris) ``` ::: ::: {} こっちは右側に配置されるブロックです. ```{r} plot(iris[, -5]) ``` ::: :::: 上記の例では外側の Div (::::) は2つの Div (:::) を含んでいます. この中にさらに Div を追加することもできます. とても強力な CSS 属性 display: flex; (CSS Flexbox) についてもっと知るためには https://css-tricks.com/snippets/css/a-guide-to-flexbox/ というガイドを読めばよいでしょう. CSS グリッド (display: grid;) もまた強力で, 上記の例にも使えます. もし試してみたいなら, display: flex; を display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px; に置き換えてみてください. グリッドレイアウトについてもっと知りたければ, https://css-tricks.com/snippets/css/complete-guide-grid/ のガイドを見てください. HTML でも LaTeX でも同じように使えるレイアウトにしたいのなら, よりトリッキーになります. 以下に HTML, LaTeX そして Beamer で使える用例の全容を示します. --- output: pdf_document: latex_engine: lualatex keep_tex: true includes: in_header: columns.tex html_document: css: columns.css beamer_presentation: keep_tex: true latex_engine: lualatex includes: in_header: columns.tex documentclass: &quot;`r if(knitr::opts_knit$get(&#39;rmarkdown.pandoc.to&#39;) == &#39;beamer&#39;) &#39;beamer&#39; else &#39;ltjsarticle&#39;`&quot; mainfont: &#39;Noto Sans CJK JP&#39; --- # 二段組み 以下は 3つの子要素の Div を横並びに持つ Div コンテナです. 中央の Div は空で, 左右の Div の間に空白を作るためだけに存在します. :::::: {.cols data-latex=&quot;&quot;} ::: {.col data-latex=&quot;{0.55\\textwidth}&quot;} ```{r, echo=FALSE, fig.width=5, fig.height=4} par(mar = c(4, 4, .2, .1)) plot(cars, pch = 19) ``` ::: ::: {.col data-latex=&quot;{0.05\\textwidth}&quot;} \\ &lt;!-- 段どうしのセパレータとして機能するだけの空の Div (空白入り) --&gt; ::: ::: {.col data-latex=&quot;{0.4\\textwidth}&quot;} 左側の図は `cars` データを表しています. &gt; いろはにほへと ちりぬるを わかよたれそ つねならむ うゐのおくやま けふこえて あさきゆめみし ゑひもせす ::: :::::: 図 5.3: HTML, LaTeX, Beamer で動作する二段組み 図5.3 がその出力です. この例では外側の .cols クラスを持つ Div と, 内側に .col クラスを持つ3つの Div を使っています. HTML 出力では, 外部 CSS ファイル columns.css を導入し, その中で Flexbox レイアウトを外側の Div に適用しているので, 内側の Div が横並びになります. .cols {display: flex; } LaTeX 出力 (pdf_document) では, columns.tex に含まれている「あまり行儀の良くない裏ワザ」をLaTeX プリアンブルに適用し, LaTeX 環境 cols と col を定義しなければなりません. \\newenvironment{cols}[1][]{}{} \\newenvironment{col}[1]{\\begin{minipage}{#1}\\ignorespaces}{% \\end{minipage} \\ifhmode\\unskip\\fi \\aftergroup\\useignorespacesandallpars} \\def\\useignorespacesandallpars#1\\ignorespaces\\fi{% #1\\fi\\ignorespacesandallpars} \\makeatletter \\def\\ignorespacesandallpars{% \\@ifnextchar\\par {\\expandafter\\ignorespacesandallpars\\@gobble}% {}% } \\makeatother col 環境が特に複雑な主な理由としては, LaTeX 出力で Pandoc は各 Div でいつも段落を改めるので, この改段を除去しなければならないからです. そうしないと Div を横並びに配置することはできません. このハックは https://tex.stackexchange.com/q/179016/9128 から借用しました. Beamer 出力でも columns.tex で同じハックを適用しています. Pandoc は スライドショー用に ::: {.columns}, ::: {.column}, ::: {.incremental} といった特別な Div を提供していることに注意してください. これらは特別な意味を持つため, この節のような方法で Div を LaTeX 環境に変換するときには, これらのタイプの Div を使わないように注意しなければなりません. columns や column という名前の Div タイプを使わず, cols, col 使ったのは, これが理由です. fenced Div についてより詳しく知りたいなら, 9.6節を見てください. 訳注: 二段組にしたいのが PDF 限定であれば, YAML フロントマターのみで簡単に制御できるかもしれません (6.2節参照).↩︎ 訳注: @atusy のこと↩︎ "],["latex-output.html", "6 LaTeX 出力", " 6 LaTeX 出力 多くの著作者にとって作品の主な出力は PDF レポートですが, この出力では強力な LaTeX のスタイル設定を活用できます. この章では, LaTeX コードやパッケージをプリアンブルに含めることや, カスタム LaTeX テンプレートの使用, ヘッダとフッタの追加, 図を分割して生成する方法, 生の LaTeX コードを文書の本文に書く方法, といったPDFレポートのカスタマイズに使えるアプローチについて議論します. ただし, 始める前に注意しておきたいことがあります. R Markdown の恩恵の1つは単一のソース文書から複数のフォーマットの文書を生成できるということです. あなたの作品を単一の出力に対して仕立て上げるこにとよって, その出力フォーマット単体の見た目やパフォーマンスは向上するかもしれませんが, それはこの移植性を犠牲にすることでもあります. この問題は LaTeX に限ったことでなく. 他の出力フォーマットでも同様です. "],["latex-preamble.html", "6.1 プリアンブルに LaTeX コードを追加する", " 6.1 プリアンブルに LaTeX コードを追加する LaTeX 文書の一般的な構造はこのようになっています. \\documentclass{article} % preamble \\begin{document} % body \\end{document} これは文書クラスを \\documentclass{} で宣言し, 必要に応じて特定の LaTeX パッケージを読み込んだり特定のオプションをプリアンブルで設定し, そして \\begin{document} に続いて文書の本文を書き始めています. Markdown 文書はほとんどがこの文書の本文に対応します. プリアンブルになにか追加したい時, pdf_document の includes オプションを使わねばなりません. このオプションは3つのサブオプションを持ちます. in_header, before_body, そして after_body です. いずれも1つ以上のファイルパスを指定できます. in_header に指定されたファイルはプリアンブルに追加されます. before_body と after_body に指定されたファイルはそれぞれ本文の前と後に追加されます. 例えば以下はテキスト内のハイパーリンクを脚注に変える小ワザです. この小ワザが役に立つのは, PDF 出力された文書が紙に印刷されたときに, 読者は紙面上のリンク (\\href{URL}{text} で生成されたもの) をクリックすることはできませんが, 脚注で URL を見ることはできるからです. この小ワザはテキストと URL の両方を表示します. % あなたはレンダリング前に \\href のコピーを保存したいかもしれない % \\let\\oldhref\\href \\renewcommand{\\href}[2]{#2\\footnote{\\url{#1}}} 上記のコードを任意のファイル名（例えば preamble.tex ） に保存してから, プリアンブルに読み込んでください. output: pdf_document: includes: in_header: &quot;preamble.tex&quot; この小ワザに限れば, 実際に自分で実装しなくても, Pandoc のデフォルトの TaTeX テンプレート (6.2節参照) に組み込まれた機能である YAML オプション links-as-notes を true にすることで簡単にできます. コードをプリアンブルに追加する別の方法として, YAML フロントマター の header-includes フィールドに直接コードを与えることができます. 6.3節でその例を紹介しています. header-includes を使う利点は R Markdown １文書の内部に全てを含められることです. しかしレポートを複数の出力フォーマットで生成したいのなら, やはり includes を使う方法をお薦めします. header-includes は使われ方に制約がないため, 非 LaTeX 出力の文書に対しても読み込まれてしまうからです. これと比較して, includes オプションは pdf_document フォーマットにのみ適用されます. "],["latex-variables.html", "6.2 LaTeX 出力の Pandoc オプション", " 6.2 LaTeX 出力の Pandoc オプション LaTeX 出力に対してデフォルトの Pandoc テンプレートを使うなら, PDF 出力の文書の見た目を調整するオプションが何種類もあります. そのうちいくつかの例を以下に挙げておきます. 完全なリストは https://pandoc.org/MANUAL.html#variables-for-latex で見ることができます. documentclass: book classoption: - twocolumn - landscape papersize: a5 linestretch: 1.5 fontsize: 12pt links-as-notes: true あなたが LaTeX をある程度ご存知なら, これらのオプションの意味は明らかでしょう. documentclass オプション は, 例えば article, book, report などの文書クラスを設定します. classoption は文書クラスに与えたいオプションをリストにしたもので, 例えば二段組の文書を作りたいなら twocolumn オプション,24, 横置きレイアウトにするなら landscape オプション (デフォルトでは縦置き (portrait) レイアウト) があります. papersize オプションは a4, paper, a5 といった用紙サイズを設定します. linestretch オプションは行間を設定します. fontsize オプションはフォントサイズを 10pt, 11pt, 12pt というふうに設定します. links-as-notes オプションはテキスト内のリンクを脚注に置き換えます. 紙に印刷する際には読者は紙面上のリンクをクリックできませんが, 脚注の URL を見ることができるので便利です. フォントの変更は少しトリッキーで, どの LaTeX エンジンを使っているかに依存します. LaTeX ベースの出力フォーマットで通常デフォルトの pdflatex を使っているのなら25, fontfamily オプションを使って読み込む LaTeX フォントパッケージを選択してください. 例えばこのように. fontfamily: accanthis output: pdf_document: latex_engine: pdflatex これで文書に Accanthis フォントが使われます. 他にも多数の LaTeX フォントパッケージのリストがあるので https://tug.org/FontCatalogue/ を見てください. LaTeX ディストリビューションに TinyTeX をお使いで, インストールされていないフォントパッケージが要求されるときは, 文書がコンパイルされる際に自動でインストールされるはずです(1.2節参照). LaTeX エンジンに xelatex または lualatex を使っているなら, ローカルのコンピュータで使用可能なフォントから選ぶことができ, LaTeX パッケージの追加インストールはしなくともよいです. YAML オプションで mainfont, sansfont, monofont を使えば, それぞれメインのフォント, サンセリフ体, そしてタイプライタ体のフォントを指定できます.26 例えばこのように. mainfont: Arial output: pdf_document: latex_engine: xelatex Beamer の文書は LaTeX 文書なので, Beamer でスライドを生成する時にもこれらのオプションを使用できます. 加えて, Pandoc は Beamer スライド用にオプションをいくつか追加提供しています. それらは https://pandoc.org/MANUAL.html#variables-for-beamer-slides で確認できます. 例えば institute オプションで著者の所属機関を指定することができます. --- output: beamer_presentation institute: &quot;ハッカーの大学&quot; --- このオプションは文書全体を変更しますが, 特定の位置から再度一段組に戻したいのなら, そこに \\onecolumn コマンドを挿入することになるでしょう. 二段組モードを続けたいなら \\twocolumn を挿入します.↩︎ 訳注: 日本語文書を pdflatex で出力することは全く不可能というわけではありませんが, 技術的制約が多いため LaTeX に慣れている方以外にはお薦めしません. xelatex または lualatex の使用をお薦めします.↩︎ 訳注: rmdja パッケージでは YAML フロントマターで3種類のフォントをまとめて設定できたり, あるいは欧文用フォントと和文用フォントを個別に細かく指定できたりします. 詳細はパッケージのドキュメント等を参考にしてください.↩︎ "],["latex-logo.html", "6.3 表紙ページにロゴを置く", " 6.3 表紙ページにロゴを置く LaTeX パッケージの titling は表題ブロックを画像に変更するのに使えます. 以下は R ロゴ (logo.jpg) を表紙に配置する方法の全容を示したものです. 画像は LaTeX のサポートする形式 (例えば jpg, png, pdf) ならなんでも使えます. --- title: LaTeX のタイトルにロゴを追加する author: Michael Harper date: 2018/12/7 output: pdf_document: latex_engine: lualatex documentclass: ltjsarticle header-includes: - \\usepackage{titling} - \\pretitle{\\begin{center} \\includegraphics[width=2in,height=2in]{logo.jpg}\\LARGE\\\\} - \\posttitle{\\end{center}} --- &lt;!-- 改ページを含めることもできます. これで文書を強制的に2ページ目から始めさせます. --&gt; \\newpage ここからあなたのレポート ```{r, include=FALSE} # R ロゴをカレントディレクトリにコピー file.copy(file.path(R.home(&quot;doc&quot;), &quot;html&quot;, &quot;logo.jpg&quot;), &#39;.&#39;) ``` 図6.1 がこの出力例です. 図 6.1: LaTeX の表紙ページにロゴを追加する LaTeX パッケージ (titling) を特に要求しない代替方法として, Markdown 構文を使って title フィールドに画像を挿入する方法があります. 例えばこのように. title: | ![](logo.jpg){width=1in} LaTeX のタイトルにロゴを追加する この場合, 最初の例にあった YAML フロントマターの header-includes フィールドは不要になります. 例からは見えませんが, ![](logo.jpg){width=1in} の末尾にスペースが2つあることに注意してください. これは Markdown では改行を意味します(4.12節参照). 改行がない場合画像とタイトルは同じ行に現れてしまい, あなたの意図するものではないはずです. "],["latex-extra.html", "6.4 LaTeX パッケージを追加で読み込む", " 6.4 LaTeX パッケージを追加で読み込む 追加の LaTeX パッケージ を使うことで文書のスタイルに拡張的なカスタマイズが可能になります. 加えて kableExtra (Zhu 2021) のようないくつかのパッケージでは R パッケージの関数が LaTeX に依存して機能するものもあります. R でもよくあるように, これらの関数を使えるようになる前に R Markdown 文書内でパッケージを読み込む必要があります. 6.4.1 LaTeX パッケージを読み込む pdf_document の YAML 設定で extra_dependencies オプション を使って追加の LaTeX パッケージを読み込めます. これにより中間出力の LaTeX 文書で読み込むべき LaTeX パッケージのリストを与えることができます. 例えばこのように. --- title: &quot;追加 LaTeX パッケージを使う&quot; output: pdf_document: extra_dependencies: [&quot;bbm&quot;, &quot;threeparttable&quot;] --- パッケージ読み込み時のオプションを指定する必要があるなら, 第2のレベルを加えてオプションをリストとして与えられます. 例えばこのように. output: pdf_document: extra_dependencies: caption: [&quot;labelfont={bf}&quot;] hyperref: [&quot;unicode=true&quot;, &quot;breaklinks=true&quot;] lmodern: null これは LaTeX に慣れた人にとっては以下の LaTeX コードと同じです. \\usepackage[labelfont={bf}]{caption} \\usepackage[unicode=true, breaklinks=true]{hyperref} \\userpackage{lmodern} 6.1節で紹介した includes 引数よりも extra_dependencies 引数を使う利点は, 外部ファイルを読み込む必要がないため, Rmd 文書が自己完結的になりうるということです. 6.4.2 パッケージの例 LaTeX には広範なコミュニティがあり Comprehensive TeX Archive Network (CTAN) 全体には 4,000 種類以上のパッケージがあります. ここにレポートづくりに使えるかもしれない LaTeX パッケージの例をいくつか挙げます. pdfpages: あなたの文書内に, 別の外部 PDF 文書からページを丸ごと持ってきて埋め込むことができます. caption: キャプションのサブタイトルを変更します. 例えば図のタイトルをイタリックや太字にできます. fancyhdr: 全てのページのラニングタイトル (欄外見出し) を変更できます. 参考文献 "],["figure-placement.html", "6.5 図の位置を制御する", " 6.5 図の位置を制御する LaTeX に共通の不満点の1つは図表の配置です. Microsoft Word のような図がユーザーの指定した場所にそのまま置かれるワードプロセッサと違い, LaTeX は特定の組版ルールに反しないように図を配置しようとします. そうなると図はテキストで参照した場所から浮動 (フロート) するかもしれません. この節では (図などの) フロート環境がどう機能するかについての背景情報と, その挙動をカスタマイズするためにどうオプションを与えればよいか解説します. 6.5.1 フロート環境 LaTeX ではデフォルトではキャプションのある図は figure 環境で生成されます. 例えば Pandoc は以下の画像を含む Markdown コードを…, ![This is a figure.](images/cool.jpg) こう変換します. \\begin{figure} \\includegraphics{images/cool.jpg} \\caption{This is a figure.} \\end{figure} figure 環境はフロート環境です. フロートの詳細な説明は https://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions で読むことができます. 要約するとフロートは, 図や表のようにページで区切られないコンテナとして使われます. 図表が現在のページの余白に収まらないときには, LaTeX は次のページの先頭に配置します. 図が十分に縦長だと, テキストを数行分の余白が残っていたとしても, 次のページ全てを占有します. この挙動は, \\begin{figure}[b] のように, \\begin{figure}の後の角カッコ内のいくつかの配置指定修飾子によって制御できます. 以下は使用可能な記号のリストです. h: フロートをここ (here) に配置します. つまりソーステキスト上に現れるところとほぼ同じ位置です. t: そのページの先頭 (top) に配置します. b: そのページの末尾 (bottom) に配置します. p: フロート専用の特別なページ (page) に配置します. !: LaTex が「良い」フロートの位置を決定するための内部パラメータ上書きします. H: フロートを正確に LaTex コード上と同じ位置に配置します. float パッケージが必要です (\\usepackage{float}). これらの修飾子は併用できます. 例えば !b は LaTeX が図をページ末尾に置くよう強制できます. デフォルトの挙動は tbp です. これは LaTeX が図をまずページ先頭に, ついで末尾に, そして独立したページに置こうとします. 6.5.2 図がフロートするのを防ぐ 多くのユーザは初めに, 伝統的なワードプロセッサの挙動を再現できるよう, 文書内を図が移動するのを防ぎたくなります. これを実現するには, まず LaTeX パッケージの float を読み込まなければなりません. YAML に以下の記述を含めることでできます. output: pdf_document: extra_dependencies: [&quot;float&quot;] チャンクオプション fig.pos をフロートの挙動を制御するのに使えます. オプションの値 !H は文書でのいかなる移動も防ぎます. 以下の行を R Markdown 文書の最初のコードチャンクに書くことで, 全てのチャンクがこの設定になるように, 文書のデフォルトの挙動を設定できます. knitr::opts_chunk$set(fig.pos = &quot;!H&quot;, out.extra = &quot;&quot;) 一般論として, LaTeX の図のフロートを強制的にやめさせることをおすすめしません. よくある要望なので, 本書にこの解決策を盛り込んだのですが,27 LaTeX が図をフロートできないときにはいくつかの深刻な副作用が発生することがあります. 6.5.3 フロートを後回しに強制する 全てのフロートを固定するよう強制する代わりに, テキストの後ろにフロートが回るよう強制する方法があります. これはよくある問題を排除できます. 問題とは関連するテキストが現れるよりも前に図がページの先頭に現れてしまうということで, こうなるとレポートを読む流れが破壊されてしまいます. LaTeX パッケージの flafter を使って以下のようにすることで, 常に図がテキストより後に現れるよう強制できます. output: pdf_document: extra_dependencies: [&quot;flafter&quot;] 6.5.4 LaTeX 配置ルールを調整する (*) LaTeX のフロート配置パラメータの初期値は, あなたにとっては「理にかなった」配置を全体的に邪魔しているかもしれません. 堅実などころか悪質なまでに. これらのデフォルト設定を表6.1に示します. 表 6.1: LaTeX デフォルトのフロート設定 コマンド 概要 デフォルト topfraction ページ先頭からフロートが占めるページ割合の最大値 0.7 bottomfraction ページ末尾からフロートが占めるページ割合の最大値 0.3 textfraction 1ページに占めるテキストの割合の最小値 0.2 floatpagefraction 1ページに占めるフロートの割合の最小値 0.5 topnumber ページ先頭のフロート最大数 2 bottomnumber ページ末尾のフロート最大数 1 totalnumber 1ページの最大フロート数 3 LaTeX に図を動かさないよう努力してもらうために, これらの設定を変えることができます. LaTeX プリアンブルファイルに, 1ページのテキストの最小量を減らすような以下のコードを追加し, フロートが収まる余地を増やすことができます. \\renewcommand{\\topfraction}{.85} \\renewcommand{\\bottomfraction}{.7} \\renewcommand{\\textfraction}{.15} \\renewcommand{\\floatpagefraction}{.66} \\setcounter{topnumber}{3} \\setcounter{bottomnumber}{3} \\setcounter{totalnumber}{4} これらの記述を .tex ファイルに追加したら, 6.1節で紹介した方法で LaTeX 文書のプリアンブルで読み込ませることができます. 関連するスタック・オーバーフローの質問 https://stackoverflow.com/q/16626462/559676 は 45,000 回以上閲覧されました.↩︎ "],["latex-subfigure.html", "6.6 LaTeX で複数の図をまとめる", " 6.6 LaTeX で複数の図をまとめる 複数の画像を1つの画像環境に含めたいときがあるかもしれません. 複数の画像 (sub-figures, サブ図) を1つの環境に配置しそれぞれに副題を与えることで, サブ図をまとめることができます. 複数の図をまとめるには LaTeX パッケージの subfig が必要です. pdf_document 出力の YAML オプションの extra_dependencies で読み込ませることができます. 例は以下のようになります. --- output: pdf_document: extra_dependencies: &quot;subfig&quot; --- あるコードチャンクからの全てのプロットを並べるためには, チャンクオプション fig.cap (環境全体のキャプション) と fig.subcap (サブ図のためのキャプションの文字列ベクトル) を使わなければなりません. 最良の出力を得るためには, 以下のような選択肢も使用できます. fig.ncol: サブ図の列の数です. デフォルトでは全てのグラフが単一の行に並べられます. これを使って複数の行に分けられます. out.width: 個別のグラフの出力幅です. 通常はこれを 100% を列の数で割ったものに設定します. 例えば2つグラフがあるなら, out.width は 50% 以下にすべきです. そうしないとグラフはページの外枠をはみ出すかもしれません. 以下は具体例の1つです. --- output: pdf_document: extra_dependencies: &quot;subfig&quot; --- ```{r, fig.cap=&#39;Figure 1&#39;, fig.subcap=c(&#39;(a)&#39;, &#39;(b)&#39;, &#39;(c)&#39;)} plot(1:10) plot(cars, pch = 19) boxplot(Sepal.Width ~ Species, data = iris) ``` この出力を図6.2に示します. 簡潔にするために, 上記の例はチャンクヘッダの fig.ncol = 2, out.width = \"50%\", fig.align = \"center\" や長くなるキャプションなどのチャンクオプションをいくつか省略しています. 図 6.2: 複数の図を含む単一の figure 環境の例 "],["latex-unicode.html", "6.7 Unicode 文字を含む文書をレンダリングする", " 6.7 Unicode 文字を含む文書をレンダリングする ! Package inputenc Error: Unicode char \\u8: not set up for use with LaTeX. もしこのようなエラーにでくわしたら, おそらくデフォルトの LaTeX エンジンである pdflatex を使って文書 (中間ファイルの .tex ) を PDF へレンダリングしているのでしょう. pdflatex はそのファイルにある何らかの Unicode 文字を処理できません. このようなときは, xelatex か lualatex へ切り替えることになるでしょう. 例えばこのように. output: pdf_document: latex_engine: xelatex 他の文書出力フォーマットの LaTeX エンジン, 特に pdf_document ベースの bookdown::pdf_document2 や tufte::tufte_handout といったもののエンジンも変更できます. 例えばこのように. output: bookdown::pdf_document2: latex_engine: lualatex tufte::tufte_handout: latex_engine: xelatex "],["latex-fragment.html", "6.8 LaTeX のコードフラグメントを生成する", " 6.8 LaTeX のコードフラグメントを生成する もしはじめから純粋な LaTeX 文書で作業していたとしても, R Markdown はやはり便利だとわかることもあるでしょう. R Markdown で書いて, 文書を他の LaTeX 文書に読み込める LaTeX のコード片 (フラグメント) に変換したほうが便利なこともあります. Rmd 文書を LaTeX にレンダリングするとき, \\documentclass{}, \\begin{body}, \\end{body} を含む完全な LaTeX 文書が生成されます. フラグメントはこの完全な文書の主に本文の部分です. LaTeX フラグメントをレンダリングするのに, latex_fragment 出力フォーマットが使えます. 例えばこのように. --- output: latex_fragment --- これは .tex ファイルをレンダリングします. 例えば foo.Rmd は foo.tex にレンダリングされ, 別の LaTeX 文書で \\input{foo.tex} を使うことでフラグメントを読み込めます. "],["latex-header.html", "6.9 カスタムヘッダとフッタ (*)", " 6.9 カスタムヘッダとフッタ (*) LaTeX パッケージの fancyhdr は文書のヘッダとフッタをカスタマイズするいくつかのコマンドを提供します. より完全なガイドとして, https://ctan.org/pkg/fancyhdr の完全版ドキュメントを参照してください. 最初に, パッケージを読み込みます. それからヘッダのスタイルを変えます. 例えばこのように. \\usepackage{fancyhdr} \\pagestyle{fancy} このパッケージは異なる3つのインターフェースを提示します. ここでは \\fancyhead と \\fancyfoot コマンドを使います. 形式を決める構文は \\fancyhead[selectors]{output text} で, カスタマイズしたいヘッダの箇所をセレクタが宣言しています. ページの位置を指定する以下のようなセレクタが使えます. E 偶数ページ O 奇数ページ L ページ左側 C ページ中央 R ページ右側 例えば \\fancyhead[LE,RO]{あなたの名前} は偶数ページの頭の左側と, 奇数ページの頭の右側に「あなたの名前」と印字します. さらに LaTeX コマンドを織り交ぜることで, 各ページの詳細情報を取りだすことができます. \\thepage: 現在のページ番号 \\thechapter: 現在の章番号 \\thesection: 現在の節番号 \\chaptername: 英語の “Chapter” の単語, あるいは現在の言語でそれに対応するもの, または著者がこのコマンドを再定義してできたテキスト. \\leftmark: 大文字で現在のトップレベル構造の名前と番号. \\rightmark: 大文字で現在のトップレベル構造に次ぐレベルの名前と番号. 以下は LaTeX コードの例で, 6.1節で紹介した方法でプリアンブルに書き加えることができます. \\usepackage{fancyhdr} \\pagestyle{fancy} % ヘッダ中央 \\fancyhead[CO,CE]{Your Document Header} % フッタ中央 \\fancyfoot[CO,CE]{And this is a fancy footer} % 偶数ページ左と奇数ページ右にページ番号 \\fancyfoot[LE,RO]{\\thepage} デフォルトではヘッダとフッタは PDF 文書の最初のページには表示されません. 表示にもフッタを表示したいなら, もう1行 \\fancypagestyle{plain}{\\pagestyle{fancy}} を追加しなければなりません. "],["latex-template.html", "6.10 Pandoc の LaTeX テンプレートをカスタマイズする (*)", " 6.10 Pandoc の LaTeX テンプレートをカスタマイズする (*) Pandoc はテンプレート を通じて Markdown を LaTeX に変換します. テンプレートは Pandoc 変数を含む LaTeX ファイルであり, Pandoc はこれらの変数を値に置き換えます. 以下は $body$ という変数を1つだけ含んだ単純なテンプレートです. \\documentclass{article} \\begin{document} $body$ \\end{document} $body$ の値は Markdown ドキュメントの本文から生成された LaTeX コードです. 例えば Markdown で本文が Hello **world**! ならば, $body$ の値は Hello \\textbf{world}! となります. 6.1, 6.2, 6.4節で紹介した LaTeX のカスタマイズ方法だけでは不十分なら, 代わりにカスタムテンプレートを使ってみてください. テンプレートはその内部に任意の LaTeX コードを使うことが可能なので, はるかに柔軟です. テンプレートを使うには, pdf_document の template オプション にテンプレートのパスを含めます. output: pdf_document: template: my-template.tex Pandocのデフォルトの LaTeX テンプレートは https://github.com/jgm/pandoc/tree/master/data/templates で見ることができます (ファイル名は default.latex). 自分でテンプレートを作成したい場合, このテンプレートから作りたいと思うことでしょう. Pandoc 変数 ($body$ や $title$ など) の完全なリストとその意味は Pandoc マニュアルの https://pandoc.org/MANUAL.html#templates で見ることができます. 任意のカスタム変数を使うこともでき, それは典型的には YAML メタデータからテンプレートへと与えられます. もし具体例で学びたいなら, MonashEBSTemplates パッケージ (https://github.com/robjhyndman/MonashEBSTemplates) を確認することもできます. これはいくつかのカスタム LaTeX テンプレートを提供しています. これらのテンプレートは inst/rmarkdown/templates/*/resources/ ディレクトリ (* はテンプレート名を指します) 以下にあります. 例えば出力フォーマット MonashEBSTemplates::memo 用のテンプレートは YAML メタデータの変数 branding を使って, モナシュ大学のブランドロゴを含むかどうかを制御できます. 以下のようにテンプレート内で if 文を使うことで実現しています. $if(branding)$% \\includegraphics[height=1.5cm]{monash2} \\vspace*{-0.6cm} $else$ \\vspace*{-1cm} $endif$ "],["raw-latex.html", "6.11 生の LaTeX コードを書く", " 6.11 生の LaTeX コードを書く デフォルトでは Pandoc は LaTeX へ変換する時, 文書内の LaTeX コードを維持するので, Markdown 内で LaTeX コマンドや環境を使うことができます. しかし, LaTeX コードが Pandoc がパースするには複雑過ぎる場合には, Pandoc は通常の Markdown として扱います. 結果として特別な LaTeX の文字はエスケープされます. 例えばバックスラッシュ \\ は \\textbackslash{} に変換されるかもしれません. Pandoc が Markdown 文書内の生の LaTeX コードに確実に手を付けないようにするには, コードを fenced block で囲み, =latex の属性を付けることができます. 例えばこのように. ```{=latex} \\begin{tabular}{ll} A &amp; B \\\\ A &amp; B \\\\ \\end{tabular} ``` latex の前の等号を忘れないでください. つまり latex ではなく =latex です. この機能は Pandoc 2.0 以降のバージョンが必要です (rmarkdown::pandoc_version() で確認してください). "],["latex-hardcore.html", "6.12 ハードコア LaTeX ユーザーのために (*)", " 6.12 ハードコア LaTeX ユーザーのために (*) R Markdown はきっと執筆と組版のための最善の文書フォーマットではないでしょう. シンプルさは長所であると同時に短所でもあります. LaTeX はタイプすべきコマンドの多さと引き換えに, 組版の観点で Markdown よりはるかに強力です. あなたにとって組版がはるかに優先すべき事項で, あらゆる LaTeX コマンドや環境を使うことに満足しているのなら, 文書全体で Markdown を使う代わりに純粋な LaTeX コードを使えばよいのです. knitr パッケージは R Markdown に限定されない多様なソース文書フォーマットをサポートしています. 以下は R コードと純粋な LaTeX コードが混ざり合っている例です \\documentclass{article} \\usepackage[T1]{fontenc} \\begin{document} これがコードチャンクです. &lt;&lt;foo, fig.height=4&gt;&gt;= 1 + 1 par(mar = c(4, 4, .2, .2)) plot(rnorm(100)) @ インラインコードを書くこともできます. 例えば $\\pi=\\Sexpr{pi}$ とか, \\Sexpr{1.9910214e28} で大きな数値を表現できます. \\end{document} 例えば上記のファイルが latex.Rnw であるようにファイル名には通常 .Rnw という拡張子がつきます. 考え方は同じですが R コードチャンク構文とインライン R コードを書く構文とは異なっています. R コードチャンクは &lt;&lt;&gt;&gt;= で始まり (チャンクオプションは括弧内に書きます), @ で終わります. インライン R コードは Sexpr{} 内に書きます. knitr::knit() 関数は Rnw 文書を出力ファイルである LaTeX (.tex) にコンパイルでき, それをさらに pdflatex といった LaTeX ツールを通して PDF にコンパイルできます. .Rnw から PDF を一足飛びでコンパイルするのに knitr::knit2pdf() を使うこともできます. RStudio を使っているならツールバーの Compile PDF を押すこともできます. 注意してほしいのは, Rnw 文書をコンパイルする方法のデフォルトは Sweave であり, これを knitr に変更することです (その方法はこの投稿 http://stackoverflow.com/q/27592837/559676 を確認してください). Rnw 文書は LaTeX のフルパワーをあなたにもたらします. Markdown ではほんとうに解決の難しい組版の問題があるのなら, これは最終手段となるでしょう. ただし, Markdown をやめる前に, カスタム Pandoc LaTeX テンプレート (6.10節参照) もまた役に立つかもしれない, ということも覚えておいてください. "],["html-output.html", "7 HTML 出力", " 7 HTML 出力 LaTeX と比べて HTML はおそらくページに分けた出力の組版が苦手です. しかし, 特に CSS や JavaScript と連携すれば, 結果を見せつける際にははるかに強力になります. 例えば HTML にインタラクティブアプリケーションを埋め込んだり, 動的に HTML ページの外観や, 内容すら変えることができます. CSS と JavaScript の小ワザは, HTML 出力においては有用ながらもシンプルですが, LaTeX 出力で再現するのがとても難しいこともあります (しばしば不可能なこともあります). この章では, カスタム CSS の適用方法, カスタム HTML テンプレートの使い方, コードブロックのスタイル変更や折りたたみ, 表の内容の並び替え, そして HTML ページへのファイル埋め込みといった, R Markdown の HTML 出力を改良するテクニックを紹介します. "],["html-css.html", "7.1 カスタム CSS を適用する", " 7.1 カスタム CSS を適用する HTML 文書の外観をカスタマイズしようと思うのなら, CSS と JavaScript を少しでも勉強することを強くお勧めします. blogdown 本 (Xie, Hill, and Thomas 2017) の Appendix B には HTML, CSS, JavaScript の簡単なチュートリアルがあります. 初心者にとっては, CSS のセレクタと優先度のルールを理解することは極めて重要です. さもなければ自分のカスタム CSS が意図したように機能しないことに混乱することになるでしょう (おそらく優先度が十分でないから). Rmd 文書に1つかそれ以上のカスタムスタイルシートを読み込ませるには, 次の例のような css オプション を使うことができます. output: html_document: css: &quot;style.css&quot; 複数のスタイルシートを読み込ませるには, このようにブラケットで囲んだリストを使います. output: html_document: css: [&quot;style-1.css&quot;, &quot;style-2.css&quot;] あるいは, css コードチャンク を使って, Rmd 文書に 直接 CSS のルールを埋め込むこともできます. 例えばこのように. ここに `css` コードチャンクを埋め込む. ```{css, echo=FALSE} p { font-size: 32px; } ``` チャンクオプション echo = FALSE は CSS コードを出力にそのまま表示させないことを意味しますが, CSS コードを含む &lt;style&gt; タグは HTML 出力ファイルには生成されます. 参考文献 "],["center-heading.html", "7.2 セクションヘッダを中央揃えにする", " 7.2 セクションヘッダを中央揃えにする 7.1節で言及した応用方法のように, CSS を見出しのアラインメントに使うことができます. 例えば以下のような CSS コードを使って, レベル1から3の見出しを中央揃えにできます. h1, h2, h3 { text-align: center; } Rmd 文書に CSS を適用する方法は7.1節を見てください. "],["chunk-styling.html", "7.3 コードチャンクのスタイルを変更する", " 7.3 コードチャンクのスタイルを変更する チャンクオプションの class.source と class.output を使えば, それぞれコードチャンクおよびそのテキスト出力のスタイルをカスタマイズできます. これらのオプションはクラス名の文字列ベクトルを取ります (11.13節参照). 例えば class.source = \"important\" は, コードチャンクを含んでいる HTML 要素が出力される時に important というクラス名を持たせます. そこでこのクラスに CSS ルールを定義できます.28 このルールは特定のコードチャンクやテキスト出力を強調したいときに役に立ちます. R Markdown の HTML 出力は, デフォルトで, Bootstrap フレームワークを読み込みます. Bootstrap は \"bg-primary\", \"bg-success\", \"bg-info\", \"bg-warning\", \"bg-danger\" といったいくつかの 背景に対する CSS クラス が定義済みのため, コードと出力の外観の変更を容易にしてくれます. 以下はチャンクオプション class.source = \"bg-danger\" と class.output = \"bg-warning\" を使った例で, その出力は図7.1で見られます. --- title: チャンクのスタイルを変更する output: html_document --- データフレームの一部を取りだすとき, 必ずしもデータフレームが返されるとは限りません. 例えば2つの列を取りだすなら, データフレームを得ますが, 1つの列を取り出そうとするときは, ベクトルを得ます. ```{r class.source=&quot;bg-danger&quot;, class.output=&quot;bg-warning&quot;} mtcars[1:5, &quot;mpg&quot;] ``` 常に確実にデータフレームを得るようにするには, `drop = FALSE` 引数を使わなければなりません. ここで, チャンクオプション `class.source = &quot;bg-success&quot;` を使います. ```{r df-drop-ok, class.source=&quot;bg-success&quot;} mtcars[1:5, &quot;mpg&quot;, drop = FALSE] ``` 図 7.1: Bootstrap で定義された背景色を使ったコードチャンクと出力ブロック 任意のクラスを使って対応する CSS ルールを定義することもできます. この場合以下の例のように, 7.1節で言及した方法を使ってカスタム CSS ルールを読み込ませなければなりません. --- title: チャンクにカスタムクラスを割り当てる output: html_document --- まず `watch-out` というクラスにいくつか CSSを ルールを定義します. ```{css, echo=FALSE} .watch-out { background-color: lightpink; border: 3px solid red; font-weight: bold; } ``` それからチャンクオプション `class.source` で `watch-out` クラスをコードチャンクに割り当てます. ```{r class.source=&quot;watch-out&quot;} mtcars[1:5, &quot;mpg&quot;] ``` 図7.2が出力されたスタイルです. 図 7.2: 明桃色の背景, 赤い太枠線をもつコードチャンク 文書内の全てのコードブロックにカスタムスタイルを適用したいなら, グローバルな knitr オプションで class.source を設定します. 例えばこのように. knitr::opts_chunk$set(class.source = &quot;watch-out&quot;) 複数のクラスをコードブロックに適用できます. 例えば class.source = c(\"important\", \"warning\") でコードブロックに “important” と “warning” という2つのクラスを持たせることができます. コードブロック全体ではなく, 内部の個別の要素を装飾したいならば, flair パッケージ (Bodwin and Glanz 2020) の使用を検討するとよいでしょう. このパッケージでコードの個別の部分 (特定の文字, 関数名, 引数など) をカスタムスタイル (例えば色, フォントサイズ, あるいはフォントのウエイト) で強調できます. 参考文献 "],["html-scroll.html", "7.4 コードブロックをスクロール可能にする (*)", " 7.4 コードブロックをスクロール可能にする (*) 大量のコードやテキスト出力を HTML ページに表示するとき, 表示範囲の高さを制限したほうがよいでしょう. そうしないとページはとてつもなく長くなり, コードやテキストの出力を細かく読む気のない人が読み飛ばしづらくなります. この問題の解決法は複数あります. 一つは, html_document フォーマットの code_folding オプションを使います. このオプションは文書のコードブロックを折りたたんで出力し, 読者はボタンを押して折りたたみを展開することができます (詳細は7.5節). 他の解決法としては, コードブロックが長すぎるとき, 高さを固定しスクロール可能にすることです. これは CSS プロパティの max-height と overflow-y で実現できます. 以下はその使用例の全容で, 出力は図7.3になります. --- title: スクロール可能なコードブロック output: html_document --- ```{css, echo=FALSE} pre { max-height: 300px; overflow-y: auto; } pre[class] { max-height: 100px; } ``` コードブロックの高さを制限する CSS ルールをいくつか定義しました. これらのルールがコードブロックとテキスト出力に対して機能するのかテストすることができます. ```{r} # このチャンクに多くのコードがあるように見せかける if (1 + 1 == 2) { # もちろん真になる print(mtcars) # 単に長いデータを表示させるだけ } ``` 次に高さを100px に制限するために `scroll-100` という新しいクラスにルールを追加し, チャンクオプション `class.output` でこのクラスをコードチャンクの出力に追加します. ```{css, echo=FALSE} .scroll-100 { max-height: 100px; overflow-y: auto; background-color: inherit; } ``` ```{r, class.output=&quot;scroll-100&quot;} print(mtcars) ``` 図 7.3: カスタム CSS を使用したスクロール可能なコードブロック 上記の例では全てのコードブロックに大域的に 300px の高さの上限を定義しています. HTML 出力時にはコードブロックが &lt;pre&gt; タグで囲まれていることを思い出してください. それから class 属性を用いて &lt;pre&gt; ブロックの高さを 100px に制限します. これは CSS セレクタ pre[class] が意味するところです. デフォルトではテキスト出力は &lt;pre&gt; &lt;/pre&gt; に含まれ, R コードブロックは &lt;pre class=\"r\"&gt; &lt;/pre&gt; に含まれます ( &lt;pre&gt; タグが class 属性を持っていることに注意). ２つ目の R コードチャンクからのテキスト出力の高さも 100px です. これは出力に対して, カスタムクラス名 scroll-100 を割り当て, 高さの上限を 100px に定義したためです. 個別のコードブロックに対して異なる最大の高さを指定したいならば, 12.3節の例を見てください. "],["fold-show.html", "7.5 全コードブロックを折りたたみ, かついくつかは表示する", " 7.5 全コードブロックを折りたたみ, かついくつかは表示する 出力文書に書かれたコードブロックが読者に嫌がられるおそれがあるなら, はじめは折りたたんでおくという選択がいいでしょう. 読者はボタンを押して表示を選ぶことができます. output: html_document: code_folding: hide 全てのコードブロックを最初から展開しておくこともできます (よって読者は折りたたみもできます). output: html_document: code_folding: show 最初から全てのコードブロックを折りたたむなら, 特定のブロックだけチャンクオプション class.source = \"fold-show\" を使い最初から展開させておくこともできます. このように. --- title: Hide all code blocks and show some initially output: html_document: code_folding: hide --- ```{r} 1 # code is hidden initially ``` ```{r class.source = &#39;fold-show&#39;} 2 # code is shown initially ``` ```{r} 3 # also hidden ``` 反対のこともできます. つまり, 最初から全てのコードブロックを表示するものの, 一部を非表示にします. 例えばこのように. --- output: html_document: code_folding: show --- ```{r} 1 # code is shown initially ``` ```{r class.source = &#39;fold-hide&#39;} 2 # code is hidden initially ``` code_folding は Rと他の一部の言語 (デフォルトでは r, python, bash, sql, cpp, stan, and julia) コードチャンクの表示・非表示の挙動を制御します. これがあなたにとって制約になるなら, それ以外の言語のチャンクオプションの class.source に foldable クラスを追加するか, または いずれかのチャンクで knitr::opts_chunk$set(class.source = \"foldable\") を使ってグローバルに折りたたみの適用範囲を広げることができます. --- title: CSS コードチャンクを隠す output: html_document: code_folding: hide --- これは `css` エンジンを使用した CSS コードチャンクです. これは `code_folding = &#39;hide&#39;` を指定しても隠すことができません. ```{css} pre { background-color: lightblue; } ``` しかし `foldable` クラスをチャンクのソースコードに追加すれば可能になります. ```{css, class.source = &#39;foldable&#39;} pre.foldable { background-color: lightgreen; } ``` "],["html-tabs.html", "7.6 内容をタブブラウジングさせる", " 7.6 内容をタブブラウジングさせる HTML レポートで並列しているセクションをうまくまとめるには, タブセットが自然な方法として使えます. これは読者がページをスクロールして戻したり進めたりするかわりに, タブのタイトルをクリックすることで異なるセクションの内容を閲覧することを可能にします. セクションをタブにするには, タブに変換する見出しより1レベル上の見出しにクラス属性 .tabset を追加します. 例えばレベル2の見出しに .tabset を追加すると, それ以降のレベル3の見出しが全てタブに変換されます. 以下は用例の全容です. --- title: 内容をタブにまとめる output: html_document --- `html_document` 出力で並列するセクションをタブにできます. ## 結果 {.tabset} ### グラフ このセクションでは散布図を表示します. ```{r, fig.dim=c(5, 3)} par(mar = c(4, 4, .5, .1)) plot(mpg ~ hp, data = mtcars, pch = 19) ``` ### 表 このタブではデータを表示します. ```{r} head(mtcars) ``` 出力を図7.4に示します. 実際には一度に1つのタブしか見られないことに注意してください. この図は両方のタブがみられるよう2つのスクリーンショットを連結したものです. 図 7.4: 複数のセクションをタブに タブに “pill” 効果を付けるため, さらに別の属性 .tabset-pills を上位レベルの見出しに追加することができます. これでタブは暗青色の背景になります. ## Results {.tabset .tabset-pills} デフォルトでは最初のタブがアクティブ (つまり表示されている) です. 他のタブを最初に表示させたいなら, そのセクションに .active 属性を追加できます. 以下の例では, 文書を開くか再読み込みしたときに第2のタブ(背景情報) がアクティブ, つまり表示されている状態になります. ## 結果 {.tabset} ### 内容 ここに文章. ### 背景情報 {.active} ここに文章. タブセットを終わらせるには, 上位レベルのセクション見出しを新しく開始する必要があります. 新しいセクションの見出しは空にします. 例えばこのように. ## Results {.tabset} ### Tab One ### Tab Two ## {-} 上記のように番号なし (`{-}`) で空のセクション見出しがあれば, タブセットを終了しさらなる段落を続けることができます. "],["embed-rmd.html", "7.7 Rmd ソースファイルを HTML に埋め込む", " 7.7 Rmd ソースファイルを HTML に埋め込む 他の人とHTML 出力ページを共有するとき, Rmd ソースファイルもほしいかもしれません. 例えば 自分自身で Rmd ソースを変更し, レポートをコンパイルしたいかもしれません. オプション code_download を使えば, Rmd ソースファイルのコピーを HTML に埋め込むことができます. output: html_document: code_download: true オプションを有効にすると, HTML 出力ページにはダウンロードボタンが現れ, 読者はそのボタンを押してソースファイルのダウンロードができます. "],["embed-file.html", "7.8 HTML 出力に好きなファイルを埋め込む", " 7.8 HTML 出力に好きなファイルを埋め込む 7.7節で言及したように, HTML出力には Rmd ソース文書のコピーを埋め込めます. Rmd ファイル単体ではレポートを再現するのに不十分なこともあります. 例えばレポートに外部のデータファイルが必要かもしれません. HTML 出力ファイルに好きなファイルを埋め込んでくれる一連の関数が xfun パッケージ (Xie 2021g) にあります. これらの関数を使うために, 以下の R パッケージを用意しておきます. xfun::pkg_load2(c(&quot;htmltools&quot;, &quot;mime&quot;)) これにより, コードチャンク内で xfun::embed_file(), xfun::embed_files(), xfun::embed_dir() のどれかを使って, 1つ以上のファイルやディレクトリを HTML 出力に埋め込めます. 例えばこのように. ```{r echo=FALSE} # a single file xfun::embed_file(&#39;source.Rmd&#39;) # multiple files xfun::embed_files(c(&#39;source.Rmd&#39;, &#39;data.csv&#39;)) # a directory xfun::embed_dir(&#39;data/&#39;, text = &#39;Download full data&#39;) ``` プログラミング的にファイルのリストを与えることもできます. 例えばこのように. # embed all Rmd and csv files xfun::embed_files(list.files(&quot;.&quot;, &quot;[.](Rmd|csv)$&quot;)) 複数のファイルに対しては, これらの関数はまず zip ファイルに圧縮してから, その zip ファイルを埋め込みます. これらの関数はリンクを返し, 読者は HTML ページのリンクをクリックして埋め込んだファイルをダウンロードすることができます. これらの関数のより詳細な技術的情報は, ヘルプページ ?xfun::embed_file またはブログ投稿 https://yihui.org/en/2018/07/embed-file/ で学ぶことができます. 同様のアイディアにより, downloadthis package (Mattioni Maturana 2020) はダウンロードボタンを実装したことで, ユーザーはリンクではなくダウンロードボタンをクリックしてダウンロードできるようになります. ボタンを使うほうがお好みなら, こちらを使うことも検討するとよいでしょう. 参考文献 "],["html-template.html", "7.9 カスタム HTML テンプレートを使う (*)", " 7.9 カスタム HTML テンプレートを使う (*) 既に6.10節で LaTeX テンプレートについて話しました. カスタム HTML テンプレート を指定すると, Pandoc が Markdown を HTML へと変換できます. 以下は簡単なテンプレートの例です. &lt;html&gt; &lt;head&gt; &lt;title&gt;$title$&lt;/title&gt; $for(css)$ &lt;link rel=&quot;stylesheet&quot; href=&quot;$css$&quot; type=&quot;text/css&quot; /&gt; $endfor$ &lt;/head&gt; &lt;body&gt; $body$ &lt;/body&gt; &lt;/html&gt; テンプレートに $title$, $body$ といったいくつかの変数が含まれているのがわかるでしょう. Pandoc 変数の完全なリストとそれぞれの意味については https://pandoc.org/MANUAL.html#templates で検索できます. テンプレートによってあなたは HTML 出力をカスタマイズする究極の力を得ることになります. 例えば好きな CSS スタイルシートや JavaScript コード, あるいはライブラリを &lt;head&gt; 内で読み込ませたりできます. あるいは次のように, 文書が下書きか最終稿かを示すブーリアン変数 draft も使えます. &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; .logo { float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;logo&quot;&gt; $if(draft)$ &lt;!-- use draft.png to show that this is a draft --&gt; &lt;img src=&quot;images/draft.png&quot; alt=&quot;Draft mode&quot; /&gt; $else$ &lt;!-- insert the formal logo if this is final --&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;Final version&quot; /&gt; $endif$ &lt;/div&gt; $body$ &lt;/body&gt; すると Rmd 文書の YAML メタデータ内で draft 変数に true または false を設定できます. 例えばこのように. --- title: &quot;An Important Report&quot; draft: true --- テンプレートを Rmd 文書に適用するためには, テンプレートをファイルに保存した上で, html_document の template オプションにファイルパスを与えます. 例えばこのように. output: html_document: template: my-template.html rmarkdown パッケージに同梱したカスタム HTML テンプレートを読み込んで使用しており, これは Pandoc のデフォルトテンプレートとは異なります. Pandoc のデフォルトを使うには template: null で指定できます. "],["include-html.html", "7.10 既存の HTML ファイルの内容を読み込む (*)", " 7.10 既存の HTML ファイルの内容を読み込む (*) html_document フォーマット (あるいはこのオプションをサポートしている他のフォーマット) の includes オプション があれば, 既存の HTML ファイルの本文を 出力する HTML 文書内の３箇所のいずれかに読み込むことができます. それらは タグ内部, の前, そして本文の後でかつ の直前です. output: html_document: includes: in_header: header.html before_body: before.html after_body: after.html HTML にあまり詳しくないなら, 7.9節がこのオプションをより理解するのに役に立つかもしれません. in_header オプションを使うなら, CSS と JavaScript コードを &lt;head&gt; タグ内に挿入することができます. before_body を使うなら, バナーやロゴを表示するヘッダを埋め込むこともできます. after_body を使うなら, フッタを読み込ませることができます. 例えばこのように. &lt;div class=&quot;footer&quot;&gt;Copyright &amp;copy; John Doe 2020&lt;/div&gt; 外部 HTML ファイルの内容を本文の好きな位置に読み込みたいときもあるでしょう. これは htmltools::includeHTML() を使えば可能です. HTML ファイルパスをこの関数に与えます. 関数はこのファイルを読み込み, 出力文書にたいしてこのファイルの中身を書き込みます. 9.5節で使用したようなテクニックをを使っても良いかもしれません. 例えばこのように. ````{=html} ```{r, echo=FALSE, results=&#39;asis&#39;} xfun::file_string(&#39;file.html&#39;) ``` ```` HTML ファイル内に読み込めるのは別の HTML の一部分だけであり, HTMLファイルそのものを読み込んではならないことに注意してください. 完全な HTML ファイルとは &lt;html&gt; タグを含むものであり, これは他の &lt;html&gt; タグ内に埋め込むことができません. 以下は HTML 文書に別の完全な HTML 文書が 埋め込まれた場合の無効な HTML 文書です. &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; 親 HTML ファイル. &lt;!-- 以下 htmltools::includeHTML() --&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; 子 HTML ファイル. &lt;/body&gt; &lt;/html&gt; &lt;!-- 読み込み終わり --&gt; &lt;/body&gt; &lt;/html&gt; HTML ファイルを別の HTML 出力文書に読み込む時に問題が発生したなら, HTML ファイルに &lt;html&gt; タグが含まれていないか確認するとよいでしょう. rmarkdown パッケージには html_fragment という出力フォーマットがあり, 完全な HTML 文書の代わりに HTML の一部を生成します. Rmd 文書内で別のコンパイルされた Rmd 文書の結果を読み込みたい場合, 後者の Rmd 文書の出力には 通常用いるhtml_document フォーマットの代わりに html_fragment フォーマットを使うとよいでしょう. HTML ファイルの代わりに Rmd または Markdown 文書を読み込ませたいなら, 16.4節で紹介されている子文書を使うこともできます. "],["favicon.html", "7.11 ブラウザアイコンをカスタマイズする", " 7.11 ブラウザアイコンをカスタマイズする 7.10節では html_document フォーマットの includes オプションを使って, 追加のコードを HTML のヘッダ, 本文, フッタに挿入できることを実演しました. このテクニックはファビコンというカスタムブラウザアイコンを HTML 出力に追加することにも使えます. ファビコンはブラウザのアドレスバー, タブタイトル, ブックマークに表示されるウェブサイトのロゴです. 例えば Google Chrome で CRAN のウェブサイト (https://cran.r-project.org) を開いてブラウザのタブを見ると, 小さな R ロゴがあります. 携帯端末ならばファビコンはウェブサイトをホームスクリーンに固定表示した際にアプリアイコンの代わりに使われます. HTML 文書にファビコンを追加するには, 以下のコードをカスタムヘッダファイル (7.10節で言及したように, header.html といった名前のファイル) を追加します. &lt;link rel=&quot;shortcut icon&quot; href=&quot;{ファビコン画像ファイルへのパス}&quot; /&gt; YAML メタデータを使って, このファイルを文書の &lt;head&gt; 領域に挿入できることを思い出してください. output: html_document: includes: in_header: header.html &lt;link&gt; の href 属性に与えるパスは, 他のアセット (例えば画像やデータ・セット) を参照するときと同じように, 相対パス構造を前提とすべきです. 使用する画像は, 最も小さい正方形の PNG ファイルがよく機能します. 典型的なウェブブラウザは画像を 16 x 16 ピクセルの領域に表示するため, シンプルなデザインがより良いということに留意してください. あなたの文書を表示する各種のブラウザやプラットフォームが, 特定のレイアウトに対して最適な解像度のバージョンのアイコンを用いるようにしたいのであれば, https://realfavicongenerator.net といったサービスを使って, ファビコンセットとやや複雑な HTML ヘッダのコードを生成するとよいでしょう. このサービスは現在 pkgdown パッケージ (Wickham and Hesselberth 2020) の pkgdown::build_favicon() 関数で R パッケージロゴからファビコンセットを作り出すのに使用されています. 参考文献 "],["details-tag.html", "7.12 折りたたみ要素 &lt;details&gt; を使う", " 7.12 折りたたみ要素 &lt;details&gt; を使う 7.4節で言及したように, html_document フォーマットの code_folding: hide オプションでソースコードチャンクを折りたたむことができます. 現在は出力ブロックを折りたたむことはできませんが, JavaScript の小ワザが使えれば出力を折りたたみできます. これは出力が比較的長く, しかしさほど重要でないときに役に立つでしょう. 初期状態で折りたたみ, 読者が興味を持てば内容を見るために展開することができます. 図7.5はその例です. 「詳細」ボタンをクリックして出力を展開できるでしょう. 図 7.5: details 要素でテキスト出力を囲む あなたがご覧になっているのが本書の HTML バージョンなら, 以下のチャンクで実際に動くのを見ることができます. PDF または印刷版を読んでいるのなら, このような対話的機能 (「詳細」ボタンを押すこと) はもちろん不可能です. 1:100 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 ## [13] 13 14 15 16 17 18 19 20 21 22 23 24 ## [25] 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 ## [49] 49 50 51 52 53 54 55 56 57 58 59 60 ## [61] 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 ## [85] 85 86 87 88 89 90 91 92 93 94 95 96 ## [97] 97 98 99 100 以下の Rmd 文書は, 出力ブロックを検出しそれを &lt;details&gt; タグで囲む JavaScript コードを読み込ませた, 完全なソースです. --- title: 折りたたみ要素 `&lt;details&gt;` を使う output: html_document --- この例ではテキスト出力を `&lt;details&gt;` タグ内に表示します. JavaScript でテキスト出力ブロックを `&lt;details&gt;&lt;/details&gt;` で囲みます. Javascript コードはこの文書の末尾で実行する必要があるため, 最後に配置します. 以下はテスト用のコードチャンクです. ```{r} 1:100 ``` 実際の JavaScript コードは以下になります. ```{js, echo=FALSE} (function() { var codes = document.querySelectorAll(&#39;pre:not([class])&#39;); var code, i, d, s, p; for (i = 0; i &lt; codes.length; i++) { code = codes[i]; p = code.parentNode; d = document.createElement(&#39;details&#39;); s = document.createElement(&#39;summary&#39;); s.innerText = &#39;詳細&#39;; // &lt;details&gt;&lt;summary&gt;詳細&lt;/summary&gt;&lt;/details&gt; d.appendChild(s); // コードを &lt;details&gt; 内に移動 p.replaceChild(d, code); d.appendChild(code); } })(); ``` 上記の JavaScript コードを自分で適用することもできます. ポイントは要素を &lt;details&gt; で囲むということです. document.querySelectorAll(&#39;pre:not([class])&#39;); CSS セレクタの pre:not([class]) は class 属性のない全ての &lt;pre&gt; 要素を意味します. 他の要素のタイプを選択することもできます. CSS セレクタについてより知りたいなら, https://www.w3schools.com/css/css_selectors.asp を見てください. HTML タグ &lt;details&gt; と &lt;summary&gt; をより知りたいなら, https://www.w3schools.com/tags/tag_details.asp を見てください. "],["html-share.html", "7.13 HTML 出力を Web で共有する", " 7.13 HTML 出力を Web で共有する R Markdown を HTML ファイルにレンダリングする魅力的な側面の1つは, これらのファイルをとても簡単にインターネットでホストし, 他のウェブサイトと同様に共有できるということです. この節ではあなたの作成した HTML 文書を共有するオプションを簡単に要約します. 7.13.1 R 特化のサービス RStudio は R Markdown で作られた様々な種類のコンテンツをインターネットで公開するためのサービスをいくつか提案しています. これらのサービスは特に RStudio IDE または rsconnect パッケージ (McPherson and Allaire 2021) を使って簡単に公開できます. RPubs は静的な単一の R Markdown コンテンツの無料ホスティングを可能とします. RStudio IDE の Publish ボタンまたは rsconnect::rpubsUpload() 関数で簡単に公開できます. 詳細は “Getting Started” のページ (https://rpubs.com/about/getting-started) をご覧ください. ShinyApps.io は R を実行するサーバを要する動的コンテンツのホスティングを可能にします. 例えば Shiny コンポネントを含んでいる29インタラクティブな R Markdown 文書をホストできます. ShinyApp.io は Shiny アプリケーション用の RPubs の類似サービスです. アプリとインタラクティブな R Markdown 文書は RStudio IDE の push ボタンか rsconnect::deployApp() 関数を使って公開できます. 詳細はユーザーガイド (https://docs.rstudio.com/shinyapps.io/) をご覧ください. bookdown.org は bookdown パッケージで書かれた本の無料ホスティングを提案します. bookdown::publish_book() 関数であなたの書籍の静的な出力ファイルを簡単に公開できるでしょう. RStudio Connect は組織団体が自前のサーバで動作させるような企業向け製品です. 作成された広範な種類のコンテンツ (R Markdown 文書, Shiny アプリケーション, API など) を文書レベルでのアクセス制御, 閲覧履歴などといった機能を使いセキュアな環境でホストできます. コンテンツは RStudio Connect に手動でアップロードするか, rsconnect パッケージか, または git ベースのデプロイによって公開できます. 7.13.2 Static website services 端的に言うなら, 単純な静的ウェブサイトは数個の HTML ファイル (典型的にはホームページである index.html), JavaScript, CSS ファイル, そして画像などの追加のコンテンツで構成されます. 一連のファイルは web サーバにそのままホストし, web ブラウザに表示させることができます. R Markdown が HTML 出力フォーマットでレンダリングされた場合, その結果は静的なウェブサイトとして扱われます. ウェブサイトは単一のスタンドアロンな HTML ファイル (デフォルトオプション self_contained: true を使った場合に得られます) から, ファイルのセット, blogdown パッケージ (静的なウェブサイトジェネレータに依存しています) に基づいたウェブサイトのような洗練されたプロジェクトまで複雑さの点で多岐に及びます. より詳しく知りたいなら, blogdown 本 (Xie, Hill, and Thomas 2017) の Section 2.1 on Static Sites を見てください. 結論として, あなたは R 特化のサービスに加え, 多くの無料で使用可能な静的ウェブサイトホスティングサービスを使って HTML 文書をホストできるでしょう. R コミュニティでのよくある選択としては以下があります. GitHub Pages は Github リポジトリから Markdown と HTML コンテンツをそのまま公開する場合は特に簡単です. main ブランチのルートか, main ブランチのdocs/ ディレクトリ, あるいは特定の gh-pages ブランチからコンテンツをホストすることを指定することになるでしょう. 新しいコンテンツの公開は git でリポジトリに新しい HTML ファイルをプッシュするだけで可能です. GitLab Pages は GitHub Pages と類似の機能を GitLab リポジトリに対して提案します. GitLab はリポジトリの public/ ディレクトリに保存されたコンテンツをデプロイします. コンテンツをビルドし公開するには, .gitlab-ci.yml という YAML ファイルで指示を与えなければなりませんが, GitLab は多くの便利なテンプレートを提供してくれます. レンダリングされた HTML コンテンツをホストする例として, https://gitlab.com/pages/plain-html/-/tree/master をご覧ください. Netlify は静的な web コンテンツをビルドしデプロイするプラットフォームです. blogdown と pkgdown で作成された web コンテンツに対する選択としてはよく知られていますが, これはあらゆる種類の HTML ファイルをホスティングできます. 公開方法として, ドラッグ・アンド・ドロップ, コマンドライン, あるいは GitHub および GitLab レポジトリから自動公開するといったいくつもの選択があります. 加えて, プルリクエストから web サイトをプレビューするといった多くの役立つ機能も提案されています. 詳細は Netlify のドキュメント (https://docs.netlify.com) や RStudio webinar “Sharing on Short Notice” をご覧ください. 参考文献 "],["html-accessibility.html", "7.14 HTML ページのアクセシビリティを向上させる", " 7.14 HTML ページのアクセシビリティを向上させる HTML 出力文書に, 何らかの視覚的な障害を持つ読者に対するアクセシビリティをもたせることは重要です. たいていの場合, こういった読者は文書を視覚的に読む代わりに, スクリーンリーダ (音声読み上げソフト) といった聞くための特殊なツールを使います. 通常はスクリーンリーダはテキストを読み上げることができるだけで, (ラスタ) 画像を読み上げられません. つまりあなたはスクリーンリーダに十分なテキストでヒントを与える必要があるということです. 良いニュースは, わずかな労力があればあなたの文書のアクセシビリティを格段に向上できるということです. Jonathan Godfrey が R Markdown 文書のアクセシビリティのためのいくつかのヒントを https://r-resources.massey.ac.nz/rmarkdown/ で記事にしています.30 この記事に基づいて, 本書の読者にとっての利便性になるいくつかのヒントを以下に提示します. HTML 文書はしばしば PDF よりアクセシビリティが優れている. 可能ならば HTML 出力文書に Rmd ソース文書を同梱するようにする (例えば7.7節でその方法の1つを実演しています). HTML 文書にアクセシビリティがない場合, 視覚障害者は Rmd ソースから内容を理解できるかもしれませんし, ソースを修正することもできるかもしれません. グラフのタグにテキストで情報を含ませる. 2014年の useR! カンファレンスで, 私は Jonathan からこの問題を個人的に教えてもらいました. web ページ上の画像の alt 属性の大切さを, 私は初めて理解しました. この問題を理解するために, まずは web ページの画像が HTML タグ &lt;img /&gt; によって生成されることを知らなければなりません. このタグは src 属性を持ち, 画像ファイルのソースの場所を指定しています. 例えば &lt;img src=\"foo_figures/image.png\" /&gt; のように. 視力のある読者はこの画像を見ることができますが, 視覚障害者には描かれていることを知るのは難しいのです. それはスクリーンリーダは, 特にラスタ画像の場合, 画像を読むことが出来ないためです (SVG のようなベクタ画像は多少ましかもしれませんが). この場合テキストでのヒントを与えると, スクリーンリーダは読み上げることができるので便利です. このテキストでのヒントは画像の代替 (alternate) テキストを意味する alt 属性で与えることできます. R Markdown のコードチャンクから生成された画像の場合は, もしチャンクオプション fig.cap (つまり 画像のキャプション, figure caption) が設定されているなら alt 属性はここから生成されます. 代わりに Markdown 構文 ![]() を使って画像を挿入することもできます. 画像パスをパーレン () 内に入力し, alt テキストをブラケット [] 内に入力, 例えば ![テキスト情報](パス/image.png) のように. alt テキストは視覚のある読者にとっては HTML ページ上に表示されません. しかし画像にキャプションや代替テキストを与えた場合, rmarkdown::html_document フォーマットはデフォルトでキャプション要素を表示します. もし実際にキャプションを表示させたくないなら, このように fig_caption をオフにすることができます. output: html_document: fig_caption: false このケースでは alt 属性はまだ生成されますが, 表示されることはありません. 数学的なコンテンツを書くには画像の代わりに LaTeX 構文を使う (例: $ $, あるいは $$ $$). デフォルトでは, R Markdown は数学的なコンテンツのレンダリングに MathJax ライブラリを使い, 結果としてスクリーンリーダが読み上げられるものになります. チャンクオプション comment = \"\" を設定してコードチャンクのテキスト出力の行頭の ## を除く (11.12節参照). 我々はアクセシビリティの専門家ではありませんので, 詳細を知りたければ元の記事を読むことをお薦めします. JooYoung Seo も, 視覚障害を持つ人の手助けになる R パッケージを https://jooyoungseo.com/post/ds4blind/ で紹介しています. これは R Markdown と直接関係しませんが, 視覚障害者がどうグラフを読み取っているのかを学ぶのに役に立つでしょう.↩︎ "],["html-hardcore.html", "7.15 ハードコア HTML ユーザー向けの話 (*)", " 7.15 ハードコア HTML ユーザー向けの話 (*) 6.12節では, Markdown がシンプルであるがゆえにその制約が強すぎると感じるときは, Markdown の代わりに純粋な LaTeX 文書にコードチャンクを埋め込むことができる, という話をしました. 同様に, 直接 HTML コードを書くことに慣れていて快適さを感じるなら, HTML にコードチャンクを混ぜ合わせることもまた可能です. そのような文書は慣習的に .Rhtml というファイル拡張子を持ちます. Rhtml 文書では, コードチャンクは &lt;!--begin.rcode と end.rcode--&gt; の間に埋め込まれ, インライン R コードは &lt;!--rinline --&gt; 内に埋め込まれます. 以下は Rhtml 全体の例です. これを test.Rhtml というファイル名で保存し, knitr::knit(\"test.Rhtml\") を使ってコンパイルできます. 出力は 1つの HTML (.html) ファイルになります. RStudio では, ツールバーの Knit ボタンを押すことでもコンパイルできます. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;HTML の最低限の knitr 使用例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--begin.rcode knitr::opts_chunk$set(fig.width=5, fig.height=5) end.rcode--&gt; &lt;p&gt;これは &lt;strong&gt;knitr&lt;/strong&gt; が純粋な HTML ページでどのように動作するかの最低限の例です.&lt;/p&gt; &lt;p&gt;お決まりの退屈な使用例.&lt;/p&gt; &lt;!--begin.rcode # 単純な計算 1 + 1 # 退屈な乱数生成 set.seed(123) rnorm(5) end.rcode--&gt; &lt;p&gt;図を生成することもできます (&lt;code&gt;fig.align=&#39;center&#39;&lt;/code&gt;オプションで中央揃えしています).&lt;/p&gt; &lt;!--begin.rcode cars-scatter, fig.align=&#39;center&#39; plot(mpg ~ hp, data = mtcars) end.rcode--&gt; &lt;p&gt;エラー, メッセージ, 警告文はそれぞれ異なる&lt;code&gt;class&lt;/code&gt;を持つ &lt;code&gt;div&lt;/code&gt; 内に配置されます.&lt;/p&gt; &lt;!--begin.rcode sqrt(-1) # 警告 message(&#39;knitr says hello to HTML!&#39;) 1 + &#39;a&#39; # ミッションインポッシブル end.rcode--&gt; &lt;p&gt;さて全てうまくいっているようです. R に &amp;pi; の値を聞いてみましょう. もちろん答えは &lt;!--rinline pi --&gt; です.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; "],["word.html", "8 Word", " 8 Word R Markdown から Word 文書を生成するには, 出力フォーマット word_document が使えます. 文書に相互参照を含めたいなら, 4.7節でも言及された bookdown::word_document2 を検討するとよいでしょう. --- output: word_document: default bookdown::word_document2: default # 相互参照のため --- われわれの経験上, Word 出力に関する最もよくある質問は以下のようなものです. 文書へのカスタム Word テンプレートはどうすれば適用できるのか? Word 側で元の R Markdown 文書を適切に変更にはどうすればいいのか? 文書の要素の個別のスタイルの設定はどうすればいいのか? この章ではこれらの質問に答えていきます. "],["word-template.html", "8.1 カスタム Word テンプレート", " 8.1 カスタム Word テンプレート Word テンプレート文書で定義されたスタイルを R Markdown で新たに生成された Word 文書に適用することができます. テンプレート文書は「スタイル参照文書」 “style reference document” とも呼ばれています. ポイントは, まずはこのテンプレート文書を Pandoc から作成し, それからスタイル定義を変更しなければならないということです. それからこのテンプレートファイルのパスを word_document の reference_docx オプションに与えてください. 例えばこのように. --- output: word_document: reference_docx: &quot;template.docx&quot; --- たった今言及したように, template.docx は Pandoc から生成されたものでなければなりません. このテンプレートは word_document 出力フォーマットを使ったどのような R Markdown 文書 からでも (この文書の実際の内容はなんでも問題ありませんが, スタイルを適用したい要素の種類を含んでいるべきです) 作ることができます31. それから .docx ファイルを開き, スタイルを編集します. 図 8.1: 特定の文書要素のスタイルを見つける 図8.1は Word の「ホーム」タブから「スタイル」ウィンドウを開くと見つけられます. カーソルを文書の特定の要素上に動かすと, スタイルリストの項目が強調されます. ある要素のスタイルを変更したいならば, 強調された項目上でドロップダウンメニューの「変更」をクリックして図8.2のようなダイアログボックスを見ることができます. 図 8.2: Word 文書の要素のスタイルを変更する スタイルの編集を終わったら, 文書を保存し (誤って上書きしないようなファイル名にしてください), 今後の Word 文書のテンプレートとして使用することができます. Pandoc が参照文書テンプレートを与えられて新しい Word 文書をレンダリングするとき, テンプレートのスタイルが読み出されて新しい文書に適用されます. カスタムスタイル付きの Word テンプレートを作成する方法の詳細については, https://vimeo.com/110804387 で短い動画を見るか, https://rmarkdown.rstudio.com/articles_docx.html の記事を読むとよいでしょう. 文書の要素に対するスタイル名がすぐには見つからないこともあります. 複数のスタイルが同じ要素に適用され, それらのうち1つだけが強調されてみえることもあります. 修正したいスタイルが実際になんであるかは, 当て推量やネット検索で解決することが求められることもあります. 例えば「スタイルの管理」ボタン (図8.1のスタイルリストの下部にある, 左から3番目のボタン) をクリックし, “Table” スタイル (図8.3参照) を見つけるまでには多数のスタイル名をスクロールして飛ばさなければならりません. これでようやく, 枠線などの表のスタイルを修正できます. 図 8.3: Word 文書の表のスタイルを修正する 訳注 Word の日本語版へのローカライズの過程によるものか, バージョンアップによるものかは分かりませんが, Word のスタイル名は必ずしもこの章の例とは一致しないかもしれません. 訳注: この記述はややわかりにくいかもしれませんが, R Markdown もまた Pandoc によってファイルを生成していることを思い出してください. 具体的な手順は次のようになります. 一旦 (1) R Markdown 文書をコンパイルし docx ファイルを生成し, (2) このファイルを Word で開いて変更したい箇所のスタイル設定を行い, 保存します. (3) そして上記のように reference_docx フィールドに保存したファイルを指定してから, 再びファイルをコンパイルします. このとき参照されるのはスタイル情報のみなので, 既に保存した文書の内容は出力に影響しません.↩︎ "],["word-redoc.html", "8.2 R Markdown と Word 間の双方向ワークフロー", " 8.2 R Markdown と Word 間の双方向ワークフロー R Markdown から Word 文書を生成するのは簡単ですが, その一方, 誰かが Word 文書を編集したものを元の R Markdown 文書に手動で反映しなければならないときは, 特に苦痛が伴います. 幸いにも Noam Ross がこの問題に対して有望な解決策を提示しています. redoc パッケージ (https://github.com/noamross/redoc) は Word 文書を生成し, 文書を校正してから R Markdown に再度変換することを可能にします. この原稿を書いている現時点 (2020年6月) では redoc パッケージはまだ試験的であり, さらに不運なことに, 彼は開発を中止しています. どちらにせよこれを試して見たいなら, GitHub からインストールすることができます. remotes::install_github(&quot;noamross/redoc&quot;) パッケージがインストールされたら, 出力フォーマット redoc::redoc を使うこともできます. --- output: redoc::redoc --- この出力フォーマットは, 実際には元の Rmd 文書を保存したWord 文書を生成するので, Word 文書を Rmd に変換して戻すこともできます. Word 上の変更履歴は CriticMarkup 構文 (http://criticmarkup.com) で書かれたテキストへ変換されます 例えば {++ 重要 ++} はテキストに「重要」という単語が挿入されたことを表現しています. redoc::redoc で生成された Word 文書は, redoc::dedoc() 関数で Rmd に変換できます. 例えば redoc::dedoc(\"file.docx\") は file.Rmd を生成します. この処理では Word 上の変更履歴にどう対処するかを track_changes 引数で決めることができます. 例えば変更を受け入れるか破棄するか, 変更履歴を CriticMarkup に変換するかなどです. 変更履歴が完全に失われてしまわないように, track_changes = 'criticmarkup' を使うことを推奨します. Word 文書を編集する際には, R Markdown のコードチャンクやインライン R コードによって自動生成されていない箇所を編集すると想定されています. 例えばコードチャンク内で knitr::kable() を使って自動生成された表は編集してはなりません. そのような変更は dedoc() で Word から Rmd に変換する際に失われるからです. コードチャンクで自動生成された出力を誤って編集することを避けるために, redoc::redoc フォーマットの highlight_outputs オプションを trueに設定してください. これは自動出力した箇所を Word 上で背景色で強調表示することを意味します. あなたの共同編集者には Word 文書上の強調表示された箇所に触れないよう伝えるべきでしょう. 繰り返しになりますが, redoc パッケージは未だ試験的であり現時点ではその機能がはっきりしないため, ここでの導入はあえて簡潔なものとしています. 信用できない場合, GitHub 上のパッケージのドキュメントを読むことをお薦めします32. 訳注: 2021/5/7 現在, redoc パッケージは開発を中止しています. 動作確認は使用者自身でお願いします.↩︎ "],["word-officedown.html", "8.3 個別の要素にスタイルを設定する", " 8.3 個別の要素にスタイルを設定する Markdown のシンプルさにより, Word 文書全体に対してグローバルなスタイル設定ができます (8.1節参照) が, ある単語に色を着けたりある段落の中央揃えなど, 個別の要素に直接スタイルを設定することはできません. David Gohel は, R 上で Office 文書で作業するのをより簡単にするという努力を続ける中で, 2018 年に officedown パッケージ (Gohel and Ross 2021)の開発を始めました. これは officer (Gohel 2021b) パッケージの機能のいくつかを R Markdown に持ち込むのが目的です. 本書の執筆時点ではこのパッケージの初期のバージョンが CRAN で公開されていますが, まだ実験的です. CRAN あるいは GitHub どちらからでもインストールできます. # CRAN からインストール install.packages(&quot;officedown&quot;) # GitHub からインストール remotes::install_github(&quot;davidgohel/officedown&quot;) パッケージがインストールされたら, R Markdown 文書内で読み込む必要があります. 例えばこのように. ```{r, setup, include=FALSE} library(officedown) ``` officedown パッケージには rdocx_document という出力フォーマットがあります. これはデフォルトでは rmarkdown::word_document を基礎にして, 表やグラフにスタイル付けする機能が追加されています. officedown パッケージは officer パッケージを介して特定の Word 要素にスタイルを適用することを可能にします. 例えば officer::fp_text() 関数でスタイルを作成し, インライン R コードの ftext() でテキストの一部にそのスタイルを適用できます. --- title: officedown でテキストにスタイルを適用する output: officedown::rdocx_document: default --- ```{r} library(officedown) library(officer) ft &lt;- fp_text(color = &#39;red&#39;, bold = TRUE) ``` # テスト **officedown** パッケージは `r ftext(&#39;すごい&#39;, ft)`! officer の関数とは別に, officedown パッケージは特殊な HTML コメントを使って officer のタスクが実現できます. 例えば officer::block_pour_docx() は外部の Word 文書を現在の文書にインポートするのに用いますが, 代わりに R Markdown 上で HTML コメントを使うこともできます. &lt;!---BLOCK_POUR_DOCX{file: &#39;my-file.docx&#39;}---&gt; これはインライン R コードで以下のように書くのと等価です. `r block_pour_docx(file = &#39;my-file.docx&#39;)` officedown と officer パッケージで他にできることとして, 以下のようなものがあります. 改ページの挿入 多段組みレイアウトの配置 段落設定の変更 目次の挿入 あるセクションのページの向きを変える (縦向きか横向きか) officedown についてもっと学ぶには, 公式ドキュメント https://davidgohel.github.io/officedown/ をご覧ください. :::.infobox .memo data-latex=“{memo}”} 訳注 翻訳者は officedown のテンプレートを日本語化した簡易的なパッケージを作成しています. https://github.com/Gedevan-Aleksizde/wordja ::: 参考文献 "],["multi-formats.html", "9 複数の出力フォーマット", " 9 複数の出力フォーマット R Markdown の主な利点は1つのソースから複数種類の出力フォーマットを作成できることです. これは1つ以上の Rmd ファイルでも可能です. 例えば本書は R Markdown で書かれ, 2種類のフォーマットでコンパイルされています. 印刷用の PDF と, オンライン版の HTML です. コードチャンクの出力を全ての出力フォーマットに対応させるのは時には難題になることがあります. 例えばたった1つの CSS ルール (img { border-radius: 50%; }) で HTML 出力に対して円の画像を作成するのは非常に単純ですが, LaTeX 出力ではこれとそのまま同じようにはいきません. 典型的には Tikz グラフィックスに関係する問題になります. ある出力要素がすべての出力フォーマットに対して動作するわけではありません. 例えば gifski パッケージ (Ooms 2021a) (4.14節参照) で GIF アニメを簡単に作ることができ, これは HTML 出力では完璧に動作しますが, LaTeX 出力に埋め込んだものは追加の GIF ファイルの処理と LaTeX パッケージなしでは不可能です. この章では複数のフォーマットで動作する例を少しだけ提示します. ある機能が特定の出力フォーマットでのみ有効なら, その出力フォーマットに基づいて条件付きで有効・無効にする方法を提示します. 参考文献 "],["latex-html.html", "9.1 LaTeX か HTML か", " 9.1 LaTeX か HTML か LaTeX と HTML はどちらもよく使われるフォーマットです. knitr::is_latex_output() 関数は出力フォーマットが LaTeX かどうか (Pandoc 出力フォーマットの latex および beamer) を教えてくれます. 同様に knitr::is_html_output 関数は出力フォーマットが HTML かどうか教えてくれます. デフォルトでは Pandoc 出力フォーマットのうち markdown, epub, html, html4, html5, revealjs, s5, slideous, そして slidy が HTML 出力とみなされます. ある Pandoc 出力が HTML であると思えないなら, そのフォーマットを除外するために, 例えばこのように excludes 引数を使えます. # markdown を HTML として扱わない knitr::is_html_output(excludes = &quot;markdown&quot;) ## [1] TRUE ある出力要素が LaTeX または HTML のみで生成されるのなら, これらの関数を条件つきで生成できるように使えます. 例えば, PDF のページには大きすぎる表はフォントサイズを小さくした環境内に表を入れるとよいでしょうが, そういった LaTeX 環境は HTML 出力では機能しませんので, HTML 出力に含めるべきでありません (HTML 出力でフォントサイズを調整したいなら, CSS を使うこともできます). 以下はその例です. --- title: tiny 環境内で表をレンダリングする output: pdf_document: latex_engine: lualatex html_document: default documentclass: ltjsarticle --- ```{r, setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) options(knitr.table.format = function() { if (knitr::is_latex_output()) &#39;latex&#39; else &#39;pandoc&#39; }) ``` LaTeX 環境の `tiny` は LaTeX 出力でのみ生成されます. ```{r, include=knitr::is_latex_output()} knitr::asis_output(&#39;\\n\\n\\\\begin{tiny}&#39;) ``` ```{r} knitr::kable(mtcars) ``` ```{r, include=knitr::is_latex_output()} knitr::asis_output(&#39;\\\\end{tiny}\\n\\n&#39;) ``` 比較のため, 以下に通常のフォントサイズの表を配置します. ```{r} knitr::kable(mtcars) ``` 上記の例でのポイントはチャンクオプション include = knitr::is_latex_output() です. \\begin{tiny} \\end{tiny} 環境は出力フォーマットが LaTeX の場合のみ含まれます. この例の2つの表は出力が LaTeX でない場合は同じ見た目になるでしょう. 5.1節では HTML と LaTeX 出力のテキストの色を変更する関数を使用しました. 4.14節では, アニメーションの例を提示しました. これにも今回の小ワザを使うことができます. HTML 出力に対してアニメーションを生成し, LaTeX 出力に対しては静止画を生成するコードチャンクはこのようになります. ```{r animation.hook=if (knitr::is_html_output()) &#39;gifski&#39;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&#39;red&#39;, &#39;yellow&#39;), labels = NA) } ``` これらの条件付けのための関数はどこでも使えます. 他のチャンクオプションにも使えます (例えばチャンクの評価に条件を付けるため eval に使うなど) し, あるいはこの例のように R コード内にも使えます. ```{r, eval=knitr::is_html_output(), echo=FALSE} cat(&#39;これは HTML 出力でのみ見えます&#39;) ``` ```{r} if (knitr::is_latex_output()) { knitr::asis_output(&#39;\\n\\n\\\\begin{tiny}&#39;) } ``` "],["html-widgets.html", "9.2 HTML ウィジェットを表示する", " 9.2 HTML ウィジェットを表示する HTML ウィジェット (https://htmlwidgets.org) はインタラクティブな JavaScript アプリケーションの典型で, HTML 出力でのみ動作します. HTML ウィジェットを含んだ Rmd 文書を, PDF や Word など HTML でないフォーマットへと knit すると, このようなエラーメッセージが返ってくるでしょう. Error: Functions that produce HTML output found in document targeting X output. Please change the output type of this document to HTML. Alternatively, you can allow HTML output in non-HTML formats by adding this option to the YAML front-matter of your rmarkdown file: always_allow_html: yes Note however that the HTML output will not be visible in non-HTML formats. 上記のエラーメッセージに示された解決法よりも良い方法があるのですが, 追加のパッケージが絡んできます. R に webshot パッケージ(Chang 2019) をインストールし, さらに PhantomJS をインストールしてください. install.packages(&quot;webshot&quot;) webshot::install_phantomjs() それから HTML ウィジェットつきの Rmd 文書を非 HTML フォーマットで knit すれば, HTML ウィジェットは静的なスクリーンショットとして表示されます. スクリーンショットは knitr によって自動的に作られます. bookdown 本の Section 2.10 に, スクリーンショットの詳しい操作方法が書かれています. 参考文献 "],["include-url.html", "9.3 Web ページの埋め込み", " 9.3 Web ページの埋め込み webshot パッケージ (Chang 2019) と PhantomJS をインストール (9.2説参照)していれば, knitr::include_url() でどんな web ページも出力文書に埋め込むことができます. コードチャンク内でこの関数に URL を与えれば, 出力フォーマットが HTML ならば &lt;iframe&gt; (インラインフレーム) が生成され, 他のパッケージならばスクリーンショットが埋め込まれます. 例えば図9.1は, 本書のオンライン版を読んでいるなら私の個人サイトが, それ以外なら代わりに静的なスクリーンショットが現れているはずです. knitr::include_url(&quot;https://yihui.org&quot;) 図 9.1: iframe または screenshot による Yihui’s のホームページ out.width や fig.cap といった図に関連するほとんどのチャンクオプションが knitr::include_url() でも機能します. サーバ上で Shiny アプリを公開しているなら, knitr::include_app() を使えばこれを文書に含めることができます. これは include_url() と同じように動作します. bookdown 本 (Xie 2016) の Section 2.11 には include_app() と include_url() に関する詳細な話が書かれています. 参考文献 "],["figures-side.html", "9.4 複数の図を横並びに", " 9.4 複数の図を横並びに fig.show=\"hold\" と out.width option オプションを併用して複数の図を並べることができます. 以下の例では out.width=\"48%\" を設定し, 出力は図9.2になります. ```{r, figures-side, fig.show=&quot;hold&quot;, out.width=&quot;48%&quot;} par(mar = c(4, 4, .1, .1)) plot(cars) plot(mpg ~ hp, data = mtcars, pch = 19) ``` 図 9.2: 横に並べた図 この単純なアプローチは PDF でも HTML 出力でも動作します. 訳注 この方法は, PDF では必ず横並びになるとは限りません. 余白にはみ出す大きさならば, 自動で折り返されます. これは LaTeX 側の文書スタイルの設定にも依存し, 多くの場合は欧文と和文でよく使われるレイアウトが異なることが原因です. よって, ここでは原著とは異なり画像サイズを 48% と少し小さくしています. 図の内部に複数のプロットがあり, サブ図を使いたいなら, 6.6節を見てください. しかしサブ図は LaTeX 出力に対してのみサポートされているので気をつけてください. "],["raw-content.html", "9.5 生のコードを書く (*)", " 9.5 生のコードを書く (*) 6.11節で紹介したテクニックは実に広く使えます. いかに複雑な生のコードであっても Markdown 内で「生の」コンテンツとして保護するよう指定できます. 例えば HTML を直接書いたなら, =html 属性を使用することができます. ```{=html} &lt;p&gt;どんな&lt;strong&gt;生の&lt;/strong&gt; HTML コンテンツでもここでは動作します. 例えば, ここにユーチューブのビデオがあります.&lt;/p&gt; &lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;https://www.youtube.com/embed/s3JldKoA0zw?rel=0&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen&gt;&lt;/iframe&gt; ``` 属性名は Pandoc 出力の名前です. 出力フォーマット名を知りたいなら, Rmd 内で以下のコードチャンクの出力をみてください. ```{r} knitr::pandoc_to() ``` 生のコンテンツは特定の出力フォーマットでのみ表示されることに注意してください. 例えば生の LaTeX コンテンツは出力フォーマットが HTML の場合は無視されます. "],["custom-blocks.html", "9.6 カスタムブロック (*)", " 9.6 カスタムブロック (*) bookdown 本の 2.7節 では, どうすれば R Markdown でブロックの見た目をカスタマイズできるかを話しました. これはレポートや本の中でコンテンツを目立たせる便利な方法で, 読者があなたの著作の中の要点を確実に取りせるようにできます. これらのブロックの使い方の例として, 次のようなものがあります. あなたの分析コードを実行する前に, ユーザが最新のパッケージを使用しているか確認するための警告メッセージを表示する. ソースコードのある GitHub リポジトリへのリンクを文書の冒頭に追加する. あなたの分析から得られた要点や知見を強調する. この節では PDF と HTML の両方でカスタムブロックを作成する方法を説明します. どちらのフォーマットでも R Markdown 上で同じ整形の構文を使用できますが, 要求される設定は異なります. 9.6.1 構文 カスタムブロックの構文は Pandoc の fenced Div blocks に基づいています. Div ブロックはとても強力ですが1つだけ問題があります. これはおもに HTML 出力に対して動作しますが, LaTeX 出力に対しては動作しないことです. バージョン 1.16 以降の rmarkdown パッケージは Div ブロックを HTML と LaTeX どちらに対しても変換するようになりました. HTML 出力に対してはブロックの全ての属性が &lt;div&gt; タグの属性になります. 例えば Div は ID (# の後のに続くもの), 1つまたは複数のクラス (クラス名は . の後に書かれるものです), そしてそれ以外の属性を持ちます. 以下の Div ブロック, ::: {#hello .greeting .message style=&quot;color: red;&quot;} Hello **world**! ::: は以下の HTML コードに変換されます. &lt;div id=&quot;hello&quot; class=&quot;greeting message&quot; style=&quot;color: red;&quot;&gt; Hello &lt;strong&gt;world&lt;/strong&gt;! &lt;/div&gt; LaTeX 出力に対しては, 最初のクラス名が LaTeX 環境名として使われます. また, Div ブロックに data-latex と名付けた属性を与え, 環境の引数としましょう. 環境が引数を必要としないなら, この属性は空白にすることができます. 2つの単純な例を以下にお見せします. 1つ目の例は LaTeX で verbatim 環境を使用します. これは引数を必要としません. ::: {.verbatim data-latex=&quot;&quot;} ここに _verbatim_ テキストを表示. ::: LaTeX 出力はこうなります. \\begin{verbatim} ここに \\emph{verbatim} テキストを表示. \\end{verbatim} ブロックが HTML へと変換される場合は, HTML コードはこのようになります. &lt;div class=&quot;verbatim&quot;&gt; ここに &lt;em&gt;verbatim&lt;/em&gt; テキストを表示. &lt;/div&gt; 2つ目の例では center と minipage 環境を使い, ページ幅の半分の大きさに中央揃えしたボックス内にテキストを表示しています. :::: {.center data-latex=&quot;&quot;} ::: {.minipage data-latex=&quot;{.5\\linewidth}&quot;} この段落は中央揃えされ, 親要素の半分の幅で表示されます. ::: :::: center ブロックの中に minipage ブロックをネストしていることに注意してください. 親ブロックに子ブロックを入れるには, さらにコロンが必要です. 上記の例では center ブロックに4つのコロンを使用していますが, 5個以上書くことも可能です. 2つのブロックは以下の LaTeX コードに変換されます. \\begin{center} \\begin{minipage}{.5\\linewidth} この段落は中央揃えされ, 親要素の半分の幅で表示されます. \\end{minipage} \\end{center} HTML 出力では, ユーザーの好みで CSS によって &lt;div&gt; ブロックの外見を定義することもできます. LaTeX 出力の場合は, 環境が未定義ならば \\newenvironment を, 既存の環境を再定義するならば \\renewenvironment コマンドを LaTeX 上で使うこともできます. LaTeX 上での定義で PDF 上でのブロックの見た目を決定できます. これらのカスタマイズは通常は style.css や preamble.tex といったファイルを内に記述して, YAML オプションで読み込みます. --- output: html_document: css: style.css pdf_document: includes: in_header: preamble.tex --- 次に, CSS ルールや LaTeX 環境を使用したいくつか発展的なカスタムブロックの実例をお見せします. さらなる使用例としては, 5.8節に, 多段組みレイアウト内で複数ブロックを並べるものがあります. 9.6.2 影付きブロックを追加する まず, 影付きボックスの内部にコンテンツを入れる方法を紹介します. ボックスは黒の背景色とオレンジ色の枠があり, 角は丸めます. ボックス内のテキストは白色です. HTML 出力に対しては, CSS ファイル内でそのルールを定義します. CSSにあまり詳しくなくても, 無料で見られるオンラインチュートリアルが豊富にあります. 例えば https://www.w3schools.com/css/ とか33. .blackbox { padding: 1em; background: black; color: white; border: 2px solid orange; border-radius: 10px; } .center { text-align: center; } LaTeX 出力に対しては, LaTeX パッケージの framed を基にして blackbox という名前で新しい環境を作成し, 黒い背景色と白い文字色にします. \\usepackage{color} \\usepackage{framed} \\setlength{\\fboxsep}{.8em} \\newenvironment{blackbox}{ \\definecolor{shadecolor}{rgb}{0, 0, 0} % black \\color{white} \\begin{shaded}} {\\end{shaded}} 本書で framed パッケージを使うのはこれがかなり軽量だからですが, このパッケージは色付きで角の丸い枠を描画することができません. それを実現するには, より洗練された LaTeX パッケージである tcolorblox (https://ctan.org/pkg/tcolorbox)が必要です. このパッケージには影付きボックスを作るためのとても柔軟な一連のオプションがあります. パッケージのドキュメントからは多くの使用例を見ることができます. 以下の LaTeX 環境は上記の CSS の例と似た影付きボックスを作成できます. \\usepackage{tcolorbox} \\newtcolorbox{blackbox}{ colback=black, colframe=orange, coltext=white, boxsep=5pt, arc=4pt} これで PDF と HTML 出力の両方のフォーマットでカスタムボックスを使用できるようになりました. ボックスのソースコードはこのようになります. :::: {.blackbox data-latex=&quot;&quot;} ::: {.center data-latex=&quot;&quot;} **注意!** ::: この**新しい注意書き**を見てくれてありがとう! あなたがこれを見ていることは監視されており, 当局に報告される! :::: 出力はこうなります. 注意! この新しい注意書きを見てくれてありがとう! あなたがこれを見ていることは監視されており, 当局に報告される! 9.6.3 アイコンを加える カスタムボックス内に画像を含めることで, より見た目で注意を引く作りにできます. 画像はブロックの内容をより効果的に伝える方法にもなりえます. 以下に続く例では, 次のようなディレクトリ構造で動作させるという前提にしています. これは本書を作成するために使ったものを簡略化したものです. directory/ your-report.Rmd style.css preamble.tex images/ important.png note.png caution.png ... 全体がどのように動作するかを説明する前に, この例のソースコードと出力をお見せしましょう. ::: {.infobox .caution data-latex=&quot;{caution}&quot;} **注意!** この**新しい注意書き**を見てくれてありがとう! あなたがこれを見ていることは監視されており, 当局に報告される! ::: 出力はこうなります. 注意! この新しい注意書きを見てくれてありがとう! あなたがこれを見ていることは監視されており, 当局に報告される! HTML 出力では, CSS の background-image プロパティ内にボックスの画像を追加することができます. 背景に画像を挿入し, 左側に十分な幅のパディングを追加することでテキストと画像の重なりを避けます. ローカルの画像ファイルを使用するなら, ファイルパスは CSS との相対パスで与えます. これが例です. .infobox { padding: 1em 1em 1em 4em; margin-bottom: 10px; border: 2px solid orange; border-radius: 10px; background: #f5f5f5 5px center/3em no-repeat; } .caution { background-image: url(&quot;images/caution.png&quot;); } ブロックに .infobox と .caution という2つのクラス名を使用していることに注意してください. infobox クラスは色付きの外枠のある影付きボックスを定義するのに使用し, caution クラスは画像を入れるために使用されています. 2つのクラスを使用する利点は影付きボックスの設定を繰り返すことなく, いろいろなアイコンの付いたブロックを定義できるということです. 例えば, warning のボックスが必要ならば, .infobox のルールを繰り返し書くことなく, 以下のように定義するだけで十分です. .warning { background-image: url(&quot;images/warning.png&quot;); } すると以下の Markdown ソースコードで warning ボックスを作成できます. :::: {.infobox .warning data-latex=&quot;warning&quot;} 実際のコンテンツをここに表示 :::: PDF 出力に対しては, 以前の例で定義した blackbox 環境を基に infobox 環境を作成し, ボックスの左側に画像を追加できます. LaTeX 環境に画像を追加する方法はいくつもあります. これはそのうちの1つにすぎません. なお, これは上記の CSS で定義したスタイルを正確に再現するものではありません. \\newenvironment{infobox}[1] { \\begin{itemize} \\renewcommand{\\labelitemi}{ \\raisebox{-.7\\height}[0pt][0pt]{ {\\setkeys{Gin}{width=3em,keepaspectratio} \\includegraphics{images/#1}} } } \\setlength{\\fboxsep}{1em} \\begin{blackbox} \\item } { \\end{blackbox} \\end{itemize} } 以下に, 様々なアイコンを付けたブロックを掲載します. 注意! この新しい注意書きを見てくれてありがとう! あなたがこれを見ていることは監視されており, 当局に報告される! 注意! この新しい注意書きを見てくれてありがとう! あなたがこれを見ていることは監視されており, 当局に報告される! 注意! この新しい注意書きを見てくれてありがとう! あなたがこれを見ていることは監視されており, 当局に報告される! 注意! この新しい注意書きを見てくれてありがとう! あなたがこれを見ていることは監視されており, 当局に報告される! 代替案として, LaTeX パッケージの awesomebox を使って PDF にアイコン付きのボックスを生成することもできます. このパッケージがあれば非常に多くのアイコンを選ぶことができます. 以下に簡単な例をお見せします. 使用可能な LaTeX 環境と引数についてはパッケージのドキュメントを参照してください. --- title: Awesome Boxes output: pdf_document: latex_engine: lualatex extra_dependencies: awesomebox documentlass: ltjsarticle mainfont: Noto Serif CJK JP sansfont: Noto Sans CJK JP --- &quot;note&quot; 型のボックス: ::: {.noteblock data-latex=&quot;&quot;} この**新しい注意書き**を見てくれてありがとう! あなたがこれを見ていることは監視されており, あなたがこれを見ていることは監視されており, _当局に報告される_! ::: このボックスの引数を生成するための R 関数 `box_args()` を定義しました. ```{r} box_args &lt;- function( vrulecolor = &#39;white&#39;, hrule = c(&#39;\\\\abLongLine&#39;, &#39;\\\\abShortLine&#39;, &#39;&#39;), title = &#39;&#39;, vrulewidth = &#39;0pt&#39;, icon = &#39;Bomb&#39;, iconcolor = &#39;black&#39; ) { hrule &lt;- match.arg(hrule) sprintf( &#39;[%s][%s][\\\\textbf{%s}]{%s}{\\\\fa%s}{%s}&#39;, vrulecolor, hrule, title, vrulewidth, icon, iconcolor ) } ``` インライン R コード内で `awesomeblock` 環境に引数を与えます. ::: {.awesomeblock data-latex=&quot;`r box_args(title = &#39;注意!&#39;)`&quot;} この**新しい注意書き**を見てくれてありがとう! あなたがこれを見ていることは監視されており, _当局に報告される_! ::: 訳注: 翻訳者の開発した rmdja パッケージでは, デフォルトでこの節で紹介されているようなカスタムブロックが定義されており, より簡単にアイコン付きブロックを記述できます. 詳細はこのパッケージのドキュメントをご覧ください. 訳注: このサイト相当の日本語のサイトを翻訳者は知らないので Moziila のサイトなどを参考にしてください https://developer.mozilla.org/ja/docs/Learn/Getting_started_with_the_web/CSS_basics (一部未翻訳のページもあるかもしれません)↩︎ "],["tables.html", "10 表", " 10 表 表は, レポート上で結果を伝えることができる主要な手段です. 表を独自の要件に合った外見に調整したいことはよくあります. この章では表のカスタマイズに使えるテクニックを紹介します. この章のねらいは以下のとおりです. 表生成関数 knitr::kable() の全ての特徴を紹介する kableExtra パッケージ (Zhu 2021) を使用したより発展的な表のカスタマイズに焦点を当てる 表を生成してくれる他のパッケージの一覧を提示する 参考文献 "],["kable.html", "10.1 knitr::kable() 関数", " 10.1 knitr::kable() 関数 knitr パッケージの kable() 関数はとてもシンプルな表生成用の関数で, その設計もシンプルです. 行列やデータフレームのように厳密に矩形状のデータに対してのみ表を生成します. 表のセルを細かく整形したりセルを結合したりはできません. しかしこの関数は表の外見をカスタマイズする多くの引数を持っています. kable(x, format, digits = getOption(&quot;digits&quot;), row.names = NA, col.names = NA, align, caption = NULL, label = NULL, format.args = list(), escape = TRUE, ...) 10.1.1 サポートする表形式 データオブジェクト x を単純な表で表すことだけが必要ならば, ほとんどの場合, knitr::kable(x) で十分でしょう. format 引数は knitr のソース文書フォーマットに従って自動的に設定されます. 引数が取り得る値は列をパイプで区切った pipe, Pandoc 式の単純な表である simple, LaTeX の表 latex, HTML の表 html, reStructuredText (rst) 形式の rst です. R Markdown 文書に対して kable() はデフォルトで pipe フォーマットを使用し, このような外見になります. knitr::kable(head(mtcars[, 1:4]), &quot;pipe&quot;) | | mpg| cyl| disp| hp| |:-----------------|----:|---:|----:|---:| |Mazda RX4 | 21.0| 6| 160| 110| |Mazda RX4 Wag | 21.0| 6| 160| 110| |Datsun 710 | 22.8| 4| 108| 93| |Hornet 4 Drive | 21.4| 6| 258| 110| |Hornet Sportabout | 18.7| 8| 360| 175| |Valiant | 18.1| 6| 225| 105| 単純な表, そして HTML, LaTeX, reStructuredText での表を生成できます. knitr::kable(head(mtcars[, 1:4]), &quot;simple&quot;) mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 Datsun 710 22.8 4 108 93 Hornet 4 Drive 21.4 6 258 110 Hornet Sportabout 18.7 8 360 175 Valiant 18.1 6 225 105 knitr::kable(mtcars[1:2, 1:2], &quot;html&quot;) &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; mpg &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; cyl &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 Wag &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; knitr::kable(head(mtcars[, 1:4]), &quot;latex&quot;) \\begin{tabular}{l|r|r|r|r} \\hline &amp; mpg &amp; cyl &amp; disp &amp; hp\\\\ \\hline Mazda RX4 &amp; 21.0 &amp; 6 &amp; 160 &amp; 110\\\\ \\hline Mazda RX4 Wag &amp; 21.0 &amp; 6 &amp; 160 &amp; 110\\\\ \\hline Datsun 710 &amp; 22.8 &amp; 4 &amp; 108 &amp; 93\\\\ \\hline Hornet 4 Drive &amp; 21.4 &amp; 6 &amp; 258 &amp; 110\\\\ \\hline Hornet Sportabout &amp; 18.7 &amp; 8 &amp; 360 &amp; 175\\\\ \\hline Valiant &amp; 18.1 &amp; 6 &amp; 225 &amp; 105\\\\ \\hline \\end{tabular} knitr::kable(head(mtcars[, 1:4]), &quot;rst&quot;) ================= ==== === ==== === \\ mpg cyl disp hp ================= ==== === ==== === Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 Datsun 710 22.8 4 108 93 Hornet 4 Drive 21.4 6 258 110 Hornet Sportabout 18.7 8 360 175 Valiant 18.1 6 225 105 ================= ==== === ==== === pipe と simple のフォーマットのみが移植可能だと覚えておいてください. つまり, これだけがどの出力文書フォーマットでも動作します. それ以外の表形式は特定のフォーマットに対してのみ, 例えば format = 'latex' は LaTeX 出力に対してのみの動作です. 特定の表形式を使うことでより細かい操作ができますが, 代わりに移植性を犠牲にします. 特定の1つの表形式だけが必要で, それが文書のデフォルト形式でないなら, knitr.table.format という R のグローバルオプションで一括設定できます. 例えばこのように. options(knitr.table.format = &quot;latex&quot;) このオプションには, 表形式を表す文字列か NULL を返す関数を与えることもできます. NULL の場合は knitr は適切な表形式を自動的に決定しようとします. 例えば出力フォーマットが LaTeX の場合のみ latex を使用できます. options(knitr.table.format = function() { if (knitr::is_latex_output()) &quot;latex&quot; else &quot;pipe&quot; }) 10.1.2 列名を変更する データフレームの列の名前と読者に見せたいものとが一致するとは限りません. R のデータの列名でよくあるのは, 単語を区切るのにスペースを使わずドットやアンダースコアで代用します. これは表を読む上で不自然に感じるでしょう. col.names 引数を使うと列名を新しい名前のベクトルで置き換えることができます. 例えば iris データの列名のドットをスペースに置換します. iris2 &lt;- head(iris) knitr::kable(iris2, col.names = gsub(&quot;[.]&quot;, &quot; &quot;, names(iris))) Sepal Length Sepal Width Petal Length Petal Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa col.names 引数には必ずしも gsub() ような関数で列を与える必要はなく, 元のデータオブジェクトの列数と同じ長さであれば, 以下の例のように好きな文字列ベクトルを与えることができます. knitr::kable( iris, col.names = c(&#39;ここ&#39;, &#39;には&#39;, &#39;5つの&#39;, &#39;名前が&#39;, &#39;必要&#39;) ) 10.1.3 列のアラインメントを指定する 表の各列のアラインメントを変更するには, 左揃え l, 中央揃え c, 右揃え r のどれかと一致する1文字づつの文字ベクトルまたは, 1つの文字列で指定できます. よって kable(..., align = c('c', 'l')) は kable(..., align = 'cl') に省略できます. デフォルトでは, 数値列は右揃えで, それ以外は左揃えになります. これが使用例です. # 左, 中央, 中央, 中央, 右, 右揃え knitr::kable(iris2, align = &quot;lccrr&quot;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 10.1.4 表にキャプションを追加する caption 引数で表にキャプションを追加できます. 以下が例です (表10.1参照). knitr::kable(iris2, caption = &quot;表のキャプションの例&quot;) 表 10.1: 表のキャプションの例 Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.7節で言及したように, 出力フォーマットが bookdown パッケージ由来のものであれば, キャプションのある表を相互参照することができます. 10.1.5 数値列を整形する 小数点以下の最大表示桁数を digits 引数で指定できます. 値は round() 関数に与えられるものと同じです. それ以外の整形用の引数は base R の format() 関数に与えられるものを format.args に与えられます. まず round() や format() を使ったいくつかの簡単な例をお見せすれば, この後の kable() 引数がどう動作するか理解できることでしょう. round(1.234567, 0) ## [1] 1 round(1.234567, digits = 1) ## [1] 1.2 round(1.234567, digits = 3) ## [1] 1.235 format(1000, scientific = TRUE) ## [1] &quot;1e+03&quot; format(10000.123, big.mark = &quot;,&quot;) ## [1] &quot;10,000&quot; それでは表の数値を丸め整形します. d &lt;- cbind(X1 = runif(3), X2 = 10^c(3, 5, 7), X3 = rnorm(3, 0, 1000)) # 最大で4桁表示 knitr::kable(d, digits = 4) X1 X2 X3 0.0698 1e+03 -571.9407 0.7653 1e+05 -2161.6849 0.0049 1e+07 -1705.9400 # 列ごとにそれぞれ丸める knitr::kable(d, digits = c(5, 0, 2)) X1 X2 X3 0.06975 1e+03 -571.94 0.76528 1e+05 -2161.68 0.00491 1e+07 -1705.94 # 指数表記を使わせない knitr::kable(d, digits = 3, format.args = list(scientific = FALSE)) X1 X2 X3 0.070 1000 -571.941 0.765 100000 -2161.685 0.005 10000000 -1705.940 # 大きな数に対してカンマ区切りする knitr::kable(d, digits = 3, format.args = list(big.mark = &quot;,&quot;, scientific = FALSE)) X1 X2 X3 0.070 1,000 -571.941 0.765 100,000 -2,161.685 0.005 10,000,000 -1,705.940 10.1.6 欠損値を表示する デフォルトでは欠損値 (NA) は表の上で NA という文字で表示されます. これを R のグローバルオプション knitr.kable.NA で他の値に置き換えたり何も表示させない, つまり NA を空白にする, といったことができます. 例えば以下の2つ目の表では NA を空白に置き換え, 3つ目の表で ** で表示しています. d[rbind(c(1, 1), c(2, 3), c(3, 2))] &lt;- NA knitr::kable(d) # デフォルトでは NA は表示される X1 X2 X3 NA 1e+03 -571.9 0.7653 1e+05 NA 0.0049 NA -1705.9 # NA を空白に置き換え opts &lt;- options(knitr.kable.NA = &quot;&quot;) knitr::kable(d) X1 X2 X3 1e+03 -571.9 0.7653 1e+05 0.0049 -1705.9 options(knitr.kable.NA = &quot;**&quot;) knitr::kable(d) X1 X2 X3 ** 1e+03 -571.9 0.7653 1e+05 ** 0.0049 ** -1705.9 options(opts) # グローバルオプションを元に戻す 10.1.7 特殊文字をエスケープする あなたがもし HTML や LaTeX に詳しいなら, これらの言語にいくつかの特殊文字があることを知っているでしょう. 安全に出力するために, kable() はデフォルトでは escape = TRUE 引数によって特殊文字をエスケープし, これは全ての文字がそのまま表示され, 特殊文字はその特別な意味を失います. 例えば &gt; は HTML の表に対しては &amp;gt; に置き換えられ, LaTeX の表に対しては _ は \\_ としてエスケープされます. あなたが専門家で, 特殊文字を適切に扱う方法を知っているなら, escape = FALSE 引数によってこれを無効化することもできます. 以下の2つ目の表では, 特殊文字である $, \\, _ を含む LaTeX の数式表現を与えています. m &lt;- lm(dist ~ speed, data = cars) d &lt;- coef(summary(m)) knitr::kable(d) Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -17.579 6.7584 -2.601 0.0123 speed 3.932 0.4155 9.464 0.0000 # 行と列の名前に数式表現を与える rownames(d) &lt;- c(&quot;$\\\\beta_0$&quot;, &quot;$\\\\beta_1$&quot;) colnames(d)[4] &lt;- &quot;$P(T &gt; |t|)$&quot; knitr::kable(d, escape = FALSE) Estimate Std. Error t value \\(P(T &gt; &amp;#124;t&amp;#124;)\\) \\(\\beta_0\\) -17.579 6.7584 -2.601 0.0123 \\(\\beta_1\\) 3.932 0.4155 9.464 0.0000 escape = FALSE なしでは特殊文字はエスケープされるか置き換えられます. 例えば $ は \\$ に, _ は \\_ に, \\ は \\textbackslash{} にエスケープされます. knitr::kable(d, format = &quot;latex&quot;, escape = TRUE) \\begin{tabular}{l|r|r|r|r} \\hline &amp; Estimate &amp; Std. Error &amp; t value &amp; \\$P(T &gt; |t|)\\$\\\\ \\hline \\$\\textbackslash{}beta\\_0\\$ &amp; -17.579 &amp; 6.7584 &amp; -2.601 &amp; 0.0123\\\\ \\hline \\$\\textbackslash{}beta\\_1\\$ &amp; 3.932 &amp; 0.4155 &amp; 9.464 &amp; 0.0000\\\\ \\hline \\end{tabular} LaTeX で他によく知られた特殊文字として, #, %, &amp;, {, } があります. HTML のよく知られた特殊文字は &amp;, &lt;, &gt; そして \" です. escape = FALSE で表を生成する際には, 正しい方法で特殊文字を使うよう注意深くなるべきです. とてもよくある失敗として, LaTeX で escape = FALSE を使いつつ, % や _ が特殊文字であると気づかずに表の列名やキャプションに含んでしまうというものがあります. 特殊文字のエスケープの方法を正しく知っている自信がないなら knitr には2つのヘルパー内部関数があります. 以下はその例です. knitr:::escape_latex(c(&quot;100%&quot;, &quot;# コメント&quot;, &quot;列名&quot;)) ## [1] &quot;100\\\\%&quot; &quot;\\\\# コメント&quot; &quot;列名&quot; knitr:::escape_html(c(&quot;&lt;アドレス&gt;&quot;, &quot;x = \\&quot;文字列\\&quot;&quot;, &quot;a &amp; b&quot;)) ## [1] &quot;&amp;lt;アドレス&amp;gt;&quot; &quot;x = &amp;quot;文字列&amp;quot;&quot; ## [3] &quot;a &amp;amp; b&quot; 10.1.8 複数の表を横に並べる データフレームや行列のリストを kable() に与えて, 複数の表を並べて生成することができます. 例えば表10.2は以下のコードから生成された2つの表を含んでいます. d1 &lt;- head(cars, 3) d2 &lt;- head(mtcars[, 1:3], 5) knitr::kable( list(d1, d2), caption = &#39;横に並べられた2つの表&#39;, booktabs = TRUE, valign = &#39;t&#39; ) 表 10.2: 横に並べられた2つの表 speed dist 4 2 4 10 7 4 mpg cyl disp Mazda RX4 21.0 6 160 Mazda RX4 Wag 21.0 6 160 Datsun 710 22.8 4 108 Hornet 4 Drive 21.4 6 258 Hornet Sportabout 18.7 8 360 この機能は HTML と PDF 出力でのみ機能することに注意してください. 表を横に並べて個別の表をカスタマイズできるようにしたいと考えているなら, kables() 関数 (つまり, kable() の複数形を意味しています) を使い, kable() オブジェクトのリストを与えることもできます. 例えば, 表10.3の左の表の列名を変更し, かつ右の表の表示桁数をゼロに変更します. # データオブジェクト d1, d2 は以前のコードチャンクのもの knitr::kables( list( # 第1の kable() は列名を変更する knitr::kable( d1, col.names = c(&#39;速さ&#39;, &#39;距離&#39;), valign = &#39;t&#39; ), # 第2の kable() は表示桁数を設定する knitr::kable(d2, digits = 0, valign = &#39;t&#39;) ), caption = &#39;knitr::kables() によって作成された2つの表.&#39; ) 表 10.3: knitr::kables() によって作成された2つの表. 速さ 距離 4 2 4 10 7 4 mpg cyl disp Mazda RX4 21 6 160 Mazda RX4 Wag 21 6 160 Datsun 710 23 4 108 Hornet 4 Drive 21 6 258 Hornet Sportabout 19 8 360 10.1.9 for ループから複数の表を作成する (*) kable() に関してよく混乱することの1つは, for ループ内では動作しないということです. この問題は kable() に限らず他のパッケージにも存在します. 原因は少々複雑です. 技術的な話に関心があるなら, “The Ghost Printer behind Top-level R Expressions.” というブログ記事で解説されています. 以下のコードチャンクは3つの表を生成する, とあなたは予想するかもしれませんが, そうはなりません. ```{r} for (i in 1:3) { knitr::kable(head(iris)) } ``` 明示的に kable() の結果をプリントし, チャンクオプション results = 'asis' を適用しなければなりません. 例えばこのように. ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(head(iris))) } ``` 一般に, for ループ内で出力を生成するときは, 出力する要素をそれぞれ区別するためにそれぞれの直後に改行コード (\\n) または HTML のコメント行 (&lt;!-- --&gt;) を加えることをおすすめします. これが例です. ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(head(iris), caption = &#39;A caption.&#39;)) cat(&#39;\\n\\n&lt;!-- --&gt;\\n\\n&#39;) } ``` セパレータがないと Pandoc は個別の要素を検出するのに失敗します. 例えばグラフのすぐ後に表を続けて書いたとき, 表が認識されなくなります. ![](logo.png) mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 しかし明示的に分離した場合はこうなります. 以下では画像の直後に空白行を挟んでいることに気をつけてください. ![](logo.png) mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 あるいはこのように. ![](logo.png) &lt;!-- --&gt; mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 10.1.10 LaTeX の表をカスタマイズする (*) 必要なのが LaTeX の出力のみなら, さらにいくつか kable() のオプションがあります. これらは HTML 等, 他の種類のフォーマットでは無視されることに注意してください. 表のフォーマットオプションをグローバルに設定 (10.1.1節参照) していない限り, この節の例では kable() の format 引数を明示的に使わなければなりません. knitr::kable(iris2, format = &quot;latex&quot;, booktabs = TRUE) 表のキャプションを設定 (10.1.4節参照) している場合, kable() は表を table 環境で囲みます. つまりこうなります. \\begin{table} % the table body (usually the tabular environment) \\end{table} この環境は table.envir 引数で次のように変更できます. knitr::kable(cars[1:2, ], format = &quot;latex&quot;, table.envir = &quot;figure&quot;) \\begin{figure} \\begin{tabular}{r|r} \\hline speed &amp; dist\\\\ \\hline 4 &amp; 2\\\\ \\hline 4 &amp; 10\\\\ \\hline \\end{tabular} \\end{figure} 表のフロート位置は position 引数によって制御されます. 例えば position = \"!b\" によって表のフロートをページ下部に置くことを強制できます. knitr::kable(cars[1:2, ], format = &quot;latex&quot;, table.envir = &quot;table&quot;, position = &quot;!b&quot;) \\begin{table}[!b] \\begin{tabular}{r|r} \\hline speed &amp; dist\\\\ \\hline 4 &amp; 2\\\\ \\hline 4 &amp; 10\\\\ \\hline \\end{tabular} \\end{table} 表にキャプションがある場合, caption.short 引数でこの例のようにキャプションの短縮形を与えることもできます. knitr::kable(iris2, caption = &quot;長い長いキャプション&quot;, caption.short = &quot;短いキャプション&quot;) キャプションの短縮形は LaTeX 上では \\caption[]{} コマンドのブラケット ([]) 内に与えられ, ほとんどの場合は出力された PDF の表一覧で使用されます. 短縮形がない場合は, キャプション全文が表示されます. 出版物レベルのクオリティで作表するための LaTeX パッケージ booktabs に詳しいなら, この例のように booktabs = TRUE を設定できます. iris3 &lt;- head(iris, 10) knitr::kable(iris3, format = &quot;latex&quot;, booktabs = TRUE) \\begin{tabular}{rrrrl} \\toprule Sepal.Length &amp; Sepal.Width &amp; Petal.Length &amp; Petal.Width &amp; Species\\\\ \\midrule 5.1 &amp; 3.5 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.9 &amp; 3.0 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.7 &amp; 3.2 &amp; 1.3 &amp; 0.2 &amp; setosa\\\\ 4.6 &amp; 3.1 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 5.0 &amp; 3.6 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ \\addlinespace 5.4 &amp; 3.9 &amp; 1.7 &amp; 0.4 &amp; setosa\\\\ 4.6 &amp; 3.4 &amp; 1.4 &amp; 0.3 &amp; setosa\\\\ 5.0 &amp; 3.4 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 4.4 &amp; 2.9 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.9 &amp; 3.1 &amp; 1.5 &amp; 0.1 &amp; setosa\\\\ \\bottomrule \\end{tabular} R Markdown で booktabs のような LaTeX パッケージが追加で必要なら, YAML で宣言しなければならないことを忘れないでください (やり方は6.4節参照). 引数 booktabs が TRUE か FALSE (デフォルト) であるかに依存して表の外見は変わります. booktabs = FALSE の場合 表の列が垂直線で区切られます. vline 引数を使って垂直線を削除することができます. 例えば knitr::kable(iris, vline = \"\") と言うふうにします. デフォルトは vline = \"|\" です.このオプションをグローバルに設定することもでき, 表ごとに指定する必要はありません. 例えば options(knitr.table.vline = \"\") とします. 水平線を toprule, midrule, linesep, bottomrule 引数で定義できます. これらのデフォルト値は \\hline です. booktabs = TRUE の場合 表に垂線はありませんが, vline 引数で追加することができます. テーブルのヘッダと末尾にのみ水平線が描かれます. デフォルトの引数の値は toprule = \"\\\\toprule\", midrule = \"\\\\midrule\", bottomrule = \"\\\\bottomrule\" です. デフォルトでは1行分の空きが5行ごとに挿入されます. これは linesep 引数で制御でき, このデフォルトは c(\"\", \"\", \"\", \"\", \"\\\\addlinespace\") となっています. 3行ごとに空白を与えたいなら, このようにできます. knitr::kable(iris3, format = &quot;latex&quot;, linesep = c(&quot;&quot;, &quot;&quot;, &quot;\\\\addlinespace&quot;), booktabs = TRUE) \\begin{tabular}{rrrrl} \\toprule Sepal.Length &amp; Sepal.Width &amp; Petal.Length &amp; Petal.Width &amp; Species\\\\ \\midrule 5.1 &amp; 3.5 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.9 &amp; 3.0 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.7 &amp; 3.2 &amp; 1.3 &amp; 0.2 &amp; setosa\\\\ \\addlinespace 4.6 &amp; 3.1 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 5.0 &amp; 3.6 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 5.4 &amp; 3.9 &amp; 1.7 &amp; 0.4 &amp; setosa\\\\ \\addlinespace 4.6 &amp; 3.4 &amp; 1.4 &amp; 0.3 &amp; setosa\\\\ 5.0 &amp; 3.4 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 4.4 &amp; 2.9 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ \\addlinespace 4.9 &amp; 3.1 &amp; 1.5 &amp; 0.1 &amp; setosa\\\\ \\bottomrule \\end{tabular} 行空けを完全に削除したいなら, linesep = '' とこともできます. 表がページよりも長くなってしまうもともあるでしょう. そのような場合は longtable = TRUE を使用できます. このオプションは LaTeX パッケージ longtable を使い表を複数ページに分割します. table 環境に含まれた場合, つまり表にキャプションを設定した場合は表はデフォルトで中央揃えになります. 表を中央揃えにしたくないなら, centering = FALSE 引数を使用してください. 10.1.11 HTML の表をカスタマイズする (*) knitr::kable(format = \"html\") で生成した表をカスタマイズしたいなら, 前節で紹介した共通の引数の他に, 1つだけ table.attr という特別な引数があります. この引数で任意の属性を &lt;table&gt; タグに追加することができます. 例えばこのように. knitr::kable(mtcars[1:2, 1:2], table.attr = &quot;class=\\&quot;striped\\&quot;&quot;, format = &quot;html&quot;) &lt;table class=&quot;striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; mpg &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; cyl &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 Wag &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 表に striped クラスを追加しています. しかしクラス名だけでは表の外見を変更するのに不十分です. クラスに対して CSS ルールを定義しなければなりません. 例えば偶数列と奇数列とで色の異なるストライプ背景の表を作るには, 明灰色の背景を偶数または奇数列に追加できます. .striped tr:nth-child(even) { background: #eee; } 上記の CSS ルールの意味は, striped クラスを持つ要素の子要素ですべての行（つまり &lt;tr&gt; タグ ）のうち行番号が偶数属性の (:nth-child(even)) 要素は, 背景色が #eee になるということです. 少しの CSS の記述だけでプレーンの HTML の表の見栄えをよくできます. 図10.1は, 以下の CSS ルールを適用した HTML 表のスクリーンショットです table { margin: auto; border-top: 1px solid #666; border-bottom: 1px solid #666; } table thead th { border-bottom: 1px solid #ddd; } th, td { padding: 5px; } thead, tfoot, tr:nth-child(even) { background: #eee; } 図 10.1: HTML と CSS で作成したストライプ背景の表 "],["kableextra.html", "10.2 kableExtra パッケージ", " 10.2 kableExtra パッケージ kableExtra package (Zhu 2021)は knitr::kable() (10.1節参照) を使用して作成した表の基本機能を拡張するために設計されました. knitr::kable() はシンプルな設計なので (これは Yihui が怠け者であるという意味にとるのはご随意に！), 他のパッケージで見られるような機能の多くが決定的に失われてしまっています. そして kableExtra はこのギャップを完全に埋めてくれます. kableExtra について最も驚異することは, 表のほとんどの機能, 例えば, 図10.1のようなストライプ背景の表をつくるなどが HTML でも PDF でも動作することです. このパッケージはいつものように CRAN からインストールできますし, GitHub (https://github.com/haozhu233/kableExtra) から開発版をインストールすることもできます. # install from CRAN install.packages(&quot;kableExtra&quot;) # install the development version remotes::install_github(&quot;haozhu233/kableExtra&quot;) 発展的なドキュメントが https://haozhu233.github.io/kableExtra/ にあり, kable() の出力を HTML や LaTeX 出力でどうカスタマイズするかについて多くの使用例が掲載されています. 我々としてはご自分でドキュメントを読むことをおすすめし, ここでは一部の例だけを提示します. kableExtra パッケージはパイプ演算子 %&gt;% を前面に出しています. kable() の出力に kableExtra のスタイル関数を接続することができます. 例えばこのように. library(knitr) library(kableExtra) kable(iris) %&gt;% kable_styling(latex_options = &quot;striped&quot;) 10.2.1 フォントサイズを設定する kableExtra パッケージの kable_styling() 関数によってテーブル全体のスタイルを設定できます. 例えばページ上での表のアラインメント, 幅, フォントサイズなどです. 以下は小さいフォントサイズを使う例です. kable(head(iris, 5), booktabs = TRUE) %&gt;% kable_styling(font_size = 8) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 10.2.2 特定の行・列のスタイルを設定する 関数 row_spec() と column_spec() はそれぞれ個別の行と列のスタイル設定に使うことができます. 以下の例では第1行をボールドイタリックにし, 第2, 第3行を黒色背景と白色文字にし, 第4行にアンダーラインを引きタイプフェースを変更し, 第5行を回転させ, そして第5列に打ち消し線を引きます. kable(head(iris, 5), align = &#39;c&#39;, booktabs = TRUE) %&gt;% row_spec(1, bold = TRUE, italic = TRUE) %&gt;% row_spec(2:3, color = &#39;white&#39;, background = &#39;black&#39;) %&gt;% row_spec(4, underline = TRUE, monospace = TRUE) %&gt;% row_spec(5, angle = 45) %&gt;% column_spec(5, strikeout = TRUE) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 同様に, cell_spec() 関数で個別のセルにスタイル設定できます. 10.2.3 行・列をグループ化する 行や列をそれぞれ, pack_rows() と add_header_above() 関数でまとめることができます. collapse_rows() 関数で行を崩し, セルを複数行にまたがらせることができます. 以下は行をグループ化したカスタムテーブルヘッダの例です. iris2 &lt;- iris[1:5, c(1, 3, 2, 4, 5)] names(iris2) &lt;- gsub(&#39;[.].+&#39;, &#39;&#39;, names(iris2)) kable(iris2, booktabs = TRUE) %&gt;% add_header_above(c(&quot;長さ&quot; = 2, &quot;幅&quot; = 2, &quot; &quot; = 1)) %&gt;% add_header_above(c(&quot;Measurements&quot; = 4, &quot;More attributes&quot; = 1)) Measurements More attributes 長さ 幅 Sepal Petal Sepal Petal Species 5.1 1.4 3.5 0.2 setosa 4.9 1.4 3.0 0.2 setosa 4.7 1.3 3.2 0.2 setosa 4.6 1.5 3.1 0.2 setosa 5.0 1.4 3.6 0.2 setosa add_header_above() 内の名前付きベクトルに対して, 名前がテーブルヘッダにテキストとして表示され, 整数値のベクトルが対応する名前の列の数を表します. 例えば \"Length\" = 2 が Length が2列にまたがることを意味します. 以下は pack_rows() の例です. index 引数の意味は既に説明した add_header_above() の引数と似ています. iris3 &lt;- iris[c(1:2, 51:54, 101:103), ] kable(iris3[, 1:4], booktabs = TRUE) %&gt;% pack_rows( index = c(&quot;setosa&quot; = 2, &quot;versicolor&quot; = 4, &quot;virginica&quot; = 3) ) Sepal.Length Sepal.Width Petal.Length Petal.Width setosa 1 5.1 3.5 1.4 0.2 2 4.9 3.0 1.4 0.2 versicolor 51 7.0 3.2 4.7 1.4 52 6.4 3.2 4.5 1.5 53 6.9 3.1 4.9 1.5 54 5.5 2.3 4.0 1.3 virginica 101 6.3 3.3 6.0 2.5 102 5.8 2.7 5.1 1.9 103 7.1 3.0 5.9 2.1 10.2.4 LaTeX で表を縮小する HTML や LaTeX 出力特有の機能もいくつかあります. 例えば横向きページは LaTeX でのみ意味をなすので, kableExtra の landscape() 関数は LaTeX でのみ機能します. 以下はページに合わせて表を縮小する例です. 縮小しなければ横に長すぎる表になります. tab &lt;- kable(tail(mtcars, 5), booktabs = TRUE) tab # 長すぎる元の表 mpg cyl disp hp drat wt qsec vs am gear carb Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 tab %&gt;% kable_styling(latex_options = &quot;scale_down&quot;) mpg cyl disp hp drat wt qsec vs am gear carb Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 HTML 版をご覧なら, 上の2つの表に違いが見られないでしょう. 参考文献 "],["table-other.html", "10.3 その他の表作成パッケージ", " 10.3 その他の表作成パッケージ 多くの作表用 R パッケージがあります. kable() (10.1節) とkableExtra (10.2節) を紹介した)主な理由は他のパッケージより良いからではなく, 私がこれらにのみ詳しかったからです.34 存在は知っていますがあまり詳しくないパッケージを次に列挙します.35 ご自分で確認し, 目的に最も合っているものを決めることができます. flextable (Gohel 2021a) と huxtable (Hugh-Jones 2021): 幅広い種類の出力フォーマットをサポートするパッケージを探しているなら, flextable と huxtable が最善の2つの選択です. HTML, LaTeX. そして Office フォーマットを全てサポートし, よく使われる表の機能 (例えば条件付き書式とか) のほとんどをサポートしています. flextable の詳細は https://davidgohel.github.io/flextable/ で, huxtable のドキュメントは https://hughjonesd.github.io/huxtable/ で見られます. gt (Iannone, Cheng, and Schloerke 2021): 表のヘッダ, (題名・副題), 列のラベル, 表の本体, 行グループのラベル, 表のフッタといった異なる表のパーツをまとめて表を構成することができます. 数字のフォーマットを指定したり, セルの背景色に影をつけたりもできます. 現在は gt は主に HTML 出力をサポートしています.36 詳細は https://gt.rstudio.com で見られます. formattable (Ren and Russell 2021): percent(), accounting() といった数値を整形するものや, テキストの書式, 背景色やカラーバー, アイコンの追加などで数値を強調するなど, 表の列のスタイルを設定する関数を提供してくれます. gt のように, このパッケージも主に HTML フォーマットをサポートしています. 詳細は GitHub プロジェクトの https://github.com/renkun-ken/formattable で見ることができます. DT (Xie, Cheng, and Tan 2021): 作者なのでこのパッケージには精通していると思っていますが, HTML フォーマットのみのサポートのため独立した節を設けて紹介したりはしません. DT は JavaScript ライブラリの DataTables を下地に構築されたもので, HTML ページ上で静的な表をインタラクティブな表に変えることができます. 表をソートしたり, 検索したり, ページ移動したりできるでしょう. DT はセルの整形もサポートしており, インタラクティブなアプリケーションの構築のため Shiny と連携して動作し, 多くの DataTables の拡張を導入します. 例えばエクセルへのエクスポート, 列の並び替えなどです. 詳細はパッケージのリポジトリ https://github.com/rstudio/DT を見てください. reactable (Lin 2020): DT と同様にこのパッケージは JavaScript ライブラリを元にしてインタラクティブな表を作成します. 正直に言うと, 私が見る限り, 行のグループ化や HTML ウィジェットの埋め込み機能などいくつかの観点で DT より優れているようです. もし reactable が 2015年時点で存在していれば, 私は DT を開発していなかったと思います. とは言うものの, reactable はDT にあるすべての機能を揃えていません. よってあなたはこのパッケージのドキュメント https://glin.github.io/reactable/ を読み, どちらが目的に合ったものかを知ることもできるでしょう. rhandsontable (Owen 2021): これも DT と似ており, そして表上でデータを直接編集できるなど Excel っぽさがあります. 詳しく学ぶには https://jrowen.github.io/rhandsontable/ を見てください. pixiedust (Nutter 2021): broom パッケージ (Robinson, Hayes, and Couch 2021) を介した統計モデル (線形モデルとか) 向けの表を作るのが特徴です. Markdown, HTML, LaTeX 出力フォーマットをサポートしています. リポジトリは https://github.com/nutterb/pixiedust です. stargazer (Hlavac 2018): 回帰モデルと要約統計量の表を整形するのが特徴です. このパッケージは CRAN の https://cran.r-project.org/package=stargazer にあります. xtable (Dahl et al. 2019): おそらく最古の作表パッケージです. 最初のリリースは2000年になります. LaTeX と HTML フォーマットの両方をサポートしています. パッケージは CRAN の https://cran.r-project.org/package=xtable にあります. その他のパッケージは紹介しませんが, 名前だけ挙げておきます. tables (Murdoch 2020), pander (Daróczi and Tsegelskyi 2021), tangram (Garbett 2020), ztable (Moon 2020), condformat (Oller Moreno 2020) があります. 参考文献 "],["chunk-options.html", "11 チャンクオプション", " 11 チャンクオプション 図2.1に描かれているように, knitr パッケージは R Markdown においてきわめて重要な役割を担います. この章と後に続くの3つの章では knitr に関連するレシピをお見せします. R のチャンクを処理する際には, knitr の挙動を細かく調整するのに 50 を超すチャンクオプション (chunk options) が使えます. 完全なリストは https://yihui.org/knitr/options/ のオンラインドキュメントをご覧ください.37 このあと続く各節では, チャンクオプションを個別のコードチャンクに適用する例のみを示します. ただし, どのチャンクオプションもグローバル設定で文書全体に適用できるので, コードチャンク1つ1つに繰り返しオプションを書かなくても良いということも知っておいてください. グローバルにチャンクオプションを設定するには, いずれかのコードチャンクで knitr::opts_chunk$set() を呼び出してください. ふつうは文書の最初のチャンクオプションに設定します. 例えばこのように. ```{r, include=FALSE} knitr::opts_chunk$set( comment = &quot;#&gt;&quot;, echo = FALSE, fig.width = 6 ) ``` 訳注: 翻訳者による日本語訳はこちら: https://gedevan-aleksizde.github.io/knitr-doc-ja/options.html↩︎ "],["chunk-variable.html", "11.1 チャンクオプションに変数を使う", " 11.1 チャンクオプションに変数を使う 大抵の場合, 例えば fig.width = 6 のようにチャンクオプションは定数をとりますが, 簡単であるか複雑であるかに関わらず, 任意の R コードからの値をとることもできます. 特殊なケースはチャンクオプションに通せる変数です. 変数もまた R コードであることに注意してください. 例えば文書の冒頭で図の幅を変数で定義して, その変数を後の他のコードチャンクで使えば, それ以降の幅を簡単に変更できます. ```{r} my_width &lt;- 7 ``` ```{r, fig.width=my_width} plot(cars) ``` 以下はチャンクオプショで if-else 文を使う例です. ```{r} fig_small &lt;- FALSE # 大きい図に対しては TRUE に変更 width_small &lt;- 4 width_large &lt;- 8 ``` ```{r, fig.width=if (fig_small) width_small else width_large} plot(cars) ``` さらに以下にもう1つの例として, 必要なパッケージが使用可能な場合のみコードチャンクを評価する (つまり実行する) ものを示します. ```{r, eval=require(&#39;leaflet&#39;)} library(leaflet) leaflet() %&gt;% addTiles() ``` 意図が分からない方のために説明しますと, require('package') はパッケージが使用可能なら TRUE を返し, そうでないなら FALSE を返します. "],["opts-error.html", "11.2 エラーが起こっても中止しない", " 11.2 エラーが起こっても中止しない 時として, 例えば R のチュートリアルのために, わざとエラーを見せたいこともあるかもしれません. デフォルトでは, Rmd 文書のコードチャンクでのエラーは R の処理を停止させます. R の処理を停めることなくエラーを見せたいなら, 例えばこのように error = TRUE チャンクオプションを使うこともできます. ```{r, error=TRUE} 1 + &quot;a&quot; ``` Rmd 文書をコンパイルすると, 出力文書上でのエラーメッセージはこのような見た目になります. Error in 1 + &quot;a&quot;: 二項演算子の引数が数値ではありません R Markdown では error = FALSE がデフォルトであり, これはコードチャンクの実行時のエラーは処理を停止させます. "],["dev-vector.html", "11.3 同じグラフを複数の出力フォーマットに", " 11.3 同じグラフを複数の出力フォーマットに ほとんどの場合, 1つの図に対して png や pdf といった1つの画像フォーマットにしたいでしょう. 画像フォーマットはチャンクオプション dev で操作できます. つまり, グラフをレンダリングするグラフィックデバイスを意味します. このオプションはデバイス名のベクトルをとることができます. これが例です. ```{r, dev=c(&#39;png&#39;, &#39;pdf&#39;, &#39;svg&#39;, &#39;tiff&#39;)} plot(cars) ``` 出力文書には最初のフォーマットのみが使われますが, 残りのフォーマットに対応する画像も生成されます. 例えば, レポートでは png 画像を掲載するが, 同じ画像の tiff 形式も求められるときなど, 追加で異なるフォーマットの図の提出が要求されるような場合に便利でしょう. デフォルトでは, 通常なら画像ファイルは出力文書がレンダリングされた後に削除されます. ファイルを保持する方法は16.5節を参照してください. "],["cache.html", "11.4 時間のかかるチャンクをキャッシュする", " 11.4 時間のかかるチャンクをキャッシュする コードチャンクの実行に時間がかかる場合, チャンクオプション cache = TRUE で結果をキャッシュすることを検討するとよいでしょう. キャッシュが有効な場合, このコードが以前にも実行され, その後コードに変更がないならば, knitr はこの実行を飛ばします. コードチャンクを変更し, つまりコードまたはチャンクオプションを修正したなら, 過去のキャッシュは自動的に無効になり knitr はもう一度チャンクをキャッシュします. キャッシュされたコードチャンクに関しては, チャンクが再度実行されたかのように, 過去の実行結果から出力とオブジェクトが自動的に読み込まれます. キャッシュを読み込むほうが結果を計算するよりはるかに速いという場合に役に立ちます. しかしながら, うまい話というのは世に存在しません. あなたの使う場面によっては, キャッシュがどのように動作するかをより学びぶ必要があるでしょう. 特に cache invalidation を学べば, knitrがしょっちゅうキャッシュを無効化したり, あるいは時に無効化が十分しないことに振り回されることなく, キャッシュの利点を最大限活かすことができます. 最も適切なキャッシュの使用例は, コードチャンク内での計算に非常に時間がかかる R オブジェクトの保存と再読込に使うことですが, コードが options() を使って R のグローバルオプションを変更するといった副産物 (このような変更はキャッシュされません) があってはなりません. コードチャンクに副産物があるなら, キャッシュを使わないことをお薦めします. 最初のほうで簡単に書いたように, キャッシュの動きはチャンクオプションに依存します. もし include 以外のチャンクオプションを変更したら, キャッシュは無効化されます. この仕様はよくある問題を解決してくれます. それは外部データファイルを読み込むときに, ファイルが更新されていたならキャッシュを無効化したい, というような場合です. 単純に cache = TRUE を使うだけでは不十分です. ```{r import-data, cache=TRUE} d &lt;- read.csv(&#39;my-precious.csv&#39;) ``` knitr にデータファイルが変更されたかどうかを教えなければなりません. 1つの方法としては別のチャンクオプション cache.extra = file.mtime('my-precious.csv') を加えることですが, あるいはより厳密には cache.extra = tools::md5sum('my-precious.csv') を追加することがあります. 前者はファイルの更新時刻が変更されたらキャッシュを無効化する, という意味です. 後者はファイルの中身が変更されたらキャッシュを更新するということです. cache.extra は knitr の組み込みのチャンクオプション名ではないということに注意してください. 他の組み込みのオプション名と競合しない限り, この用途のオプションには好きな名前を使うことができます. 同様に, 他の情報をキャッシュと関連付けることができます. 例えば R のバージョンなら cache.extra = getRversion(), システム日付なら cache.extra = Sys.Date(), オペレーティングシステムなら cache.extra = Sys.info()[['sysname']] というようにすると, これらの条件が変更されたときにキャッシュは正しく無効化されます. 文書全体で cache = TRUE を設定することはお薦めしません. キャッシュはかなり扱いにくいものです. 代わりに, 実行に時間がかかり副産物がないとはっきりしているコードチャンクに限って, 個別にキャッシュを有効化することをお薦めします. knitr のキャッシュの設計に不満があるなら, 自分でオブジェクトのキャッシュを取ることもできます. 以下はごく簡単な例です. if (file.exists(&quot;results.rds&quot;)) { res &lt;- readRDS(&quot;results.rds&quot;) } else { res &lt;- compute_it() # 実行時間のかかる関数 saveRDS(res, &quot;results.rds&quot;) } この例では, キャッシュを無効化する唯一の, そして簡単な方法は result.rds ファイルを削除することです. この簡単なキャッシュのしくみが気に入ったなら, 14.9節で紹介する xfun::cache_rds() を使うこともできます. "],["cache-path.html", "11.5 複数の出力フォーマットに対してチャンクをキャッシュする", " 11.5 複数の出力フォーマットに対してチャンクをキャッシュする cache = TRUE でキャッシュが有効化されたとき, knitr は R コードチャンクで生成された R オブジェクトをキャッシュデータベースに書き込みます. これで次回から再読込ができます. キャッシュデータベースのパスはチャンクオプション cache.path によって決まります. R Markdown はデフォルトで出力フォーマットごとに異なるキャッシュのパスを使用するので, 時間のかかるコードチャンクは出力フォーマットごとに丸ごと実行されることになります. これは不便かもしれませんが, これがデフォルトの挙動であることには理由があります. コードチャンクの出力を, 固有の出力フォーマットによって決められるからです. 例えばグラフを生成した時, 出力フォーマットが word_document なら ![text](path/to/image.png) のような Markdown 構文で図を掲載できますし, 出力フォーマットが html_document なら &lt;img src=\"path/to/image.png\" /&gt; が使えます. コードチャンクにグラフなど副産物が一切ないときは, 全ての出力フォーマットで同じキャッシュデータベースを使っても安全であり, 時間を節約できます. 例えば大きなデータオブジェクトを読み込むか時間のかかるモデルを実行するかというときは, 結果は出力フォーマットに依存しませんので, 同じキャッシュデータベースを使うことができます. コードチャンクに cache.path を指定することでデータベースのパスを指定できます. これが例です. ```{r important-computing, cache=TRUE, cache.path=&quot;cache/&quot;} ``` R Markdown ではデフォルトでは cache.path = \"INPUT_cache/FORMAT/\" で, INPUT には入力ファイル名が, FORMAT には html, latex, docx といった出力フォーマット名が入ります. "],["cache-lazy.html", "11.6 巨大オブジェクトをキャッシュする", " 11.6 巨大オブジェクトをキャッシュする チャンクオプション cache = TRUE を使うと, キャッシュされたオブジェクトは R セッション内で遅延読み込みされます. これはオブジェクトが実際にコード内で使用されるまでキャッシュデータベースから読み込まれないことを意味します. このおかげで, 以降の文書内で全てのオブジェクトが使われるわけではない場合にメモリを多少節約することができます. 例えば大きなデータオブジェクトを読み込んだが, 以降の分析ではその一部しか使わないなら, 元のデータオブジェクトはキャッシュデータベースから読み込まれません. ```{r, read-data, cache=TRUE} full &lt;- read.csv(&quot;HUGE.csv&quot;) rows &lt;- subset(full, price &gt; 100) # next we only use `rows` ``` ```{r} plot(rows) ``` しかし, オブジェクトが大きすぎるときは, このようなエラーに遭遇するかもしれません. Error in lazyLoadDBinsertVariable(vars[i], ... long vectors not supported yet: ... Execution halted この問題が発生したら, チャンクオプション cache.lazy = FALSE で遅延読み込みを無効にしてみてください. チャンク内の全てのオブジェクトが即座にメモリに読み込まれるでしょう. "],["hide-one.html", "11.7 コード, テキスト出力, メッセージ, グラフを隠す", " 11.7 コード, テキスト出力, メッセージ, グラフを隠す デフォルトでは, knitr はコードチャンクから, ソースコード・テキスト出力・メッセージ・警告・エラー・グラフといった可能な全ての出力を表示します. 個別に対応するコードチャンクを使って, 隠すことができます. ソースコードを隠す. ```{r, echo=FALSE} 1 + 1 ``` テキスト出力を隠す. `results = FALSE` を使うのも可. ```{r, results=&#39;hide&#39;} print(&quot;テキスト出力はあなたには見えない.&quot;) ``` メッセージを隠す. ```{r, message=FALSE} message(&quot;このメッセージはあなたには見えない.&quot;) ``` 警告メッセージを隠す. ```{r, warning=FALSE} # 警告を発生させるが抑制される 1:2 + 1:3 ``` グラフを隠す. ```{r, fig.show=&#39;hide&#39;} plot(cars) ``` 上記のチャンクではグラフが生成されることに注意してください. 出力に表示しなくするだけです. knitr に関するよくある質問の1つは, パッケージ読み込み時のメッセージを隠す方法です. 例えば library(tidyverse) や library(ggplot2) を使ったとき, いくつかの読み込みメッセージが現れます. このようなメッセージはチャンクオプション message = FALSE で抑制することもできます. インデックスによってこれらの要素を表示したり隠したり選択することも出来ます. 以下の例では, ソースコードの4つ目と5つ目の式を表示し, 最初の2つのメッセージと2つ目と3つ目の警告を隠しています. コメントも式1つとして数えられることに注意してください. ```{r, echo=c(4, 5), message=c(1, 2), warning=2:3} # 乱数 N(0, 1) を生成する方法の1つ x &lt;- qnorm(runif(10)) # だが rnorm() を使うほうが実用的 x &lt;- rnorm(10) x for (i in 1:5) message(&#39;ここにメッセージ &#39;, i) for (i in 1:5) warning(&#39;ここにメッセージ &#39;, i) ``` 負のインデックスを使用することもできます. 例えば echo = -2 は出力部のソースコードの2つ目の式を除外します. 同様に, fig.keep オプションに対してインデックスを使うことでどのグラフを表示あるいは隠すかを選ぶこともできます. 例えば fig.keep = 1:2 は最初の2つのグラフを残すことを意味します. このオプションにはいくつかのショートカットがあります. fig.keep = \"first\" は最初のグラフのみを残し, fig.keep = \"last\" は最後のグラフのみを残し, fig.keep = \"none\" は全てのグラフを破棄します. 2つのオプション fig.keep = \"none\" と fig.show = \"hide\" は異なることに注意してください. 前者はそもそも画像ファイルを生成しませんが, 後者はグラフを生成し隠すだけです. html_document 出力のソースコードブロックに対して, echo = FALSE で完全に省略したくなければ, 7.5節をご覧になれば, ページ上でブロックを折りたたみ, ユーザーが展開ボタンを押して展開させるようにする方法が書いてあります. "],["hide-all.html", "11.8 チャンクの出力を全て隠す", " 11.8 チャンクの出力を全て隠す ときには出力を全く表示させずにコードチャンクを実行したいかもしれません. 11.7節で言及したような方法で個別にオプションを使うのではなく, ただ1つ include = FALSE を使うことで出力全体を抑制できます. これが例です. ```{r, include=FALSE} # ここに何らかの R コード ``` include=FALSE オプションがあると, eval = FALSE の指定がない限りコードチャンクは評価されますが, 出力は完全に抑制されます. コードも, テキスト出力も, メッセージもグラフも見えなくなります. "],["opts-collapse.html", "11.9 テキスト出力をソースコードとまとめる", " 11.9 テキスト出力をソースコードとまとめる テキスト出力ブロックとソースコードブロックの間隔が空きすぎていると感じたら, チャンクオプション collapse = TRUE でテキスト出力をソースブロックと連結することを検討するとよいでしょう. collapse = TRUE としたとき, 出力はこのようになります. 1 + 1 ## [1] 2 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 以下は同じチャンクですが collapse = TRUE オプションがありません. デフォルトは FALSE です. 1 + 1 ## [1] 2 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 "],["opts-tidy.html", "11.10 R のソースコードを整形する", " 11.10 R のソースコードを整形する チャンクオプション tidy = TRUE を設定すると, formatR パッケージ (Xie 2021b) の tidy_source() 関数によって R のソースコードが整形されます. tidy_source() 関数は, ほとんどの演算子の前後にスペースを追加する, 適切なインデントをする, 代入演算子 = を &lt;- に置き換えるなど, いくつかの観点でソースコードを整形します. チャンクオプション tidy.opts には formatR::tidy_source() に与えられる引数のリストが使えます. これが例です. ```{r, tidy=TRUE, tidy.opts=list(arrow=TRUE, indent=2)} # 乱雑な R コード... 1+ 1 x=1:10#代入演算子として &#39;&lt;-&#39; を好むユーザーがいる if(TRUE){ print(&#39;Hello world!&#39;) # スペース2個でインデントする } ``` 整形後の出力はこうなります. # 乱雑な R コード... 1 + 1 x &lt;- 1:10 #代入演算子として &#39;&lt;-&#39; を好むユーザーがいる if (TRUE) { print(&quot;Hello world!&quot;) # スペース2個でインデントする } 5.3節ではテキストの幅を制御する方法について言及しました. ソースコードの幅を制御したいなら, tidy = TRUE としたときに width.cutoff 引数を試してください. これが例です. ```{r, tidy=TRUE, tidy.opts=list(width.cutoff=50)} # 長い式 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+ 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1 ``` 出力はこうなります. # 長い式 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 使用可能な引数を知るにはヘルプページ ?formatR::tidy_source を読んでください. そして https://yihui.org/formatR/ で使用例とこの関数の限界を理解してください. tidy = styler を設定したなら, コード整形には代わりに styler パッケージ (Müller and Walthert 2021) が使われます. R コードは styler::style_text() 関数で整形されます. styler パッケージは formatR よりも豊富な機能を持ちます. 例えば, 引数のアラインメントができたりパイプ演算子 %&gt;% のあるコードも対処できたりします. チャンクオプション tidy.opts は styler::style_text() へ引数を渡して使うこともできます. これが例です. ```{r, tidy=&#39;styler&#39;, tidy.opts=list(strict=FALSE)} # 代入演算子のアラインメント a &lt;- 1#one variable abc &lt;- 2#another variable ``` デフォルトでは tidy = FALSE であり, あなたのコードは整形されません. 参考文献 "],["results-asis.html", "11.11 テキストを生の Markdown として出力する (*)", " 11.11 テキストを生の Markdown として出力する (*) デフォルトではコードチャンクからのテキスト出力は冒頭に2つハッシュを置いて, テキストをそのまま書き出します (11.12節参照). knitr は出力をコードブロックで囲むため, テキストはそのまま表示されます. 例えば 1:5 というコードの生の出力はこうなります. ``` ## [1] 1 2 3 4 5 ``` 時には生のテキストをそのまま出力するのではなく, Markdown 構文として扱いたいこともあるでしょう. 例えば cat('# これは見出しです') でセクション見出しを書きたい時があるかもしれませんが, 生の出力はこうなります. ``` ## # これは見出しです ``` テキストをコードブロックで囲んでほしくない, あるいは冒頭のハッシュもいらない. つまり, 生の出力が cat() に与えた文字列そのままになるようにしたい, というわけです. # This is a header これを解決するのはチャンクオプション results = 'asis' です. このオプションは テキスト出力をコードブロックで囲むのではなく, “as is” (そのまま) 扱うよう knitr に指示します. R コードから動的にコンテンツを生成したい時に, このオプションは特に有用でしょう. 例えば以下のコードチャンクと results = 'asis' オプションで, iris データから列名のリストを生成します. cat(paste0(&quot;- `&quot;, names(iris), &quot;`&quot;), sep = &quot;\\n&quot;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species ハイフン (-) は番号のない箇条書き意味する Markdown 構文です. バッククォートはオプションです. results = 'asis' オプションなしで上記のコードチャンクがそのまま出力されるのを見ることもできます. cat(paste0(&quot;- `&quot;, names(iris), &quot;`&quot;), sep = &quot;\\n&quot;) - `Sepal.Length` - `Sepal.Width` - `Petal.Length` - `Petal.Width` - `Species` 以下は, セクション見出し, パラグラフ, mtcars データの全ての列に対してfor ループ内で作成したグラフを表示する例の全貌です --- title: プログラミングでコンテンツを生成する --- チャンクオプション `results = &#39;asis&#39;` で生の Markdown コンテンツを書き出すことができます. これはプロットを含めることもできます. ```{r, mtcars-plots, results=&#39;asis&#39;} for (i in names(mtcars)) { cat(&#39;\\n\\n# 変数 `&#39;, i, &#39;` の要約.\\n\\n&#39;) x &lt;- mtcars[, i] if (length(unique(x)) &lt;= 6) { cat(&#39;`&#39;, i, &#39;` はカテゴリカル変数である.\\n\\n&#39;) plot(table(x), xlab = i, ylab = &#39;度数&#39;, lwd = 10) } else { cat(&#39;連続変数 `&#39;, i, &#39;` のヒストグラム.\\n\\n&#39;) hist(x, xlab = i, main = &#39;&#39;) } } ``` 改行 (\\n) を過剰に追加していることに注意してください. これは Markdown コンテンツ上でそれぞれの要素を明確に分離したいからです. 要素間の改行は多すぎても無害ですが, 改行が不十分だと問題が起こりえます. 例えば以下の Markdown テキストには大いに曖昧さがあります. # これは見出し? これは段落?ヘッダの一部? ![この画像は?](foo.png) # この行はどうなる? cat('\\n') で生成できていたように空白行を追加すると, この曖昧さは消えます. # そうこれは見出し! そしてこれは明らかに段落. ![これは画像](foo.png) # 完全なる別の見出し cat() だけがテキスト出力のできる関数ではありません. 他のよく使われる関数には print() があります. print() はしばしばオブジェクトの表示のために暗黙に呼び出されることに注意してください. これが R コンソールでオブジェクトや値をタイプした直後に出力が表示される理由です. 例えば R コンソールで 1:5 とタイプし Enter キーを押した時, R が実際には print(1:5) を暗黙に呼び出しているので出力が見えます. R コンソール上で入力していれば正常に表示されていたはずのオブジェクトや値が for ループなどのコード内では出力の生成に失敗するというのはとても混乱をもたらします. この話はかなり技術的に高度なので, 私はブログに “The Ghost Printer behind Top-level R Expressions” という説明の記事を投稿しました. 技術的な詳細に関心がないなら, このルールだけは覚えてください. 「for ループ内の出力が表示されなかったら, おそらく print() 関数で明示的に表示させるべきです」 "],["opts-comment.html", "11.12 テキストの先頭のハッシュ記号を消す", " 11.12 テキストの先頭のハッシュ記号を消す デフォルトでは R コードのテキスト出力の先頭には 2つのハッシュ記号 ## が付きます. この挙動はチャンクオプション comment で変更することができます. このオプションのデフォルトは \"###\" という文字列です. ハッシュを消したいなら, 空の文字列を使うことができます. これが例です. ```{r, comment=&quot;&quot;} 1:100 ``` もちろん, comment = \"#&gt;\" などと他の文字列はなんでも使うことができます. なぜ comment オプションのデフォルトはハッシュ記号なのか? その理由は # が R ではコメントを意味するからです. テキスト出力がコメントアウトされていれば, レポートに掲載されたコードチャンクを全部まとめてコピーして自分で実行するのが簡単になり, テキスト出力が R コードとして扱われないということに悩むことがありません. 例えば以下のコードチャンクの4つの行のテキスト全てをコピーして, R コードとして安全に実行することができます. 1 + 1 ## [1] 2 2 + 2 ## [1] 4 comment = \"\" でハッシュ記号を消したなら, 2つ目と2つ目のコードを手動で消さなければならないため, 全てのコードをコピーして簡単に実行するということができなくなります. 1 + 1 [1] 2 2 + 2 [1] 4 comment = \"\" が好ましいという主張の1つには, テキスト出力が R コンソールのユーザーにとって見慣れたものになるという点です. R コンソールではテキスト出力の行の先頭にはハッシュ記号が現れません. 本当に R コンソールの挙動を模倣したいのであれば, comment = \"\" を prompt = TRUE と組み合わせて使うことができます. これが例です. ```{r, comment=&quot;&quot;, prompt=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` ソースコードにプロンプト記号 &gt; と行の継続を表す記号 + が含まれているので, 出力は R コードをタイプして実行するときのものにかなり近づいているはずです. &gt; 1 + 1 [1] 2 &gt; if (TRUE) { + 2 + 2 + } [1] 4 "],["attr-output.html", "11.13 テキスト出力ブロックに属性を与える (*)", " 11.13 テキスト出力ブロックに属性を与える (*) 7.3節では, class.source と class.output を使い, ソース・テキスト出力のブロックにスタイルを定義する例をいくつかお見せしました. 実際には knitr には同様の様々なオプションがあります. それらは class.message, class.warning, class.error といったものです. これらのオプションはクラス名を対応するテキスト出力ブロックに追加するために使うことができます. 例えば class.error はチャンクオプション error = TRUE (11.2節参照) が設定されているとき, エラーメッセージに対してクラスを追加します. これらのオプションがもっともよく使われるのは, クラス名に対応して定義された CSS ルールで出力にスタイルを適用するときでしょう. この例の実演は7.3節でなされています. 典型的には, テキスト出力ブロックは最低限コードブロックに囲まれており, Markdown のソースはこのようになります. ```{.className} 出力された行 ``` 出力フォーマットが HTML ならば, たいていの場合で38このように変換されます. &lt;pre class=&quot;className&quot;&gt; &lt;code&gt;出力された行&lt;/code&gt; &lt;/pre&gt; class.* オプションは &lt;pre&gt; 要素の class 属性を制御します. この要素は先述のテキスト出力ブロックを入れたコンテナです. 実際には, クラスは HTML の &lt;pre&gt; 要素の属性に使用可能なものの1つにすぎません. HTML 要素は幅や高さやスタイルなどと, 他にも多くの属性を持ちます. attr.source, attr.output, attr.message, attr.warning, attr.error を含む一連のチャンクオプション attr.* によって, 任意の属性をテキスト出力ブロックに追加することができます. 例えば attr.source = 'style=\"background: pink;\"' を使えばソースブロックの背景をピンク色にできます. 対応するコードブロックはこのようになります. ```{style=&quot;background: pink;&quot;} ... ``` そして HTML 出力はこのようになります. &lt;pre style=&quot;background: pink;&quot;&gt; ... &lt;/pre&gt; 5.7, 12.3節でさらなる例を見ることができます. 技術的なことをいいますと, チャンクオプション class.* は attr.* の特殊形です. 例えば class.source = 'numberLines' は attr.source = '.numberLines' と同じです (後者は先頭にドットがあることに注意). しかし attr.source は任意の属性をとることができ, 例えば attr.source = c('.numberLines', 'startFrom=\"11\"') も可能です. これらのオプションはほとんどの HTML 出力で有効です. 属性が他の出力フォーマットでも有効な場合もありますが, そのような場合になるのは比較的珍しいです. 属性は Pandoc か, 何らかのサードパーティ製パッケージ のいずれかでサポートされている必要があります. .numberLines 属性は Pandoc によって HTML と LaTeX の両方で動作し, サードパーティ製パッケージというのは大抵は4.20節で紹介したような Lua フィルターを使ったものになります. &lt;div class=\"className\"&gt;&lt;/div&gt; に変換される場合もあります. 万全を期すには HTML 出力された文書を確認することもできます.↩︎ "],["fig-process.html", "11.14 グラフに後処理をかける (*)", " 11.14 グラフに後処理をかける (*) コードチャンクでグラフが生成された後, チャンクオプション fig.process によってグラフに後処理をかけることが出来ます. これはファイルパスを引数にとり, 生成された画像ファイルのパスを返す関数であるべきです. この関数はオプションで第2引数 option を取ることができ, これには現在のチャンクのオプションのリストが与えられます. R のロゴをグラフに埋め込むために, とても強力な magick パッケージ (Ooms 2021b) を使用する例を以下にお見せします. このパッケージに詳しくないなら, オンラインドキュメントか, 豊富な使用例を含むパッケージのヴィネットをを読むことをお薦めします. 初めに, 関数 add_logo() を定義します. add_logo &lt;- function(path, options) { # コードチャンクで作成された画像 img &lt;- magick::image_read(path) # R のロゴ logo &lt;- file.path(R.home(&quot;doc&quot;), &quot;html&quot;, &quot;logo.jpg&quot;) logo &lt;- magick::image_read(logo) # デフォルトの重心は `northwest` (左上) で, # ユーザーはチャンクオプション `magick.gravity` # で変更できる if (is.null(g &lt;- options$magick.gravity)) g &lt;- &quot;northwest&quot; # ロゴを画像に追加する img &lt;- magick::image_composite(img, logo, gravity = g) # 新しい画像を書き出す magick::image_write(img, path) path } 基本的にこの関数は R のグラフのパスをとり, R のロゴを追加し, 元画像のパスに新しい画像を保存します. デフォルトでは, ロゴはグラフの左上 (northwest) の隅に追加されますが, ユーザーはカスタムチャンクオプション magick.gravity で位置をカスタマイズできます. このオプション名は任意に決められます. では上記の処理関数を fig.process = add_logo と magick.gravity = \"northwest\" オプションで以下のコードチャンクに適用します. よってロゴは右上の隅に追加されます. 実際の出力は図11.1になります. par(mar = c(4, 4, 0.1, 0.1)) hist(faithful$eruptions, breaks = 30, main = &quot;&quot;, col = &quot;gray&quot;, border = &quot;white&quot;) 図 11.1: チャンクオプション fig.process でグラフに R のロゴを追加する あなたが magick パッケージにより詳しくなったら, R のグラフに後処理をするための, より創造的で有用なアイディアを思いつくことでしょう. 最後に, fig.process オプションのもう1つの応用例をお見せします. 以下の pdf2png() 関数は PDF 画像を PNG に変換します. 第11.15節ではグラフの生成のために tikz グラフィックデバイスを使用する例を見せました. この方法の問題は, デバイスが PDF を生成するため, LaTeX 以外の出力文書に対しては機能しないということです. チャンクオプション dev = \"tikz\" と fig.process = pdf2png を使えば, グラフの PNG 版を図11.2に示すことができます. pdf2png &lt;- function(path) { # LaTeX でない出力に対してのみ変換する if (knitr::is_latex_output()) return(path) path2 &lt;- xfun::with_ext(path, &quot;png&quot;) img &lt;- magick::image_read_pdf(path) magick::image_write(img, path2, format = &quot;png&quot;) path2 } 参考文献 "],["graphical-device.html", "11.15 高品質なグラフィック (*)", " 11.15 高品質なグラフィック (*) rmarkdown パッケージはそれぞれの出力フォーマットに対して妥当なデフォルトのグラフィックデバイスを設定しています. 例えば HTML 出力に対しては png() を使うので, knitr は PNG 画像ファイルを生成し, PDF 出力に対しては pdf() デバイスを使う, などです. あなたがデフォルトのグラフィックデバイスの品質に不満なら, チャンクオプション dev によって変更することができます. knitr によってサポートされているグラフィックデバイスの一覧は次のようになります. \"bmp\", \"postscript\", \"pdf\", \"png\", \"svg\", \"jpeg\", \"pictex\", \"tiff\", \"win.metafile\", \"cairo_pdf\", \"cairo_ps\", \"quartz_pdf\", \"quartz_png\", \"quartz_jpeg\", \"quartz_tiff\", \"quartz_gif\", \"quartz_psd\", \"quartz_bmp\", \"CairoJPEG\", \"CairoPNG\", \"CairoPS\", \"CairoPDF\", \"CairoSVG\", \"CairoTIFF\", \"Cairo_pdf\", \"Cairo_png\", \"Cairo_ps\", \"Cairo_svg\", \"svglite\", \"ragg_png\", \"tikz\" 大抵の場合, グラフィックデバイスの名前は関数名でもあります. デバイスについてもっと詳しく知りたいなら, あなたは R のヘルプページを読むことができます. 例えば R コンソールで ?svg と打てば svg デバイスの詳細を知ることができます. このデバイスは base R に含まれています. さらに quartz_XXX デバイスは quartz() 関数を元にしたもので, macOS でのみ有効です. CairoXXX デバイスは Cairo (Urbanek and Horner 2020) パッケージによるアドオンで, Cairo_XXX デバイスは cairoDevice package (Lawrence 2020) から39, svglite デバイスは svglite パッケージ (Wickham, Henry, et al. 2021) から, tikz は tikzDevice パッケージ (Sharpsteen and Bracken 2020) からのデバイスです. アドオンパッケージ由来のデバイスを使いたいなら, そのパッケージをまずインストールしなければなりません. 大抵はベクタ画像はラスタ画像よりも高品質であり, ベクタ画像は品質を損なうことなく縮尺を変更できます. HTML 出力では, SVG のグラフのために dev = \"svg\" または dev = \"svglite\" を使うことを検討してください. SVG はベクタ画像形式で, デフォルトの png デバイスはラスタ画像形式であることに注意してください. あなたが PDF 出力時のグラフ内の書体に対してこだわりが強い人なら, dev = \"tikz\" を使うこともできます. これは LaTeX がネイティヴでサポートしているからです. つまり, テキストや記号を含むグラフの全ての要素が LaTeX を介して高品質にレンダリングされるということです. 図11.2に, dev = \"tikz\" で R のグラフ内で LaTeX 数式表現を書く例を示します. par(mar = c(4, 4, 2, .1)) curve(dnorm, -3, 3, xlab = &#39;$x$&#39;, ylab = &#39;$\\\\phi(x)$&#39;, main = &#39;The density function of $N(0, 1)$&#39;) text(-1, .2, cex = 3, col = &#39;blue&#39;, &#39;$\\\\phi(x)=\\\\frac{1}{\\\\sqrt{2\\\\pi}}e^{\\\\frac{-x^2}{2}}$&#39;) 図 11.2: tikz デバイスでレンダリングされたグラフ base R は実は数式表現をサポートしていますが, LaTeX を介してレンダリングされていないことに注意してください (詳細は ?plotmath を見てください). tikz デバイスの細かい組版を調整するいくつかの発展的なオプションがあります. ?tikzDevice::tikz で, できることを確認できます. 例えばグラフにマルチバイト文字が含まれているなら, 次のオプションを設定するといいでしょう. options(tikzDefaultEngine = &quot;xetex&quot;) これは, LaTeX 文書でマルチバイト文字を処理する観点では, xetex の方が大抵の場合はデフォルトのエンジン pdftex より優れているからです. tikz の主な欠点が2つあります. 1つ目は LaTeX のインストールが必要ということですが, これはそこまで深刻ではありません (1.2節参照). 他にもいくつかの LaTeX パッケージが必要になりますが, TinyTeX を使用しているなら簡単にインストールできます. tinytex::tlmgr_install(c(&quot;pgf&quot;, &quot;preview&quot;, &quot;xcolor&quot;)) 2つ目の欠点は, デバイスが LaTeX ファイルを生成してから PDF にコンパイルするため, グラフのレンダリングが顕著に遅くなるということです. コードチャンクに時間がかかると感じるなら, チャンクオプション cache = TRUE でキャッシュを有効にすることもできます (第11.4節参照). 図11.2には, チャンクオプション fig.process = pdf2png が使われています. pdf2png は11.14節で定義された, 出力フォーマットが LaTeX でない時に PDF 画像を PNG に変換するものです. 変換しない場合, 本書のオンライン版をウエブブラウザで閲覧しても PDF グラフは見られないでしょう. 参考文献 "],["low-plots.html", "11.16 低水準作図関数で1つづつグラフを作る (*)", " 11.16 低水準作図関数で1つづつグラフを作る (*) R グラフィックスには2種類の作図関数があります. 高水準作図関数は新たなグラフを作成し, 低水準作図関数は既存のグラフに要素を追加します. 詳細は R マニュアルの12章 An Introduction to R をご覧ください. knitr はデフォルトで, 低水準作図関数がより前のグラフを次々と修正していく段階ではその途中段階のグラフを表示しません. 全ての低水準作図による変更が反映された最後のグラフのみが表示されます. 特に教育目的では, 中間グラフを表示することが有用になりえます. チャンクオプション fig.keep = 'low' を設定すれば, 低水準作図による変更を保存できます. 例えば 図11.3, 11.4は fig.keep = 'low' のオプションを設定した単一のコードチャンクからできたものですが, 2つのコードチャンクから生成されたように見えます. また, チャンクオプション fig.cap = c('...の散布図', '... に回帰直線を追加') で異なる図のキャプションを割り当てています. par(mar = c(4, 4, 0.1, 0.1)) plot(cars) 図 11.3: cars データの散布図. fit &lt;- lm(dist ~ speed, data = cars) abline(fit) 図 11.4: 既にある散布図に回帰曲線を追加 異なるコードチャンク間でグラフの変更を維持したいなら, 第14.5節を参照してください. "],["opts-render.html", "11.17 チャンク内のオブジェクト表示をカスタマイズする (*)", " 11.17 チャンク内のオブジェクト表示をカスタマイズする (*) デフォルトではコードチャンク内のオブジェクトは knitr::knit_print() 関数を通して表示され, これは概ね base R の print() と同じです. knit_print() 関数は S3 ジェネリック関数であり, 自分で S3 メソッドを登録して機能を拡張できることを意味します. 以下は knitr::kable() でデータフレームを表として自動表示する方法の例です. --- title: データフレームの表示にカスタム `knit_print` メソッドを使う --- 初めに `knit_print` メソッドを定義して登録します. ```{r} knit_print.data.frame = function(x, ...) { res = paste(c(&quot;&quot;, &quot;&quot;, knitr::kable(x)), collapse = &quot;\\n&quot;) knitr::asis_output(res) } registerS3method( &quot;knit_print&quot;, &quot;data.frame&quot;, knit_print.data.frame, envir = asNamespace(&quot;knitr&quot;) ) ``` これでデータフレームに対するカスタム表示メソッドをテストできます. もはや `knitr::kable()` を明示的に呼ぶ必要がないことに注意してください. ```{r} head(iris) ``` ```{r} head(mtcars) ``` knit_print() 関数の詳細は knitr パッケージのビネットから学ぶことができます. vignette(&quot;knit_print&quot;, package = &quot;knitr&quot;) printr パッケージ (Xie 2021d) はいくつかの R オブジェクトを可能な範囲で自動的に表として表示する S3 メソッドをいくつか提供します. コードチャンクで library(printr) を実行するだけで十分で, 全てのメソッドが自動的に登録されます. このテクニックがとても上級者向けだと感じたなら, html_document や pdf_document のような R Markdown の出力フォーマットに df_print オプションを与えてください. これでデータフレームの表示に関する挙動をカスタマイズできます. 例えばデータフレームを knitr::kable() で表示したいなら, このようにオプションを設定することもできます. --- output: html_document: df_print: kable --- 出力フォーマット (?rmarkdown::html_document など)が df_print をサポートするかどうか, そこで使用可能な値が何であるかの判断は, 出力フォーマット関数のヘルプページを見てください. 実際には, render チャンクオプションで knit_print() 関数を完全に置き換えることができます. このオプションはオブジェクトを表示する任意の関数を取ることができます. 例えば pander パッケージ を使ってオブジェクトを表示したいなら, チャンクオプション render に pander::pander() を設定するとよいでしょう. ```{r, render=pander::pander} iris ``` render オプションによって, あなたは R オブジェクトの表示方法に対する完全なる自由を手に入れるでしょう. 参考文献 "],["option-hooks.html", "11.18 オプションフック (*)", " 11.18 オプションフック (*) あるチャンクオプションを, 他のチャンクオプションの値に応じて動的に変えたいことがあるかもしれません. これは, opts_hooks オブジェクトを使ってオプションフックを設定すればできます. オプションフックはオプションと関連付けられた関数で, 対応するチャンクオプションが NULL でないときに実行されます. この関数は入力引数として現在のチャンクのオプションのリストを受け取り, そのリストを (変更も加えて) 返します. 例えば fig.width オプションを常に fig.height より小さくならないように調整することができます. knitr::opts_hooks$set(fig.width = function(options) { if (options$fig.width &lt; options$fig.height) { options$fig.width &lt;- options$fig.height } options }) fig.width が NULL になることはないので, このフック関数は必ずコードチャンクの直前に実行され, チャンクオプションを更新します. 以下のコードチャンクは, 上記のオプションフックが設定されていれば, fig.width が初期値の5の代わりに実際には6になります. ```{r fig.width = 5, fig.height = 6} plot(1:10) ``` 別の例として, 第11.12説の最後の例を書き換えて, 単一のチャンクオプション console = TRUE を用いて comment = \"\" と prompt = TRUE を意味できるようにしました. console は knitr の固有のチャンクオプションでなく, 任意の名前のカスタムオプションであることに注意してください. デフォルト値は NULL です. 以下はその完全な例です. ```{r, include=FALSE} knitr::opts_hooks$set(console = function(options) { if (isTRUE(options$console)) { options$comment &lt;- &#39;&#39;; options$prompt &lt;- TRUE } options }) ``` デフォルトの出力. ```{r} 1 + 1 if (TRUE) { 2 + 2 } ``` `console = TRUE` で出力. ```{r, console=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` 3つ目の例はどうやって自動的にソースコード・テキスト出力・メッセージ・警告・エラーの出力ブロックに行番号を追加するかに関するものです. 行番号を追加するために attr.source, attr.output といったチャンクオプションを使用する方法は5.7節で紹介しています. ここでは単一のチャンクオプション (この例では numberLines) で行番号を追加するかどうかを制御したいとします. knitr::opts_hooks$set( numberLines = function(options) { attrs &lt;- paste0(&quot;attr.&quot;, options$numberLines) options[attrs] &lt;- lapply(options[attrs], c, &quot;.numberLines&quot;) options } ) knitr::opts_chunk$set( numberLines = c( &quot;source&quot;, &quot;output&quot;, &quot;message&quot;, &quot;warning&quot;, &quot;error&quot; ) ) 基本的に, オプションフック numberLines は .numberLines 属性を出力ブロックに追加します. opts_chunk$set() によってチャンクオプションnumberLunes が設定されオプションフックが確実に実行されます. 上記の設定では, チャンクオプション numberLines をコードチャンクで使用して, そのチャンクの出力ブロックのどの部分に行番号を付けるかを決めることができます. 例えば numberLines = c('source', 'output') のように. numberLines = NULL は行番号を完全に削除します. このアプローチはチャンクオプションを直接設定するのと何が違うのでしょうか. 例えば第5.7節のように, 単に knitr::opts_chunk$set(attr.source = '.numberLines') とする場合と違って, ここでオプションフックを使う利点は .numberLines 属性をチャンクオプションに追加するというのみですが, これは既にあるチャンクオプションの値を上書きすることを意味しません. 例えば以下のチャンクのソースコードブロックは (既に設定してある) 行番号が付いていますが, 番号付を2行目から始めます. ```{r, attr.source=&#39;startFrom=&quot;2&quot;&#39;} # このコメント行には番号がつかない 1 + 1 ``` これは以下と同等です. ```{r, attr.source=c(&#39;startFrom=&quot;2&quot;&#39;, &#39;.numberLines&#39;} # このコメント行には番号がつかない 1 + 1 ``` "],["output-hooks.html", "12 出力フック (*)", " 12 出力フック (*) knitr パッケージによって, あなたはコードチャンクから出力されるものを各パーツ, ソースコード・テキスト出力・メッセージ・グラフといったものごとに制御しています. この制御は「出力フック」 (output hook(s))によって実現されています. 出力フックは出力の各パーツを入力 (典型的には文字列ベクトルとして扱います) とし, 文字列を出力文書に書き出すために返す一連の関数です. 現時点ではこのしくみを理解するのは簡単ではないでしょうが, これから説明する簡単な例を見ればこのアイディアがはっきりと理解できるものと思います. この例ではコードチャンクの出力が knitr の出力フックを介してレンダリングされる様子を表しています. このような1行だけのコードチャンクについて考えてみてください. ```{r} 1 + 1 ``` knitr がコードチャンクを評価すると, 2つの出力要素を得ます. 2つとも文字列ベクトルとして保持されます. ソースコードの \"1 + 1\" と, テキスト出力の \"[1] 2\" です. これらの文字列は求められている出力フォーマットに応じて, チャンクフックによってさらなる処理がなされます. たとえば Markdown 文書では knitr はソースコードに言語名を付けてコードブロックで囲みます. これは source フックを介して行われ, だいたいこのような関数となります. # 上記のケースでは, `x` は文字列 &#39;1 + 1&#39; に相当 function(x, options) { # ここの小文字 &#39;r&#39; は言語名を表す paste(c(&quot;```r&quot;, x, &quot;```&quot;), collapse = &quot;\\n&quot;) } 同様に, テキスト出力はこのような output フック関数によって処理されます. function(x, options) { paste(c(&quot;```&quot;, x, &quot;```&quot;), collapse = &quot;\\n&quot;) } よって上記のコードチャンクの最終的な出力はこのようになります. ```r 1 + 1 ``` ``` [1] 2 ``` 実際のフックは上記のような2つの関数よりも複雑ですが, 発想は同じです. knit_hooks オブジェクトから get() メソッドで実際のフック関数を取得できます. これが例です. # 意味のある出力のため, 以下のコードは knitr # 文書のコードチャンクの *内部で* 実行されるべき knitr::knit_hooks$get(&quot;source&quot;) knitr::knit_hooks$get(&quot;output&quot;) # または knitr::knit_hooks$get(c(&#39;source&#39;, &#39;output&#39;)) knitr パッケージの開発に貢献することに本当に関心がない方には, 組み込みのフック関数のソースコードを読むことをお薦めしません. 関心がある方は, このコードは https://github.com/yihui/knitr/tree/master/R にある hooks-*.R という形式で命名されたスクリプトファイルでご覧ください. 例えば hooks-md.R には R Markdown 文書に対するフックが含まれています. 普通であれば knitr ユーザーにとっては, 組み込みのフックを活かして使うカスタム出力フックの作り方を知っていれば十分です. この章ではそれが学べますし, 以下では基本的な考え方を示します. カスタム出力フックは knit_hooks の set() メソッドによって登録されます. このメソッドは既存のデフォルトのフックを上書きするので, 既存のフックのコピーを保存し, 好きなように出力要素を処理して, その結果をこのデフォルトのフックに与えるようにしておくことをお薦めします. 構文はたいてい次のようになります. # ここで local() を使うかは任意 (ここでは単に `hook_old` # のような不要なグローバル変数を作ることを避ける目的) local({ hook_old &lt;- knitr::knit_hooks$get(&quot;NAME&quot;) # 古いフックを保存する knitr::knit_hooks$set(NAME = function(x, options) { # ここで, x に何らかの処理を行い, それから 新しい x # を古いフックに与える hook_old(x, options) }) }) ここで, NAME は以下のいずれかのフックの名前を意味します. source: ソースコードを処理するフック. output: テキスト出力を処理するフック. warning: 警告 (たいていは warning() で発生するもの) を処理するフック. message: メッセージ (たいていは message() で発生するもの) を処理するフック. error: エラーメッセージ (たいていは stop() で発生するもの) を処理するフック. plot: グラフのファイルパスを処理するフック. inline: インライン R コードからの出力を処理するフック. chunk: チャンク全体の出力を処理するフック. document: 文書全体を処理するフック. フック関数の引数 x の意味は上記のリストで説明されています. options 引数は現在のコードチャンクのオプションのリストを意味します. 例えば foo = TRUE と設定したなら, フック関数内では options$foo でこの値を得ることができます. options 引数は inline および document フックでは利用できません. 出力フックによって, チャンクと文書の出力の部品1つ1つに対して究極のコントロールを得られます. あらかじめ定義された目的を持つチャンクオプションと比較すると, 出力フックはユーザー定義関数なのではるかに強力であり, 関数内ではあなたが望むことはなんでもできます. "],["hook-hide.html", "12.1 ソースコードを検閲する", " 12.1 ソースコードを検閲する ときにはレポートにソースコードの全文を掲載したくないこともあるでしょう. 例えばコードのある行にパスワードが書かれているかもしれません. 11.7節ではチャンクオプション echo で R コードの文ごとに表示の有無を選べることを言及しました. 例えば echo = 2 で2つ目の文を表示します. この節では, コードのインデックスを指定する必要のない, より柔軟な方法を提供します. 基本的なアイディアはコードに特殊なコメント, 例えば # 秘密!! のようなものを追加するということです. このコメントがコードのある行から検出されると, 行を省略します. 以下は source フックを使用した完全な例です. --- title: &quot;`source` フックを使用してコードのある行を隠す&quot; --- 初めに, 末尾に `# 秘密!!` という文字列を含むコードの行を排除する `source` フックを用意します. ```{r, include=FALSE} local({ hook_source &lt;- knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$set(source = function(x, options) { x &lt;- x[!grepl(&#39;# 秘密!!$&#39;, x)] hook_source(x, options) }) }) ``` これで新しいフックをテストできます. この文書を knit すると, 特殊なコメント `# 秘密!!` のある行が見えなくなります. ```{r} 1 + 1 # 表示されるべき通常のコード # 実際のユーザー名とパスワードを使ってみてください auth &lt;- httr::authenticate(&quot;user&quot;, &quot;passwd&quot;) auth &lt;- httr::authenticate(&quot;yihui&quot;, &quot;horsebattery&quot;) # 秘密!! httr::GET(&quot;http://httpbin.org/basic-auth/user/passwd&quot;, auth) ``` 上記の source フックの重要な部分はこの行です. これはソースコードの入ったベクトル x から grepl() で追跡用のコメントの # 秘密!! とマッチングしたものを排除しています. x &lt;- x[!grepl(&quot;# SECRET!!$&quot;, x)] 正確に言うなら, 上記のフックは追跡用の # 秘密!! というコメントのある行ではなく, 評価式 (expressions) を全て排除します. x は実際には R 評価式のベクトルだからです. 例えば以下のコードチャンクを考えます. 1 + 1 if (TRUE) { # SECRET!! 1:10 } source フック内の x の値はこうなります. c(&quot;1 + 1&quot;, &quot;if (TRUE) { # SECRET!!\\n 1:10\\n}&quot;) R 評価式ではなく行単位で隠したいなら, x を行ごとに分割しなければなりません. xfun::split_lines() の使用を検討するとよいでしょう. フック関数の本体はこうなります. x &lt;- xfun::split_lines(x) # 個別の行に分割する x &lt;- x[!grepl(&quot;# SECRET!!$&quot;, x)] x &lt;- paste(x, collapse = &quot;\\n&quot;) # 結合して1つの行にする hook_source(x, options) この例はソースコードの文字列を操作する方法を, そして grepl() は決して文字列操作の唯一の方法ではない, ということを示しています. 12.2節では他の例もお見せしています. "],["hook-number.html", "12.2 ソースコード内に行番号を追加する", " 12.2 ソースコード内に行番号を追加する この節では, ソースコードに行番号をコメントとして追加する source フックの定義の例を示します. 例えば, このコードチャンクに対するものを考えます. ```{r} if (TRUE) { x &lt;- 1:10 x + 1 } ``` このような出力を求めているものとします. if (TRUE) { # 1 x &lt;- 1:10 # 2 x + 1 # 3 } # 4 完全な例は以下になります. --- title: ソースコードに行番号を追加する --- 行番号をソースコードに追加する `source` フックを用意します. 番号は各行の末尾のコメントに現れます. ```{r, include=FALSE} local({ hook_source &lt;- knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$set(source = function(x, options) { x &lt;- xfun::split_lines(x) n &lt;- nchar(x, &#39;width&#39;) i &lt;- seq_along(x) # 行番号 n &lt;- n + nchar(i) s &lt;- knitr:::v_spaces(max(n) - n) x &lt;- paste(x, s, &#39; # &#39;, i, sep = &#39;&#39;, collapse = &#39;\\n&#39;) hook_source(x, options) }) }) ``` ここで新しいフックのテストができます. この文書を knit するとき, 末尾のコメントに行番号が見られます. ```{r} if (TRUE) { x &lt;- 1:10 x + 1 } ``` 上記の例での主な小ワザは各行のコメントの前に必要なスペースの数を決めることです. これによってコメントが右揃えになっています. この数は各行のコードの文字列幅に依存しています. このフック関数の意味を咀嚼することは読者に任せます. 内部で使われている関数 knitr:::v_spaces() は特定の長さのスペースを生成することに使われている点に注意してください. これが例です. knitr:::v_spaces(c(1, 3, 6, 0)) ## [1] &quot; &quot; &quot; &quot; &quot; &quot; &quot;&quot; 5.7節で紹介した方法が, ソースコードに行番号を追加する方法としてあなたが本当に求めていたものかもしれません. その構文はより簡潔で, ソースコードでもテキスト出力ブロックでも動作します. 上記の source フックの小ワザは, カスタム関数でソースコードを操作できることの一例を示すのが主な狙いです. "],["hook-scroll.html", "12.3 スクロール可能なテキスト出力", " 12.3 スクロール可能なテキスト出力 7.4節ではコードブロックとテキスト出力ブロックの高さを CSS で制御する方法を紹介しました. 実際には, もっと簡単なやり方で, チャンクオプション attr.source と attr.output を使って style 属性を Markdown のコードブロックに追加できます(これらのオプションの説明は11.13節参照). 例えば, このようなコードに対してチャンクオプション attr.output を使います. ```{r, attr.output=&#39;style=&quot;max-height: 100px;&quot;&#39;} 1:300 ``` Markdown 出力はこうなります. ```r 1:300 ``` ```{style=&quot;max-height: 100px;&quot;} ## [1] 1 2 3 4 5 6 7 8 9 10 ## [11] 11 12 13 14 15 16 17 18 19 20 ## ... ... ``` そして, テキスト出力ブロックは Pandoc によって HTML へと変換されます. &lt;pre style=&quot;max-height: 100px;&quot;&gt; &lt;code&gt;## [1] 1 2 3 4 5 6 7 8 9 10 ## [11] 11 12 13 14 15 16 17 18 19 20 ## ... ...&lt;/code&gt; &lt;/pre&gt; Pandoc の fenced code blocks についてより詳しく学ぶには, https://pandoc.org/MANUAL.html#fenced-code-blocks のマニュアルを読んでください. attr.source と attr.output オプションによって個別のコードチャンクに対して最大の高さを指定することができます. しかしこの構文は少しばかり野暮ったく, CSS と Pandoc の Markdown 構文をより理解する必要があります. 以下にカスタムチャンクオプション max.height と連動するカスタム output フックの例を示します. attr.output = 'style=\"max-height: 100px;\"' の代わりに max.height = \"100px\" のようにオプションを設定するだけでよいのです. この例では x 引数には手を付けず, options 引数のみを操作しています. --- title: スクロール可能なコードブロック output: html_document: highlight: tango --- チャンクオプション `max.height` が設定されている時, テキスト出力に `style` 属性を追加するような `output` フックを設定します. ```{r, include=FALSE} options(width = 60) local({ hook_output &lt;- knitr::knit_hooks$get(&#39;output&#39;) knitr::knit_hooks$set(output = function(x, options) { if (!is.null(options$max.height)) options$attr.output &lt;- c( options$attr.output, sprintf(&#39;style=&quot;max-height: %s;&quot;&#39;, options$max.height) ) hook_output(x, options) }) }) ``` `max.height` がない場合, 出力の全体が表示されます. 例えば..., ```{r} 1:100 ``` ここで `max.height` に `100px` を設定します. この高さは 100px を超えているので, テキスト出力にスクロールバーが現れます. ```{r, max.height=&#39;100px&#39;} 1:100 ``` 原則として `max.height` オプションは `attr.output` オプションに変換されます. `attr.output` が既に設定されていたとしても動作します. つまり `attr.output` オプションは上書きされません. 例えば `.numberLines` 属性を付けてテキスト出力の端に行番号を表示させてみます. ```{r, max.height=&#39;100px&#39;, attr.output=&#39;.numberLines&#39;} 1:100 ``` 図12.1がその出力です. 最後のコードチャンクにあるチャンクオプション attr.output に注意してください. そのオプションは max.height によっては上書きされないのです. なぜなら, max.height が生成する style 属性を使って既存の属性と結合することで, 既存の属性を尊重しているからです. options$attr.output &lt;- c( options$attr.output, sprintf(&#39;style=&quot;max-height: %s;&quot;&#39;, options$max.height) ) 図 12.1: チャンクオプション max.height を指定した, スクロール可能なテキスト出力の例 source フックでも同様の小ワザを使って, ソースコードブロックの高さを制限できます. "],["hook-truncate.html", "12.4 テキスト出力を中断する", " 12.4 テキスト出力を中断する コードチャンクから出力されたテキストが長い時, 冒頭の数行だけを表示させたくなります. 例えば数千行のデータフレームを表示する時, データ全体を表示するのは不便で, 最初の数行だけで十分でしょう. 以下では output フックを再定義してカスタムチャンクオプション out.lines によって最大行数を制御できるようにしています. # 組み込みの出力フックを保存 hook_output &lt;- knitr::knit_hooks$get(&quot;output&quot;) # テキスト出力を打ち切る出力フックを新規に作成 knitr::knit_hooks$set(output = function(x, options) { if (!is.null(n &lt;- options$out.lines)) { x &lt;- xfun::split_lines(x) if (length(x) &gt; n) { # 出力を切断 x &lt;- c(head(x, n), &quot;....\\n&quot;) } x &lt;- paste(x, collapse = &quot;\\n&quot;) } hook_output(x, options) }) 上記のフック関数の基本的なアイディアはテキスト出力の行数が, チャンクオプション out.linesで指定したしきい値 (関数本体では変数 n として保存されています) を上回ったら, 最初の n 行だけを残し, 省略記号 (....) を末尾に加え出力が打ち切られたことを表します. 以下のチャンクでチャンクオプション out.lines = 4 を設定し, この新たな output フックをテストできます. print(cars) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 .... 期待通りに4行の出力が現れました. 元の output フックを hook_output に保存しているので, 再度 set() メソッドを呼び出して復元することができます. knitr::knit_hooks$set(output = hook_output) 読者への練習問題として, 異なる方法で出力を打ち切ることに挑戦してみてください. 最大行を決定するチャンクオプション out.lines を所与として, 末尾の行ではなく中間の行を打ち切ることができますか? 例えば out.lines = 10 なら, このように最初と最後の5行を残し, 中間に .... を追加します. ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 .... ## 46 24 70 ## 47 24 92 ## 48 24 93 ## 49 24 120 ## 50 25 85 出力の最終行, つまりフック関数の引数 x が空白行ならば, c(head(x, n/2), '....', tail(x, n/2 + 1)) のような処理が必要であることに注意してください. +1 は最後の空白行を考慮するためです. "],["hook-html5.html", "12.5 HTML5 フォーマットで図を出力する", " 12.5 HTML5 フォーマットで図を出力する デフォルトでは R Markdown のグラフは HTML 上で &lt;p&gt; または &lt;div&gt; タグ内の &lt;img src=\"...\" /&gt; で読み込まれます. 以下の例は HTML5 の &lt;figure&gt; タグでグラフを表示する方法です. --- title: &quot;`&lt;figure&gt;` タグで図を出力する&quot; output: html_document --- ファイルパス `x` とチャンクオプション `options$fig.cap` の 図のキャプションが与えられた状態で, このようなフォーム内に HTML5 タグ内にグラフを描きたいとします. ```html &lt;figure&gt; &lt;img src=&quot;ファイルパス&quot; alt=&quot;キャプション&quot; /&gt; &lt;figcaption&gt;キャプション&lt;/figcaption&gt; &lt;/figure&gt; ``` ここで出力フォーマットが HTML であるときのみ `plot` フックを再定義します. ```{r} if (knitr::is_html_output()) knitr::knit_hooks$set( plot = function(x, options) { cap &lt;- options$fig.cap # 図のキャプション tags &lt;- htmltools::tags as.character(tags$figure( tags$img(src = x, alt = cap), tags$figcaption(cap) )) } ) ``` 以下のコードチャンクから生成されたプロットは `&lt;figure&gt;` タグ内に配置されます. ```{r, fig.cap=&#39;cars データの散布図&#39;} par(mar = c(4.5, 4.5, .2, .2)) plot(cars, pch = 19, col = &#39;red&#39;) ``` `&lt;figure&gt;` と `&lt;figcaption&gt;` タグの見栄えのために CSS スタイルを追加します. `figure` には破線の枠を, キャプションには明桃色の背景を設定します. ```{css, echo=FALSE} figure { border: 2px dashed red; margin: 1em 0; } figcaption { padding: .5em; background: lightpink; font-size: 1.3em; font-variant: small-caps; } ``` 図12.2がその出力です. この例では実際には plot フックを上書きしましたが, この章の他のほとんどの例ではデフォルトのフックの冒頭にカスタムフックを構築していることに注意してください. デフォルトのフックを完全に上書きするのは, 組み込まれている機能を無視しても構わない時に限るべきです. 例えば次の plot フックは out.width ='100%' や fig.show = 'animate' といったチャンクオプションがあるかもしれないことを考慮していません. 図 12.2: HTML5 figure タグ内の図 この例はファイルパス x と plot フックが活用できそうなことを示すものです. 図のスタイルのカスタマイズだけが必要なら, HTML5 タグを使うことはありません. 通常であれば, デフォルトの plot フックは以下のような HTML コードに画像を出力します. &lt;div class=&quot;figure&quot;&gt; &lt;img src=&quot;ファイルパス&quot; /&gt; &lt;p class=&quot;caption&quot;&gt;キャプション&lt;/p&gt; &lt;/div&gt; よって div.figure と p.caption に対して CSS ルールを定義するだけで可能となります. "],["chunk-hooks.html", "13 チャンクフック (*)", " 13 チャンクフック (*) チャンクフックはあるチャンクオプションの値が NULL ではないときに駆動する関数です. チャンクフックを使うと, チャンク内でコードを実行する以上の追加のタスクを実行することができます. 例えばグラフに後処理をしたり (例えば13.1節, 13.2節) , コードチャンクの実行時間を記録したいときなどです. このようなタスクはレポート内の計算や分析に必須でなくても, 例えばグラフを改良したり最も時間のかかるチャンクを特定したりといった, 他の目的に対しては役に立つででしょう. 例えばコンソールになんらかの情報をただ表示するだけなど, チャンクフックをまったく別の作用のために使うことができますし, あるいは返り値を使うなら, それが文字列であれば出力文書にその値を書き出すこともできます. 出力フック (12章参照)のように, チャンクフックは knitr::knit_hooks オブジェクトにて登録されます. 出力フックの名前は knitr によって予約されているので, カスタムチャンクフックに使ってはならないことに注意してください. names(knitr:::.default.hooks) ## [1] &quot;source&quot; &quot;output&quot; ## [3] &quot;warning&quot; &quot;message&quot; ## [5] &quot;error&quot; &quot;plot&quot; ## [7] &quot;inline&quot; &quot;chunk&quot; ## [9] &quot;text&quot; &quot;evaluate.inline&quot; ## [11] &quot;evaluate&quot; &quot;document&quot; チャンクフックは同じ名前のチャンクオプションと関連付けられています. 例えば greet という名前のチャンクフックを登録できます. knitr::knit_hooks$set(greet = function(before) { if (before) &quot;Hello!&quot; else &quot;Bye!&quot; }) この後すぐにフック関数の引数について説明します. まずは以下のチャンクでチャンクオプション greet = TRUE を設定してみます. ```{r, greet=TRUE} 1 + 1 ``` するとチャンクの前に “Hello!” という文字が現れ, 以下のチャンクの出力部の後に “Bye!” という文字が現れます. これは両者が文字列だからです. Hello! 1 + 1 ## [1] 2 Bye! チャンクフック関数は before ・ options ・ envir ・ name の4つの引数を取ることができます. 言い換えるならこのような形式にすることができます. function(before, options, envir, name) { } 4つの引数はすべてあってもなくてもかまいません. 4つ, 3つ, 2つ, 1つ, あるいは引数がなくとも可能です. 上記の例では before 引数1つだけを使っています. これらの引数は以下のような意味があります. before: このチャンクが現在, 実行される直前か直後かです. チャンクフックはコードチャンクごとに2度実行される, つまり直前に1度 hook(before = TRUE) が, 直後に hook(before = FALSE) が実行されることに注意してください. options: 現在のコードチャンクのチャンクオプションのリストです. 例えば list(fig.width = 5, echo = FALSE, ...) のような値です. envir: チャンクフックが評価される環境です. name: チャンクフックのトリガーとなるチャンクオプションの名前です. この章の冒頭で言及したように, チャンクフックの返す値が文字列でなければ無視されなにも起こりませんが, 文字列のときは出力文書に書き出されます. "],["crop-plot.html", "13.1 グラフをクロップする", " 13.1 グラフをクロップする チャンクフックknitr::hook_pdfcrop() は PDF やその他の種類の画像ファイルをクロップ, つまりグラフから余分な余白を削除するのに使えます. これを有効にするには, コードチャンク内で knit_hooks$set() を使って対応するチャンクオプションをオンに設定してください. これが例です. knitr::knit_hooks$set(crop = knitr::hook_pdfcrop) そうすると, チャンクオプション crop = TRUE を使ってグラフをクロップできます. フック関数 hook_pdfcrop() は内部プログラム pdfcrop を呼び出して PDF ファイルをクロップします. このプログラムは通常 LaTeX の配布パッケージ (例えば TeX Live や MikTeX) に同梱されています. システムでこれが使用可能かどうかは次のようにして確認できます. # 返り値が空でないなら使用可能 Sys.which(&quot;pdfcrop&quot;) ## pdfcrop ## &quot;/home/ks/bin/pdfcrop&quot; LaTeX 配布パッケージの TinyTeX (1.2節参照) を使っていて, pdfcrop があなたのシステムで利用できないときは, tinytex::tlmgr_install('pdfcrop') でインストールできます. 訳注 knitr::hook_pdfcrop の使用には ghostscript も必要になります. 環境によっては別途, 手動でインストールする必要があるかもしれません. PNG や JPEG といった PDF でないグラフ画像ファイルに対しては, このフック関数は R パッケージの magick (Ooms 2021b)を呼び出してクロップします. この R パッケージがインストールされているか確かめておきましょう. 図13.1はクロップされていないグラフで, 図 13.2はクロップされた同じグラフです. 図 13.1: クロップされていないグラフ 図 13.2: クロップされたグラフ 参考文献 "],["optipng.html", "13.2 PNG のグラフを最適化する", " 13.2 PNG のグラフを最適化する OptiPNG (http://optipng.sourceforge.net) プログラムをインストールしていれば, knitr::hook_optipng() フックを使って PNG 形式のグラフ画像ファイルの画質を劣化させることなく縮小して最適化できます. knitr::knit_hooks$set(optipng = knitr::hook_optipng) このフックを設定したら, チャンクオプション optipngを使い, OptiPNG へのコマンドライン引数を渡すことができます (例えば optipng = '-o7'). コマンドライン引数はオプションなので, フックを有効にするためだけに optipng = '' と書くことも可能です. 使用可能な引数を知るには OptiPNG のウェブサイト上にあるユーザーマニュアルを見てください. macOS ユーザーは Homebrew (https://brew.sh) で簡単に OptiPNG をインストールできます (brew install optipng). "],["time-chunk.html", "13.3 チャンクの実行時間をレポートする", " 13.3 チャンクの実行時間をレポートする knitr はデフォルトでは knit 処理中にテキストベースの進捗バーを提供します. より正確なチャンクの時間の情報がほしいなら, カスタムチャンクフックを登録して各チャンクの時間を記録することもできます. これはそのようなフックの例です. knitr::knit_hooks$set(time_it = local({ now &lt;- NULL function(before, options) { if (before) { # 各チャンクの直前の時刻を記録する now &lt;&lt;- Sys.time() } else { # チャンク直後の時刻との差を計算する res &lt;- difftime(Sys.time(), now) # 時間を表示するための文字列を返す paste(&quot;Time for this code chunk to run:&quot;, res) } } })) するとこれ以降のチャンクでは, チャンクオプション time_it を使って時間を測定できます. これが例です. ```{r, time_it = TRUE} Sys.sleep(2) ``` 全てのコードチャンクで時間を表示したいなら, もちろん knitr::opts_chunk$set(time_it = TRUE) でグローバルに設定することができます. 上記のフック関数では, さらに詳細な情報をチャンクオプションから出力することもできます. つまりフック関数の options 引数を使います. 例えば, 返り値のチャンクラベルを表示することもできます. paste(&quot;Time for the chunk&quot;, options$label, &quot;to run:&quot;, res) あるいはフック関数で時間を表示させずに記録するだけという手もあります. all_times &lt;- list() # 全てのチャンクの時間を保存する knitr::knit_hooks$set(time_it = local({ now &lt;- NULL function(before, options) { if (before) { now &lt;&lt;- Sys.time() } else { res &lt;- difftime(Sys.time(), now) all_times[[options$label]] &lt;&lt;- res } } })) こうすると all_times オブジェクトで全ての実行時間情報にアクセスすることができます. このオブジェクトはチャンクラベルを名前にもつ名前つきリストで, 各要素の値はそれぞれのチャンクの実行時間です. 最後に技術的な注意事項として, 先ほどのフックで使われた local() 関数に詳しくない人もいるかもしれませんので, これについて説明したいとおもいます. この関数でコードを「ローカルな」環境で実行することができます. その主な恩恵は, コード内で作られた変数はこの環境内のローカルなものになるので, 外部の環境, たいていの場合はグローバル環境を汚染することがないということです. 例えばここでは local() 内で now 変数を作成し, これを time_it 内で使用しています. フック関数内では通常の代入演算子 &lt;- の代わりに二重アロー演算子 &lt;&lt;- で now の値を更新しています. &lt;&lt;- は 親環境（ここではあくまでも, local() 環境の内部にある）の変数に代入し, &lt;- は単に現在の環境にのみ値を代入するからというのが理由です. 各コードチャンクが評価される直前に, ローカル変数 now は現在の時刻を記録します. 各コードチャンクが評価されたら現在時刻と now との差を計算します. local() はコード内に渡された最後の値を返しますが, ここではそれがフック関数であることに注意してください. 簡潔に言うなら, local() は, ローカルだけで使われグローバル環境で使われない変数を露出しないことで, ワークスペースをきれいに保つということです. グローバル環境に変数 now が作られても構わなければ, local() を使わないという選択もできます. "],["show-header.html", "13.4 出力にチャンクヘッダを表示する", " 13.4 出力にチャンクヘッダを表示する 読者に元のチャンクヘッダのコードを表示したい時もあるかもしれません. 例えば R Markdown のチュートリアルを書いていて, チャンクの出力とその出力を生成するのに使用したチャンクオプションの両方を表示すれば, 読者が自分で同じことをする方法を学ぶことができるというわけです. 元のチャンクオプションは実際にはチャンクオプションの params.scr 内に文字列として保存されています. これを知ったあなたは params.src を出力するチャンクフックを書くこともできます. 以下はその完全な例です. --- title: 出力にチャンクヘッダを表示する --- 本来のチャンクヘッダとフッタの内側にチャンクを出力する `wrapper` という名前のチャンクフックを用意します. ```{r, setup, include=FALSE} knitr::knit_hooks$set(wrapper = function(before, options) { # 本来のチャンクはインデントされる if (is.null(indent &lt;- options$indent)) indent &lt;- &#39;&#39; # wrapper=TRUE オプションを隠す opts &lt;- gsub(&#39;, wrapper=TRUE&#39;, &#39;&#39;, options$params.src) if (before) { # ヘッダを追加する sprintf(&#39;\\n\\n%s````\\n```{r,%s}\\n````\\n&#39;, indent, opts) } else { # フッタを追加する sprintf(&#39;\\n\\n%s````\\n```\\n````\\n&#39;, indent) } }) ``` ここでチャンクオプション `wrapper=TRUE` でフックを適用します. `wrapper=TRUE` をヘッダの最後に置くことと, 正確に `wrapper=TRUE` でなければならず, 上記で呼び出されている `gsub()` を修正しない限り, 例えば `wrapper=T` はダメで, コンマとスペースの後に続けなければならないことも忘れないでください. ```{r, test-label, collapse=TRUE, wrapper=TRUE} 1 + 1 plot(cars) ``` 本来のチャンクヘッダが出力に現れるはずです. フックはチャンクがインデントされていても動作するはずです. これが例です. - 箇条書きその1 ```{r, eval=TRUE, wrapper=TRUE} 2 + 2 ``` - もう1つ箇条書き 基本的には, options$params.src から取り出したチャンクヘッダを ```{r, } の中に入れることで元のヘッダを再現しています. そしてこの行を1組の4連続バッククオートで囲んでいるので, 出力時にはそのまま表示されます. 本来のコードチャンクはインデントされているかもしれない (例: 箇条書き内にネストされている場合)ので, 適切にインデントを追加することも必要になります. これはチャンクオプション options$indent に保存されています. 上記の例の最後の, 箇条書き内の出力はこのようになります. 箇条書きその1 ```{r, eval=TRUE} 2 + 2 ## [1] 4 ``` もう1つ箇条書き コードチャンクが評価され, チャンクヘッダも追加されていることが分かったかと思います. "],["rgl-3d.html", "13.5 rgl によるインタラクティブな3次元グラフを埋め込む", " 13.5 rgl によるインタラクティブな3次元グラフを埋め込む rgl パッケージ (Adler and Murdoch 2021) を使うとインタラクティブな3次元グラフを生成できます. WebGL 形式で保存すれば, これらのグラフは（保存後も）インタラクティブのままです. これはフック関数 rgl::hook_webgl() を使えば可能です. 以下の例は rgl と knitr で 3次元グラフをインタラクティブ性を保ったまま保存できるようにする方法を示しています. --- title: rgl で3次元グラフを埋め込む output: html_document --- **rgl** を保存するフック関数を用意する. ```{r, setup} library(rgl) knitr::knit_hooks$set(webgl = hook_webgl) ``` フックを有効にした後で, チャンクオプション `webgl = TRUE` で この3次元グラフが動作するかを確認してください. ```{r, test-rgl, webgl=TRUE} x &lt;- sort(rnorm(1000)) y &lt;- rnorm(1000) z &lt;- rnorm(1000) + atan2(x,y) plot3d(x, y, z, col = rainbow(1000)) ``` この例をコンパイルすると図13.3のようなインタラクティブな3次元散布図が得られるはずです. インタラクティブなグラフは出力フォーマットが HTML の時だけ動作することに注意してください. 図 13.3: rgl パッケージから生成した3次元散布図 参考文献 "],["knitr-misc.html", "14 その他の knitr の小ワザ", " 14 その他の knitr の小ワザ knitrには, チャンクオプション(11章)・出力フック(12章)・チャンクフック (13章) にとどまらず, 他にも役に立つ関数や小ワザがあります. この章では, コードチャンクの再利用, knit を早めに打ち切る方法, グラフの配置場所のカスタマイズの方法などといった小ワザを紹介します. "],["reuse-chunks.html", "14.1 コードチャンクを再利用する", " 14.1 コードチャンクを再利用する コードチャンクは, コピーアンドペーストなしで文書のどの場所でも自由に再利用できます. ポイントはコードチャンクにラベルを付けることで, そうすると他の場所でラベルによって参照することができます. コードチャンクの再利用には3種類の方法があります. 14.1.1 チャンクを別の場所にも埋め込む (*) あるコードチャンクは, チャンクのラベル名を &lt;&lt;&gt;&gt; で囲んで別のコードチャンクに埋め込むことができます. すると knitr は自動的に &lt;&lt;ラベル&gt;&gt; を実際のコードへと展開してくれます. 例えば, この方法で R 関数を作ることができます. 華氏温度を摂氏温度に変換する関数を定義する ```{r, f2c} F2C &lt;- function(x) { &lt;&lt;check-arg&gt;&gt; &lt;&lt;convert&gt;&gt; } ``` 最初に入力値が数値か確認する ```{r, check-arg, eval=FALSE} if (!is.numeric(x)) stop(&quot;入力は数値でなければなりません!&quot;) ``` それから実際に変換します ```{r, convert, eval=FALSE} (x - 32) * 5/ 9 ``` これはドナルド=クヌースの提案する文芸プログラミング の主要なアイディアの1つに基づいたものです. この技術の利点は (複雑な) コードを小さな部品に分割し, 別々のコードチャンクに書き, 文脈の中で説明することができる点です. 全ての部品は実行される主要なコードチャンクで構成することができます. 上記の例に対して, f2c というラベルのある最初のコードチャンクはこうなります. ```{r, f2c} F2C &lt;- function(x) { if (!is.numeric(x)) stop(&quot;The input must be numeric!&quot;) (x - 32) * 5/ 9 } ``` 1つのコードチャンクには好きな数のコードチャンクを埋め込むことが可能です. 埋め込みは再帰的にすることも可能です. 例えば, チャンク A をチャンク B に埋め込み, さらにチャンク B をチャンク C に埋め込むこともできます. チャンク C はチャンク B から読み込まれたチャンク A を含むことになります. マーカー &lt;&lt;ラベル&gt;&gt; は独立した行に置く必要はありません. コードチャンクのどこにでも埋め込むことができます. 14.1.2 別のチャンクで同一のチャンクラベルを使う 完全に同じコードチャンクを2回以上使いたいならば, ラベル付きのチャンクを定義し, さらに同じラベルで中身が空のチャンクを作ることもできます. 例えばこのように. これは評価されないコードチャンクです ```{r, chunk-one, eval=FALSE} 1 + 1 2 + 2 ``` 実際に評価されるのはこちらです ```{r, chunk-one, eval=TRUE} ``` 上記の例でチャンクラベル “chunk-one” を2度使っており, 2度目のチャンクは最初のチャンクの単なる再利用です. グラフないしは他のファイルを生成するのに, この方法で複数回コードチャンクを実行するのはお薦めしません. 後のチャンクで作成された画像ファイルがそれ以前のものを上書きするかもしれないからです. これらのチャンクのうち1つだけにチャンクオプション eval = TRUE を使い, それ以外では eval =FALSE を使うのならば大丈夫です. 14.1.3 参照ラベルを使う (*) チャンクオプション ref.label はチャンクラベルのベクトルを取り, そのチャンクの中身を取得できます. 例えば以下の chunk-a というラベルのコードチャンクは chunk-c と chunk-b を結合したものです. ```{r chunk-a, ref.label=c(&#39;chunk-c&#39;, &#39;chunk-b&#39;)} ``` ```{r chunk-b} # これはチャンク b 1 + 1 ``` ```{r chunk-c} # これはチャンク c 2 + 2 ``` 言い換えるなら, chunk-a は本質的にこうなります. ```{r chunk-a} # これはチャンク c 2 + 2 # これはチャンク b 1 + 1 ``` チャンクオプション ref.label のあるおかげで, コピーアンドペーストを使うことなくコードチャンクをとても柔軟に再構成することができます. 参照先のコードチャンクが ref.label が使われたチャンクの前にあるか, 後にあるかは問題になりません. 先に書かれたコードチャンクは後のコードチャンクを参照できます. 4.19節にはこのチャンクオプションの応用例があります. "],["load-cache.html", "14.2 オブジェクトが作られる前に使用する (*)", " 14.2 オブジェクトが作られる前に使用する (*) knitr 文書内の全てのコードは, コードチャンクとインライン R コードも含めて, 最初から最後まで順番に実行されます. 理論上は, 値が代入される前の変数を使うことができません. しかし場合により, 文書内で変数の値により早く言及したいことがあるでしょう. 例えば論文の中で結果を概要欄に掲載したいというのはよくある状況ですが, 実際には結果は文書のもっと後で計算されます. 以下の例はそのアイディアを具体化したものですが, 実行はできません. --- title: 重要なレポート 概要: &gt; この分析では `x` の平均値が `r mx` であった. --- 我々は次のチャンクで `mx` を作成した. ```{r} x &lt;- 1:100 mx &lt;- mean(x) ``` この問題を解決するには, オブジェクトの値がどこかに保存され, 文書が次回コンパイルされる時に読み込まれなければなりません. これは, 文書が最低でも2回コンパイルされなければならないという意味であることに注意してください. 以下は saveRDS() 関数を使った, 実行可能な解決策の1つです. ```{r, include=FALSE} mx &lt;- if (file.exists(&#39;mean.rds&#39;)) { readRDS(&#39;mean.rds&#39;) } else { &quot;`mx` の値はまだ利用できない&quot; } ``` --- title: 重要なレポート 概要: &gt; この分析では `x` の平均値が `r mx` であった. --- 我々は次のチャンクで `mx` を作成した. ```{r} x &lt;- 1:100 mx &lt;- mean(x) saveRDS(mx, &#39;mean.rds&#39;) ``` 最初のコンパイルでは, 概要に「mx の値はまだ利用できない」という文言が現れます. その後, もう1度コンパイルすると mx の値が現れます. knitr::load_cache() 関数はもう1つの解決策で, 特定のコードチャンクでキャッシュ済みのオブジェクトから値を読み込むことできます. このアイディアは上記の例と似ていますが, オブジェクトが自動でキャッシュデータベースに保存されるため, オブジェクトを手動で保存して読み込む手間を省くことになります. あなたは load_cache() で読み込むだけでいいのです. 以下は単純化した例です. --- title: An important report abstract: &gt; この分析では `x` の平均値が `r knitr::load_cache(&#39;mean-x&#39;, &#39;mx&#39;)` であった. --- 我々は次のチャンクで `mx` を作成した. ```{r mean-x, cache=TRUE} x &lt;- 1:100 mx &lt;- mean(x) ``` この例では, チャンクラベル mean-x をコードチャンクに追加し, それを load_cache() 関数に渡します. そしてチャンクオプション cache = TRUE でチャンクをキャッシュしています. このコードチャンクの全てのオブジェクトはキャッシュデータベースに保存されます. 繰り返しになりますが, オブジェクト mx はキャッシュデータベースから正しく読み込まれるには, この文書を最低でも2回コンパイルしなければなりません. mx の値が将来も変更される予定がないなら, 文書をこれ以上コンパイルする必要はありません. もし load_cache() の第2引数でオブジェクト名を指定しないなら, キャッシュデータベース全体が現在の環境に読み込まれます. そうすると, 文書の後方でオブジェクトが作成される前でも, キャッシュデータベースにあるどのオブジェクトも使えます. これが例です. knitr::load_cache(&quot;mean-x&quot;) x # the object `x` mx # the object `mx` "],["knit-exit.html", "14.3 knit 処理を打ち切る", " 14.3 knit 処理を打ち切る 時には knit 処理を文書の末尾よりも早い時点で終了したいこともあります. 例えば何かを分析する作業をしていて,結果の前半だけを共有したいとか, まだ最後のコードが書ききれていないというときです. このような状況ではコードチャンクで knit_exit() 関数を使ってみましょう. この関数はそのチャンクの直後で knit 処理を終わらせることができます. 以下は単純な例です. ここではとても単純なチャンクと, その後にもっと時間のかかるチャンクを配置しています. ```{r} 1 + 1 knitr::knit_exit() ``` あなたは出力のうち上記のコンテンツだけを見たい. ```{r} Sys.sleep(100) ``` 通常ならば100秒待つところですが, knit_exit() を呼び出しているので文書の残りの部分は無視されます. "],["fig-chunk.html", "14.4 どこにでもグラフを生成し, 表示させる", " 14.4 どこにでもグラフを生成し, 表示させる グラフは通常コードチャンク内で生成され, その直下に表示されますが, 以下の例のように表示場所を好きなところに指定したり, コードチャンクに隠すことも選べます. このコードチャンクでグラフを生成しますが, 表示はしません. ```{r cars-plot, dev=&#39;png&#39;, fig.show=&#39;hide&#39;} plot(cars) ``` 別の段落でグラフを導入します ![A nice plot.](`r knitr::fig_chunk(&#39;cars-plot&#39;, &#39;png&#39;)`) 一時的にグラフを隠すためにコードチャンクでチャンクオプション fig.show='hide' を使用しました. それから別の段落で knitr::fig_chunk() 関数を呼び出して, このグラフ画像のファイルパスを取得しました. このパスは普通は test_files/figure-html/cars-plot-1.png のようになっています. このファイルパスを導出するためには, fig_chunk() 関数にチャンクラベルとグラフィックデバイス名を渡す必要があります. blogdown で作成したウェブサイトへの fig_chunk() の応用を https://stackoverflow.com/a/46305297/559676 で見ることもできます. この関数はどの R Markdown 出力フォーマットでも動作します. 特にスライド上では, スクリーンの広さが限られているため, 画像を表示するのに便利でしょう. 1つのスライドでコードを提示し, さらに別のスライドで画像を表示させることもできます. "],["global-device.html", "14.5 以前のコードチャンクのグラフを修正する", " 14.5 以前のコードチャンクのグラフを修正する knitr はデフォルトでは, コードチャンクごとに新規にグラフィックデバイスを開いてグラフを記録しています. これは1つ問題を起こしています. グラフィックデバイスが既に閉じられているため, 以前のコードチャンクで作成されたグラフを簡単には修正できないという問題です. base R のグラフィックではたいていの場合で問題となります. なお ggplot2 (Wickham, Chang, et al. 2021) のような grid ベースのグラフィックは, グラフを R オブジェクトとして保存できるので当てはまりません. 例えばあるコードチャンクでグラフを描き, 後のチャンクでグラフに線を描き足そうとしても, R は高水準グラフがまだ作られていないというエラーを示すので, 線を描き足すことができません. 全てのコードチャンクでグラフィックデバイスを開いたままにしたいなら, 文書の冒頭で knitr パッケージのオプションである を設定します. knitr::opts_knit$set(global.device = TRUE) より頻繁に使われる opts_chunk ではなく opts_knit が使われていることに注意してください. 例は Stack Overflow の https://stackoverflow.com/q/17502050 という投稿で見ることもできます. グローバルなグラフィックデバイスを必要としなくなった時は, オプションを FALSE に設定できます. これは完全な例です. --- title: &quot;グラフの保存にグローバルグラフィックデバイスを使用する&quot; --- まず, グローバルグラフィックデバイスを有効にします. ```{r, include=FALSE} knitr::opts_knit$set(global.device = TRUE) ``` グラフを描画します. ```{r} par(mar = c(4, 4, 0.1, 0.1)) plot(cars) ``` 以前のコードチャンクのグラフに線を追加します. ```{r} fit &lt;- lm(dist ~ speed, data = cars) abline(fit) ``` グローバルデバイスを切ります. ```{r, include=FALSE} knitr::opts_knit$set(global.device = FALSE) ``` 別のグラフを描画します. ```{r} plot(pressure, type = &#39;b&#39;) ``` 参考文献 "],["opts-template.html", "14.6 グループ化したチャンクオプションを保存し再利用する (*)", " 14.6 グループ化したチャンクオプションを保存し再利用する (*) いくつかのチャンクオプションを頻繁に使うのなら, それらを1つのグループとして保存し, 以降はグループ名を書くだけで再利用できるようにするとよいかもしれません. これは knitr::opts_template$set(name = list(options)) で実行できます. それからチャンクオプション opts.label を用いてこのグループ名を参照できます. 例えばこのように. ```{r, setup, include=FALSE} knitr::opts_template$set(fullwidth = list( fig.width = 10, fig.height = 6, fig.retina = 2, out.width = &#39;100%&#39; )) ``` ```{r, opts.label=&#39;fullwidth&#39;} plot(cars) ``` opts.label = 'fullwidth' とすると, knitr は knitr::opts_template から一連のチャンクオプションを読み込み, 現在のチャンクに適用します. これはタイピングの労力を削減できます. チャンクオプションを文書全体で使用しなければならないならば, グローバルに設定すべきでしょう (11章参照). opts.label から読み込んだオプションを上書きすることもできます. 例えば以下のチャンクで fig.height = 7 を設定したなら, 実際の値は 6 でなく 7 になります. ```{r, opts.label=&#39;fullwidth&#39;, fig.height=7} plot(cars) ``` オプションのグループは好きな数だけ保存できます. 例えば knitr::opts_template$set(group1 = list(...), group2 = list(...)) のように. "],["knit-expand.html", "14.7 Rmd ソースの生成に knitr::knit_expand() を使う", " 14.7 Rmd ソースの生成に knitr::knit_expand() を使う knitr::knit_expand() 関数は, デフォルトで {{ }} 内の表現を値に展開 (expand) します. これが例です. knitr::knit_expand(text = &quot;`pi` の値は {{pi}} である.&quot;) ## [1] &quot;`pi` の値は 3.14159265358979 である.&quot; knitr::knit_expand( text = &quot;`a` の値は {{a}} なので, `a + 1` は {{a+1}} である.&quot;, a = round(rnorm(1), 4) ) ## [1] &quot;`a` の値は -1.1142 なので, `a + 1` は -0.1142 である.&quot; {{ }} 内に動的なものが含まれている Rmd 文書であれば, knit_expand() を適用して knit() を呼び出してコンパイルすることができるということを, この例は意味しています. 例えばここに template.Rmd という文書があったとします. # {{i}} に対する回帰 ```{r lm-{{i}}} lm(mpg ~ {{i}}, data = mtcars) ``` mtcars データセット内の mpg に対する他の変数全てを一つ一つ使った線型回帰モデルを構築できます. ```{r, echo=FALSE, results=&#39;asis&#39;} src = lapply(setdiff(names(mtcars), &#39;mpg&#39;), function(i) { knitr::knit_expand(&#39;template.Rmd&#39;) }) res = knitr::knit_child(text = unlist(src), quiet = TRUE) cat(res, sep = &#39;\\n&#39;) ``` この例が難しくて理解できないと感じたら, チャンクオプション results = 'asis' の意味を知るのに11.11節を, knitr::knit_child() の使用法を知るのに16.4節を見てください. "],["duplicate-label.html", "14.8 コードチャンクにラベルの重複を許可する (*)", " 14.8 コードチャンクにラベルの重複を許可する (*) knitr はデフォルトでは文書内でチャンクラベルが重複することを許可しません. 重複するラベルは文書を knit する際にエラーを引き起こします. これは文書内でコードチャンクをコピーアンドペーストするときに最もよく起こります. あなたもこのようなエラーメッセージにでくわしたことがあるかもしれません. processing file: myfile.Rmd Error in parse_block(g[-1], g[1], params.src, markdown_mode) : Duplicate chunk label &#39;cars&#39; Calls: &lt;Anonymous&gt; ... process_file -&gt; split_file -&gt; lapply -&gt; FUN -&gt; parse_block Execution halted しかし, 重複するラベルを許可したいこともあるというものです. 例えば親文書 parent.Rmd があり, その中で子文書を複数回 knit すれば, 失敗するでしょう. # 設定 settings &lt;- list(...) # 1度目の実行 knit_child(&quot;useful_analysis.Rmd&quot;) # 新しい設定 settings &lt;- list(...) # 再実行 knit_child(&quot;useful_analysis.Rmd&quot;) この筋書きでは, 子文書が knit される前に R のグローバルオプションを設定することでラベルの重複を許可できます. options(knitr.duplicate.label = &quot;allow&quot;) 子文書ではなくメインの文書でラベルの重複を許可したいなら, knitr::knit() が呼び出される前に設定しなければなりません. それを実現する可能性の1つとして, ~/.Rprofile ファイル内で設定するという方法があります (詳細は ?Rprofile のヘルプを見てください). このオプションの設定は注意深くすべきです. ほとんどのエラーメッセージは, それなりの理由があってこそ存在します. 重複するチャンクを許可することは図や相互参照に関して気が付かないうちに問題を生み出す可能性があります. 例えば, グラフ画像のファイル名はチャンクラベルによって決まるので, 2つのコードチャンクが同じラベルを持ち, かつ両方のチャンクが図を生成しているなら, 理論上はこれらの画像ファイルは互いに上書きすることになります (そしてエラーも警告も発しません). knitr は knitr.duplicate.label = \"allow\" オプションがあると, 重複するラベルに暗黙に数字の接頭語を追加して変更しています. 例えば, 2つのコードチャンクに対してはこうなります. ```{r, test} plot(1:10) ``` ```{r, test} plot(10:1) ``` 2つ目のラベルは暗黙のうちに test-1 に変更されます. これはラベル test のチャンクからのグラフ画像を上書きすることを回避するかもしれませんが, 同時にチャンクラベルが予想できなくなります. ということは, 図の相互参照 (4.7節参照) も相互参照がチャンクラベルに基づいているので難しくなるでしょう. "],["cache-rds.html", "14.9 より透明性のあるキャッシュの仕組み", " 14.9 より透明性のあるキャッシュの仕組み 11.4節で紹介した knitr のキャッシュの仕組みが複雑すぎると思ったら (実際そうです!), xfun::cache_rds() 関数に基づいた, より簡単なキャッシュの仕組みを検討してください. これが例です. xfun::cache_rds({ # ここに時間のかかるコードを書く }) knitr のキャッシュは, キャッシュの無効化のタイミングがどう決定されるかという点が難解なのです. xfun::cache_rds() においては, これはずっと明確です. 最初に R コードをこの関数に与えたときは, コードが評価され結果が .rds ファイルに保存されます. 次に cache_rds() を再実行すると, .rds ファイルを読み込み, コードを再び評価することなく直ちに結果を返します. キャッシュを無効化する最も明確な方法は, .rds ファイルを削除することです. 手動で削除したくないなら, xfun::cache_rds() に rerun = TRUE 引数を付けて呼び出します. knitr のソース文書上のコードチャンクで xfun::cache_rds() が呼び出された時, .rds ファイルのパスはチャンクオプション cache.path とチャンクラベルによって決定します. 例えば input.Rmd という Rmd 文書に foo というチャンクラベルのあるコードチャンクがあるとします. ```{r, foo} res &lt;- xfun::cache_rds({ Sys.sleep(3) 1:10 }) ``` .rds ファイルのパスは input_cache/FORMAT/foo_HASH.rds という形式になります. ここで FORMAT は Pandoc の出力フォーマット名 (例えば html あるいは latex) であり, HASH は a-z および 0-9 からなる32桁の16進 MD5 ハッシュ値です. 例えば input_cache/html/foo_7a3f22c4309d400eff95de0e8bddac71.rds のようになります. ?xfun::cache_rds のヘルプで言及されているように, キャッシュを無効化したいであろう2つのよくあるケースがあります. (1) 評価式が変更された時, (2) 評価式の外部の変数が使用され, その変数の値が変更された時です. 次に, この2つのキャッシュ無効化の方法がどう動作するのかと, 異なるコードのバージョンに対応する複数のキャッシュのコピーをどう保持するかを説明します. 14.9.1 コードの変更によってキャッシュを無効化する 例えば cache_rds({x + 1}) から cache_rds({x + 2}) へと, cache_rds() 内のコードを変更したとき, キャッシュは自動で無効化され, コードは再評価されます. しかし, 空白やコメントの変更は問われないことに注意してください. あるいは一般論として, パースされた表現に影響のない範囲の変更ではキャッシュは無効化されません. 例えば cache_rds() にパースされた以下2つのコードは本質的に同等です. res &lt;- xfun::cache_rds({ Sys.sleep(3 ); x&lt;-1:10; # セミコロンは問題ではない x+1; }) res &lt;- xfun::cache_rds({ Sys.sleep(3) x &lt;- 1:10 # これはコメント x + 1 # 空白の変更は完全に自由 }) つまり, 最初のコードを cache_rds() で実行したなら, 2度目のコードはキャッシュの利便性を得られます. この仕様のおかげでキャッシュを無効化することなくコードの見た目を整える変更ができます. 2つのバージョンのコードが同等であるか自信がないなら, 以下の parse_code() を試してください. parse_code &lt;- function(expr) { deparse(substitute(expr)) } # 空白とセミコロンは影響しない parse_code({x+1}) ## [1] &quot;{&quot; &quot; x + 1&quot; &quot;}&quot; parse_code({ x + 1; }) ## [1] &quot;{&quot; &quot; x + 1&quot; &quot;}&quot; # 左アロー演算子と右アロー演算子は同等 identical(parse_code({x &lt;- 1}), parse_code({1 -&gt; x})) ## [1] TRUE 14.9.2 グローバル変数の変更によってキャッシュを無効化する 変数にはグローバルとローカル変数の2種類があります. グローバル変数は評価式の外部で作られ, ローカル変数は評価式の内部で作られます. キャッシュされた結果は, 評価式内のグローバル変数の値が変われば, もはや再度実行して得られるはずの結果を反映していません. 例えば以下の評価式で, y が変化したなら, あなたが一番やりたいのはきっと, キャッシュを無効化して評価をやり直すことでしょう. さもなければ古い y の値を維持したままになってしまいます. y &lt;- 2 res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }) y が変化した時にキャッシュを無効化するには, キャッシュを無効化すべきかを決定する際に y も考慮する必要があることを, hash 引数を通して cache_rds() に教えてあげることもできます. res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }, hash = list(y)) hash 引数の値が変化した時, 前述のキャッシュファイル名に含まれる32桁のハッシュ値も対応して変化するため, キャッシュは無効化されます. これで他の R オブジェクトとキャッシュの依存関係を指定する手段を得ました. 例えば R のバージョンに依存してキャッシュを取りたいなら, このようにして依存関係を指定することもできます. res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }, hash = list(y, getRversion())) あるいはデータファイルが最後に修正されたタイミングに依存させたいなら, こうします. res &lt;- xfun::cache_rds({ x &lt;- read.csv(&quot;data.csv&quot;) x[[1]] + y }, hash = list(y, file.mtime(&quot;data.csv&quot;))) hash 引数にこのグローバル変数のリストを与えたくなければ, 代わりに hash = \"auto\" を試しましょう. これは cache_rds() に全てのグローバル変数を自動的に把握するよう指示し, 変数の値のリストを hash 引数の値として使わせます. res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y + z # y と z はグローバル変数 }, hash = &quot;auto&quot;) これは以下と同等です. res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y + z # y と z はグローバル変数 }, hash = list(y = y, z = z)) hash = \"auto\" とした時, グローバル変数は codetools::findGlobals() によって識別されます. これは完全に信頼できるものではありません. あなたのコードを一番良く知っているのはあなた自身ですので, hash 引数には明示的に値のリストを指定して, どの変数がキャッシュを無効化できるかを万全にすることをお薦めします. 14.9.3 キャッシュの複数のコピーを保持する キャッシュは典型的には時間のかかるコードに対して使用されるので, きっとあなたは無効化することに対して躊躇するでしょう. キャッシュを無効化するのが早すぎたり, 積極的すぎたりしたことを後悔するかもしれません. もし古いバージョンのキャッシュが再び必要になったら, 再現のために長い計算時間を待たなければなりませんから. cache_rds() の clean 引数を FALSE に設定すれば, キャッシュの古いコピーを保持できます. R のグローバルオプション options(xfun.cache_rds.clean = FALSE) の設定で, この挙動を R セッション全体を通したデフォルトにもできます. デフォルトでは, clean = TRUE と cache_rds() は毎回, 古いキャッシュを削除しようと試みます. clean = FALSE の設定は, まだコードを試行錯誤しているうちは有用になりえます. 例えば, 2つのバージョンの線形モデルのキャッシュを取ることができます. model &lt;- xfun::cache_rds({ lm(dist ~ speed, data = cars) }, clean = FALSE) model &lt;- xfun::cache_rds({ lm(dist ~ speed + I(speed^2), data = cars) }, clean = FALSE) どちらのモデルを使うかを決めたら, clean = TRUE を再度設定するか, この引数を消すことでデフォルトの TRUE に戻すことができます. 14.9.4 knitr のキャッシュ機能との比較 knitr キャッシュ, つまりチャンクオプション cache = TRUE と, xfun::cache_rds() をそれぞれいつ使えばよいのか迷っているかもしれません. xfun::cache_rds() の最大の欠点は, 評価式の値のみをキャッシュしそれ以外の結果をキャッシュしないことです. その一方で knitr は評価式以外の値についてもキャッシュを取ります. 出力やグラフを表示するといった評価式以外の結果には有用なものもあります. 例えば以下のコードでは, cache_rds() が次にキャッシュを読み込んだ時には, テキスト出力とグラフが失われてしまい, 1:10 という値だけが戻ってきます. xfun::cache_rds({ print(&quot;Hello world!&quot;) plot(cars) 1:10 }) これと比較してオプション cache = TRUE のあるコードチャンクでは, 全てがキャッシュされます. ```{r, cache=TRUE} print(&quot;Hello world!&quot;) plot(cars) 1:10 ``` knitr のキャッシュ機能の大きな欠点であると同時にユーザーが最もよく不満の対象とするのは, キャッシュがとても多くの要因で決まるため, 知らないうちに無効化してしまうことがある点です. 例えば, チャンクオプションのいかなる変更もキャッシュを無効化する可能性がありますが,40 演算に影響しないであろうチャンクオプションもあります. 以下のコードチャンクでチャンクオプション fig.width = 6 を fig.width = 10 へと変更してもキャッシュを無効化すべきではありませんが, 実際は無効化してしまいます. ```{r, cache=TRUE, fig.width=6} # there are no plots in this chunk x &lt;- rnorm(1000) mean(x) ``` 実際に knitr のキャッシュはかなり強力で柔軟であり, 多くの方法で挙動を調整できます. あなたはキャシュがどう動作するのかを学び理解するのに, 最終的に計算するタスクの所要時間よりもはるかに多くの時間を費やしてしまうかもしれません. ですので私はパッケージの作者として, これらのあまり知られていない機能は紹介するに値するのかと, 疑問に思うことがよくあります. まだはっきりわからない人は, xfun::cache_rds() は演算をキャッシュする一般的な方法でありどこでも動作しますが, 一方の knitr のキャッシュは knitr 文書でのみ動作すると覚えてください. これはデフォルトの挙動であり, 変更することができます. より細かい粒度でキャッシュを生成し, 全てのチャンクオプションがキャッシュに影響しないようにするには, https://gedevan-aleksizde.github.io/knitr-doc-ja/cache.html をご覧ください.↩︎ "],["other-languages.html", "15 その他の言語", " 15 その他の言語 R Markdown は knitr を通して R 言語以外の多くのプログラミング言語をもサポートしています. 言語の名前は3連続のバッククオートの後のカーリーブレースの最初の単語で表現されます. 例えば ```{r} の小文字の r はコードチャンクに R のコードが含まれていることを意味し, ```{python} は Python のコードチャンクであることを表しています. この章ではあなたがあまり詳しくないであろういくつかの言語をお見せします. knitr では, どの言語も言語エンジンを通してサポートされています. 言語エンジンは本質的にはソースコードとコードチャンクを入力として, 出力として文字列を返す関数です. これらは knitr::knit_engines オブジェクトで管理されています. 既存のエンジンはこのようにして確認することもできます. names(knitr::knit_engines$get()) ## [1] &quot;awk&quot; &quot;bash&quot; &quot;coffee&quot; &quot;gawk&quot; ## [5] &quot;groovy&quot; &quot;haskell&quot; &quot;lein&quot; &quot;mysql&quot; ## [9] &quot;node&quot; &quot;octave&quot; &quot;perl&quot; &quot;psql&quot; ## [13] &quot;Rscript&quot; &quot;ruby&quot; &quot;sas&quot; &quot;scala&quot; ## [17] &quot;sed&quot; &quot;sh&quot; &quot;stata&quot; &quot;zsh&quot; ## [21] &quot;highlight&quot; &quot;Rcpp&quot; &quot;tikz&quot; &quot;dot&quot; ## [25] &quot;c&quot; &quot;cc&quot; &quot;fortran&quot; &quot;fortran95&quot; ## [29] &quot;asy&quot; &quot;cat&quot; &quot;asis&quot; &quot;stan&quot; ## [33] &quot;block&quot; &quot;block2&quot; &quot;js&quot; &quot;css&quot; ## [37] &quot;sql&quot; &quot;go&quot; &quot;python&quot; &quot;julia&quot; ## [41] &quot;sass&quot; &quot;scss&quot; &quot;R&quot; &quot;bslib&quot; ## [45] &quot;targets&quot; 現時点では, R 言語でないほとんどの言語はコードチャンクごとに独立して実行されます. 例えば, 同じ文書内の bash コードチャンクは全てそれぞれ別々のセッションで実行されるため, 後の bash コードチャンクはそれ以前の bash チャンクで作成された変数を使うことができませんし, cd による作業ディレクトリの変更も異なる bash チャンク間で維持できません. R, Python, そして Julia のコードチャンクのみが同一セッションで実行されます. 全ての R コードチャンクは同一の R セッションで実行され, 全ての Python コードチャンクは同一の Python セッションされ……, ということに注意してください. R セッションと Python セッションは2つの異なるセッションですが, 一方のセッションからもう一方のセッションのオブジェクトにアクセスしたり操作したりすることは可能です (15.2節参照). R Markdown Definitive Guide (Xie, Allaire, and Grolemund 2018) の Section 2.7 では Python, シェル, SQL, Rcpp, Stan, JavaScript, CSS, Julia, C そして Fortran のコードを使用する例が紹介されています. この章ではさらなる言語エンジンを紹介します. そしてさらなる例はリポジトリ https://github.com/yihui/knitr-examples で見られます. “engine” という単語を含むファイルを探してください. 初めに, カスタム言語エンジンの登録によってこれがどのように動作するかを解明しましょう. 参考文献 "],["custom-engine.html", "15.1 カスタム言語エンジンを登録する (*)", " 15.1 カスタム言語エンジンを登録する (*) knitr::knit_engines$set() でカスタム言語エンジンを登録できます. これは関数を入力として受け容れます. これが例です. knitr::knit_engines$set(foo = function(options) { # ソースコードは options$code にある # それを使ってやりたいことは何でもやろう }) これは foo エンジンを登録し, ```{foo} で始まるコードチャンクを使えるようになります. エンジン関数は1つの引数 options を取り, これはコードチャンクのオプションのリストです. options$code にある文字列ベクトルとして, チャンクのソースコードにアクセスできます. 例えば, このコードチャンクに対して考えます. ```{foo} 1 + 1 2 + 2 ``` options の code 要素は文字列ベクトル c('1 + 1', '2 + 2') になります. 言語エンジンは実はプログラミング言語として動作しなくてもよいですが, コードチャンクの任意のテキストを処理できます. まずは, コードチャンクの本文を大文字に変換するエンジンの例をお見せします. knitr::knit_engines$set(upper = function(options) { code &lt;- paste(options$code, collapse = &quot;\\n&quot;) if (options$eval) toupper(code) else code }) ポイントは toupper 関数を「コード」に適用して, \\n でコードの全ての行を連結し, 単一の文字列として結果を返すことです. toupper() はチャンクオプション eval = TRUEの時にのみ適用され, そうでなければ元の文字列が返されることに注意してください. このことは eval のようなチャンクオプションをエンジン関数内で利用する方法を示唆しています. 同様に, results = 'hide' の時に出力を隠すため, 関数内に if (options$results == 'hide') return() を加えることも検討することもできます. 以下は upper エンジンをオプションとともに使用するチャンクの例です. ```{upper} Hello, **knitr** engines! ``` HELLO, KNITR ENGINES! 次に, py という名前のもう1つの Python エンジン41の例を紹介します. このエンジンは単純に R の system2() 関数から python コマンドを呼び出すことで実装しています. knitr::knit_engines$set(py = function(options) { code &lt;- paste(options$code, collapse = &#39;\\n&#39;) out &lt;- system2( &#39;python3&#39;, c(&#39;-c&#39;, shQuote(code)), stdout = TRUE ) knitr::engine_output(options, code, out) }) 上記のエンジン関数を完全に理解するために, 以下を知っておく必要があります. Python コードは文字列として与えられ (上記関数の code), コードはコマンドラインの呼び出し python -c 'code' によって実行できます. これが system2() のしていることです. system2() stdout = TRUE を指定することでテキスト出力を収集しています. 最終的な出力を生成するため, チャンクオプション・ソースコード・テキスト出力を knitr::engine_output() 関数に与えることができます. この関数は echo = FALSE と results = 'hide' のようなよく使うオプションを処理します. よってあなたはこれらの場合に注意する必要はありません. knitr の多くの言語エンジンはこのようにして定義されています. つまり system2() を使って言語に対応するコマンドを実行してます. もし技術的に詳しい話に興味があるなら, R ソースコードにはほとんどの言語エンジンが書かれているここ https://github.com/yihui/knitr/blob/master/R/engine.R を確認することもできます. そして今や, 新しいエンジン py を使うことができます. 例えばこのように. ```{py} print(1 + 1) ``` ## 2 あなたのバージョンの言語エンジンが knitr の既存の言語エンジンよりも必要性がるか, より良いものだと確信しているなら, knitr::knit_engines$set() によって既存のものを上書きすることすらできます. たいていの場合は既存のエンジンに慣れたユーザーが驚いてしまうかもしれないので, そうすることはお薦めしませんが, どちらにせよこの可能性は頭の片隅に置いてほしいです. 実用的には組み込みの python エンジンを使うべきです. これは reticulate パッケージに基づいており, より良く Python コードチャンクをサポートしてくれます (15.2節参照).↩︎ "],["eng-python.html", "15.2 Python コードの実行と双方向処理", " 15.2 Python コードの実行と双方向処理 あなたが Python を好んでいることは知っていますので, とてもはっきりと言ってしまいましょう. R Markdown と knitr はなんと Python をサポートしています. Python のコードチャンクを R Markdown 文書に加えるには チャンクヘッダ ```{python} を使うことができます. 例えばこのように. ```{python} print(&quot;Hello Python!&quot;) ``` いつもどおりにチャンクヘッダに echo = FALSE or eval = FALSE といったチャンクオプションを追加することができます. Python の matplotlib パッケージで描かれたグラフもサポートしています. R Markdown と knitr の Python サポートは reticulate パッケージ (Ushey, Allaire, and Tang 2021) に基づいており, このパッケージの重要な機能の1つは Python と R の双方向的なコミュニケーションを可能にすることです. 例えば reticulate の py オブジェクトを介して R セッションから Python の変数にアクセスしたり作成したりすることもできます. ```{r, setup} library(reticulate) ``` Python セッションで変数 `x` を作成する ```{python} x = [1, 2, 3] ``` R コードチャンクで Python 変数 `x` にアクセスする ```{r} py$x ``` R を使って Python セッションで新しい変数 `y` を作成し, `y` にデータフレームを与える ```{r} py$y &lt;- head(cars) ``` Python で変数 `y` を表示する ```{python} print(y) ``` reticulate パッケージに関する詳細については, https://rstudio.github.io/reticulate/ のドキュメントを見ることもできます. 参考文献 "],["eng-asis.html", "15.3 asis エンジンでコンテンツを条件付きで実行する", " 15.3 asis エンジンでコンテンツを条件付きで実行する その名が示すとおり, asis エンジンはチャンクの内容をそのまま書き出します. このエンジンを使う利点は条件に応じてコンテンツを読み込めることです. つまりチャンクオプション echo によりチャンクの内容の表示を決定します. echo = FALSE の時はチャンクは隠されます. 以下は簡単な例です. ```{r} getRandomNumber &lt;- function() { sample(1:6, 1) } ``` ```{asis, echo = getRandomNumber() == 4} https://xkcd.com/221/ によれば, **真の**乱数を生成しました! ``` asis チャンク内のテキストは条件式 getRandomNumber() == 4 が (ランダムに) 真であるならば表示されます. "],["eng-bash.html", "15.4 シェルスクリプトを実行する", " 15.4 シェルスクリプトを実行する あなたが好んでいるシェルに応じて, bash ・ sh ・ zsh エンジンでシェルスクリプトを実行できます. 以下はチャンクヘッダ ```{bash} を使った bash の例です. ls *.Rmd | head -n 5 ## index.Rmd ## rmarkdown-cookbook.Rmd bash は R の system2() 関数で呼び出されていることに注意してください. ~/.bash_profile や ~/.bash_login のようなプロファイルにある, あなたの定義したコマンドのエイリアスや PATH などの環境変数は無視されます. ターミナル上でシェルを使っている時のようにこれらのプロファイルがほしいなら, engine.opts を介して -l 引数を与えることもできます. これが例です. ```{bash, engine.opts=&#39;-l&#39;} echo $PATH ``` -l 引数を全ての bash チャンクで有効にしたいなら, 文書の冒頭でグローバルチャンクオプションに設定することもできます. knitr::opts_chunk$set(engine.opts = list(bash = &quot;-l&quot;)) チャンクオプション engine.opts に文字列ベクトルとして他の引数を bash に与えることもできます. "],["d3.html", "15.5 D3 で可視化する", " 15.5 D3 で可視化する R のパッケージ r2d3 (Strayer, Luraschi, and Allaire 2020) は D3 可視化のインターフェースです. このパッケージは例えば Shiny のような他のアプリケーションと同様に R Markdown 文書内で使うことができます. R Markdown 内で使うにはコードチャンクで r2d3() 関数を呼び出すか, d3 エンジンを使用することができます. 後者は D3 ライブラリと Javascript の理解が要求されますが, それは本書で扱う範囲を超えますので, 読者自身による学習に任せます. 以下は d3 エンジンで棒グラフを描く例です. --- title: &quot;D3 でグラフを生成する&quot; output: html_document --- 最初に, **r2d3** パッケージを読み込み **knitr** が自動で `d3` エンジンをセットアップしてくれるようにします ```{r setup} library(r2d3) ``` ここで R でデータを生成して D3 に渡してグラフを描画できます. ```{d3, data=runif(30), options=list(color=&#39;steelblue&#39;)} svg.selectAll(&#39;rect&#39;) .data(data) .enter() .append(&#39;rect&#39;) .attr(&#39;width&#39;, function(d) { return d * 672; }) .attr(&#39;height&#39;, &#39;10px&#39;) .attr(&#39;y&#39;, function(d, i) { return i * 16; }) .attr(&#39;fill&#39;, options.color); ``` 参考文献 "],["eng-cat.html", "15.6 cat エンジンでチャンクをファイルに書き出す", " 15.6 cat エンジンでチャンクをファイルに書き出す コードチャンクの内容を外部ファイルに書き出し, 以降の他のコードチャンクで使用するのは時には有用である可能性があります. もちろん, writeLines() のような R の関数で行っても良いですが, 内容が比較的長かったり, 特殊な文字が含まれていたり, writeLines() に渡したい文字列がごちゃごちゃしたりしているかもしれません. 以下は 長い文字列を my-file.txt に書き出す例です. writeLines(&quot;これは長い文字列です. 複数行にわたります. ダブルクオート \\&quot;\\&quot; は 忘れずにエスケープしてください. ですが &#39;シングルクオート&#39; は大丈夫です. バックスラッシュがいくつ必要か考えるときにあなたが 正気を失わないでいられることを願います. 例えば, &#39;\\t&#39; なのか `\\\\t` なのか &#39;\\\\\\\\t&#39; なのか?&quot;, con = &quot;my-file.txt&quot;) R 4.0.0 以降では r\"()\" 内での生の文字列 (?Quotes のヘルプ参照) がサポートされ始めたので, 特殊文字のルールを全て覚える必要はなくなり, この問題は大いに緩和されました. 生の文字列があってもなお, チャンク内で長い文字列を明示的にファイルに書き出すことは読者の注意力を少しばかり削ぐ可能性があります. knitr の cat エンジンは, 例えばバックスラッシュのリテラルが必要な時は, 二重バックスラッシュが必要といった, R の文字列ルールを一切考えることなく, コードチャンクの内容の表示かつ/または外部ファイルへの書き出しの方法を提供してくれます. チャンクの内容をファイルに書き出すには, チャンクオプション engine.opts にファイルパスを指定してください. 例えば engine.opts = list(file = 'path/to/file') のように. この内部では, engine.opts で指定された値のリストが base::cat() に渡されます. そして file は base::cat() の引数の1つです. 次に, cat エンジンの使い方の詳しい説明のため3つの例を提示します. 15.6.1 CSS ファイルへ書き込む 7.3節でお見せしたように, 要素を CSS でスタイル設定するために css コードチャンクを Rmd 文書に埋め込むことができます. 別の方法として, カスタム CSS ファイルを, html_document のようないくつかの R Markdown 出力フォーマットで有効な css オプションを介して Pandoc に渡す方法もあります. cat エンジンはこの CSS ファイルを Rmd から書き込むのに使用できます. 以下の例は文書のチャンクから custom.css ファイルを生成し, そのファイルパスを html_document フォーマットの ccs オプションに渡す方法を示しています. --- title: &quot;コードチャンクから CSS ファイルを作成する&quot; output: html_document: css: custom.css --- 以下のチャンクは `custom.css` へ書き込まれ, ファイルは Pandoc の変換時に使われます. ```{cat, engine.opts = list(file = &quot;my_custom.css&quot;)} h2 { color: blue; } ``` ## そしてこの見出しは青くなります css コードチャンクのアプローチとこのアプローチの唯一の違いは, 前者が CSS コードをその場に書き込む, つまりコードチャンクのあるまさにその場所に書き込み, そしてそこは出力文書の &lt;body&gt; タグの内側ですが, 後者は CSS を出力文書の &lt;head&gt; の領域に書き込みます. 出力文書の見た目に実用上の違いは一切生じません. 15.6.2 LaTeX コードをプリアンブルに含める 6.1節では, LaTeX コードをプリアンブルに追加する方法を紹介しました. これには 外部の .tex ファイルが必要でした. このファイルもまた Rmd から生成することができます. これがその例です. --- title: &quot;チャンクから .tex ファイルを作成する&quot; author: &quot;Jane Doe&quot; documentclass: ltjsarticle classoption: twoside output: pdf_document: latex_engine: lualatex includes: in_header: preamble.tex --- # どのように動作するか 出力する PDF のヘッダとフッタを定義するために コードチャンクを `preamble.tex` に書き出しましょう. ```{cat, engine.opts=list(file = &#39;preamble.tex&#39;)} \\usepackage{fancyhdr} \\usepackage{lipsum} \\pagestyle{fancy} \\fancyhead[CO,CE]{これは fancy header} \\fancyfoot[CO,CE]{そしてこれは fancy footer} \\fancyfoot[LE,RO]{\\thepage} \\fancypagestyle{plain}{\\pagestyle{fancy}} ``` \\lipsum[1-15] # さらに適当なコンテンツ \\lipsum[16-30] 上記の cat コードチャンク内の LaTeX コードで, PDF 文書のヘッダとフッタを定義しました. フッタに著者名も表示したいなら, 別の cat コードチャンクにオプション engine.opts = list(file = 'preamble.tex', append = TRUE) と code = sprintf('\\\\fancyfoot[LO,RE]{%s}', rmarkdown::metadata$author) を付けることで preamble.tex に著者情報を追加することができます. このチャンクの動作を理解するには, この節の最初の方で紹介した engine.opts が base::cat() に渡されるということを思い出してください. つまり append = TRUE は cat() に渡されます. そして チャンクオプション code はこの後の16.2節を読めば理解できるでしょう. 15.6.3 YAML データをファイルに書き込みつつ表示する cat コードチャンクの中身はデフォルトでは出力文書に表示されません. 中身を書き出した後で表示もしたいならば,チャンクオプション class.source に言語名を指定してください. 言語名はシンタックスハイライトに使われます. 以下の例では, 言語名を yaml に指定しています. ```{cat, engine.opts=list(file=&#39;demo.yml&#39;), class.source=&#39;yaml&#39;} a: aa: &quot;something&quot; bb: 1 b: aa: &quot;something else&quot; bb: 2 ``` その出力を以下に表示し, そしてファイル demo.yml としても生成します. a: aa: &quot;something&quot; bb: 1 b: aa: &quot;something else&quot; bb: 2 ファイル demo.yml が実際に生成されたことを示すには, yaml パッケージ (Stephens et al. 2020) で読み込んでみることができます. xfun::tree(yaml::read_yaml(&quot;demo.yml&quot;)) ## List of 2 ## |-a:List of 2 ## | |-aa: chr &quot;something&quot; ## | |-bb: int 1 ## |-b:List of 2 ## |-aa: chr &quot;something else&quot; ## |-bb: int 2 参考文献 "],["eng-sas.html", "15.7 SAS コードを実行する", " 15.7 SAS コードを実行する あなたは sas エンジン で SAS (https://www.sas.com) を実行するかもしれません. あなたの環境変数 PATH に SAS の実行ファイルがあることを確認するか, (PATH の意味を知らないなら) チャンクオプション engine.path に実行ファイルのフルパスを与える必要があります. 例えば engine.path = \"C:\\\\Program Files\\\\SASHome\\\\x86\\\\SASFoundation\\\\9.3\\\\sas.exe\" のように. 以下は “Hello World” を表示する例です. ```{sas} data _null_; put &#39;Hello, world!&#39;; run; ``` "],["eng-stata.html", "15.8 Stata コードを実行する", " 15.8 Stata コードを実行する Stata をインストールしているなら, stata エンジンで Stata のコードを実行できます. stata 実行ファイルが環境変数 PATH から見つけられないかぎり, チャンクオプション engine.path を介して実行ファイルのフルパスを指定する必要があります. 例えば engine.path = \"C:/Program Files (x86)/Stata15/StataSE-64.exe\" のように. 以下は簡単な例です. ```{stata} sysuse auto summarize ``` knitr の stata エンジンの機能はかなり限定的です. Doug Hemken が Statamarkdown パッケージでこれを実質的に拡張しており, GitHub の https://github.com/Hemken/Statamarkdown で利用可能です. “Stata R Markdown” でオンライン検索することでパッケージのチュートリアルを見つけられるでしょう. "],["eng-asy.html", "15.9 Asymptote でグラフィックを作成する", " 15.9 Asymptote でグラフィックを作成する Asymptote (https://asymptote.sourceforge.io) はベクタグラフィックのための強力な言語です. Asymptote をインストール済みなら (インストールの説明はウェブサイトを見てください) asy エンジンを使い R Markdown に Asymptote のコードを書き実行することもできます. 以下はそのリポジトリ https://github.com/vectorgraphics/asymptote からコピーした例で, 出力を図15.1に示します. import graph3; import grid3; import palette; settings.prc = false; currentprojection=orthographic(0.8,1,2); size(500,400,IgnoreAspect); real f(pair z) {return cos(2*pi*z.x)*sin(2*pi*z.y);} surface s=surface(f,(-1/2,-1/2),(1/2,1/2),50,Spline); surface S=planeproject(unitsquare3)*s; S.colors(palette(s.map(zpart),Rainbow())); draw(S,nolight); draw(s,lightgray+opacity(0.7)); grid3(XYZgrid); 図 15.1: Asymptote で作成した3Dグラフィック PDF 出力に対しては追加の LaTeX パッケージが必要であることに注意してください. そうでないとこのようなエラーが出ることでしょう. ! LaTeX Error: File `ocgbase.sty&#39; not found. このようなエラーが発生したなら, 欠けている LaTeX パッケージのインストール方法を1.3節で確認してください. 上記の asy チャンクでは, settings.prc = false という設定を使いました. この設定がないと Asymptote は PDF 出力時にインタラクティブな 3D グラフィックを表示してしまいます. しかしインタラクティブなグラフィックは Acrobat Reader でのみ見ることができます. Acrobat Reader を使用しているなら, グラフを操作できます. 例えば図15.1ではマウス操作で3D平面を回転できます. 15.9.1 R でデータを生成し Asymptote に読み込ませる ここでは, 最初に以下の R コードチャンクのように, R で生成したデータを CSV ファイルに保存します. x &lt;- seq(0, 5, l = 100) y &lt;- sin(x) writeLines(paste(x, y, sep = &quot;,&quot;), &quot;sine.csv&quot;) それから Asymptote でこれを読み込み, データに基づいたグラフを描画し図15.2 に示します. 以下が asy コードチャンクです. import graph; size(400,300,IgnoreAspect); settings.prc = false; // import data from csv file file in=input(&quot;sine.csv&quot;).line().csv(); real[][] a=in.dimension(0,0); a=transpose(a); // generate a path path rpath = graph(a[0],a[1]); path lpath = (1,0)--(5,1); // find intersection pair pA=intersectionpoint(rpath,lpath); // draw all draw(rpath,red); draw(lpath,dashed + blue); dot(&quot;$\\delta$&quot;,pA,NE); xaxis(&quot;$x$&quot;,BottomTop,LeftTicks); yaxis(&quot;$y$&quot;,LeftRight,RightTicks); 図 15.2: R からデータを渡し Asymptote でグラフを描く "],["eng-sass.html", "15.10 Sass/SCSS で HTML ページをスタイリングする", " 15.10 Sass/SCSS で HTML ページをスタイリングする Sass (https://sass-lang.com) は CSS を拡張した言語で, 基本的な CSS で行っていた のよりはるかに柔軟な方法でルールを作成できます. これを学ぶことに関心があるなら, 公式ドキュメントを見てください. R パッケージの sass (Cheng et al. 2021) は SaSS を CSS にコンパイルするのに使用できます. sass パッケージに基づいて, knitr はコードチャンクを CSS にコンパイルするため2つの言語エンジン, sass and scss を読み込みます. Sass と SCSS の構文は互いに対応しているためです. 以下はチャンクヘッダが ```{scss} である scss コードチャンクです. $font-stack: &quot;HGS創英角ﾎﾟｯﾌﾟ体&quot;, &quot;Comic Sans MS&quot;, cursive, sans-serif; $primary-color: #00FF00; .book.font-family-1 { font: 100% $font-stack; color: $primary-color; } ﻿.book.font-family-1{font:100% \"HGS創英角ﾎﾟｯﾌﾟ体\",\"Comic Sans MS\",cursive,sans-serif;color:lime} sass エンジンも使うことができます. Sass 構文は SCSS 構文とわずかに異なります. 例えばこのように. ```{sass} $font-stack: &quot;HGS創英角ﾎﾟｯﾌﾟ体&quot;, &quot;Comic Sans MS&quot;, cursive, sans-serif $primary-color: #00FF00 .book.font-family-1 font: 100% $font-stack color: $primary-color ``` あなたがこのセクションの HTML 版を読んでいるなら, このページのフォントが Comic Sans に変化したことに気付くでしょう. これには驚いたかもしれませんが, パニックにならないでください, あなたは脳卒中になどなっていません. sass/scss コードチャンクは sass::sass() 関数によってコンパイルされます. 現在はチャンクオプション engine.opts で CSS コードの出力スタイルをカスタマイズできます. 例えば engine.opts = list(style = \"expanded\") のように. デフォルトのスタイルは “compressed” です. これが何を意味するのか自信がないなら, ?sass::sass_options のヘルプを参照し, output_style 引数の項目を探してください. 参考文献 "],["managing-projects.html", "16 プロジェクトを管理する", " 16 プロジェクトを管理する 大きなプロジェクトやレポートの作業をしている時には, 1つの R Markdown 文書の中に全てのテキストとコードを置かず, 代わりに小さな単位に分けたものをうまくまとめたいでしょう. この章では, R Markdown と関係する複数のファイルをまとめる方法を紹介します. "],["source-script.html", "16.1 外部の R スクリプトを実行する", " 16.1 外部の R スクリプトを実行する もし R Markdown 文書に大量のコードがあるなら, 以下の例のように, コードの一部を外部 R スクリプトに配置し, source() か sys.source() 経由で実行するよう検討してください. ```{r, include=FALSE} source(&quot;your-script.R&quot;, local = knitr::knit_global()) # または sys.source(&quot;your-script.R&quot;, envir = knitr::knit_global()) ``` お薦めするやり方は, sys.source() の envir 引数または source() の local 引数を明示的に使い, コードが確実に適正な環境で評価されるようにすることです. これらのデフォルト値は適切な環境でないかもしれません. 間違った環境で変数を作成してしまい, その後のチャンクでオブジェクトが見つからず驚くということになりかねません. それから, R Markdown 文書の中で, これらのスクリプトで作成された, データや関数といったオブジェクトを使えるのです. このやり方は R Markdown 文書が簡潔になるだけでなく, R コードの開発がもっと便利になるという効果もあります. 例えば R コードのデバッグは, R Markdown より, ピュアな R スクリプトでやるほうがたいてい簡単です. 上記の例では include = FALSE を使っていることに注目してください. 出力を一切表示させずにスクリプトの実行するだけにしたいからです. 出力が欲しければこのチャンクオプションを削除するか, 11.7節で紹介したオプションを使って, 隠したり表示したりを出力の種類の違いによって選択することもできます. "],["option-code.html", "16.2 外部スクリプトをチャンク内で読み込む", " 16.2 外部スクリプトをチャンク内で読み込む 16.1節で紹介した source() の方法には欠点があります. それはデフォルトではソースコードを見ることができないという点です. source(..., echo = TRUE) を使うことはできますが, ソースコードのシンタックスがきちんとハイライトされません. 加えて16.1節で言及したように, source() の local 引数について注意を払う必要があります. この節ではこういった問題のない代わりになる方法を紹介します. 1つでも外部スクリプトがあれば, 基本的にはそれを読み込んで中身を, チャンクの code オプションに渡すことができます. code オプションは文字列ベクトルをとるので, それをコードチャンクの本文として扱えます. 以下に少しだけ例をお見せします. code オプションはソースコードを文字列ベクトルとして取ることができます. これが例です. ```{r, code=c(&#39;1 + 1&#39;, &#39;if (TRUE) plot(cars)&#39;)} ``` 外部ファイルを読み込むこともできます. ```{r, code=xfun::read_utf8(&#39;your-script.R&#39;)} ``` ファイルを好きな数だけ読み込むこともできます. ```{r, include=FALSE} read_files &lt;- function(files) { unlist(lapply(files, xfun::read_utf8)) } ``` ```{r, code=read_files(c(&#39;one.R&#39;, &#39;two.R&#39;))} ``` 他の言語のスクリプトも読み込めます. R Markdown で他の言語を使う方法は15章を確認してください. 以下に, もう少しだけ R 以外のコードの例をお見せします. Python スクリプトを読み込む. ```{python, code=xfun::read_utf8(&#39;script.py&#39;)} ``` C++ ファイルを読み込む: ```{Rcpp, code=xfun::read_utf8(&#39;file.cpp&#39;)} ``` code オプションがあれば, お気に入りのエディタ使って複雑なコードを開発した上で, それを R Markdown 文書のコードチャンクに読み込ませるということができます. "],["read-chunk.html", "16.3 外部スクリプトから複数のコードチャンクを読み込む (*)", " 16.3 外部スクリプトから複数のコードチャンクを読み込む (*) 16.2節では, コードを単一のチャンクに読み込む方法を紹介しました. この節では外部スクリプトから複数のチャンクを読み取る方法を1つ紹介します. ポイントは, スクリプト内のコードにラベルを付ける必要がありますが, 同じラベルを R Markdown 文書のコードチャンクにも使用できるという点です. つまり外部スクリプトのコードを knitr::read_chunk() 関数を介して各コードチャンクに展開できるのです. スクリプトのブロックにラベルを付けるには, ## ---- の後にラベルを書きます (行の終わりにも好きな数のダッシュ記号を続けることができます). 例えば次のように, 1つのスクリプトにはラベル付けされたブロックを複数含めることができます. ## ---- test-a -------- 1 + 1 ## ---- test-b -------- if (TRUE) { plot(cars) } 上記のスクリプトのファイル名が test.R であるとします. R Markdown 文書ではこれを knitr::read_chunk() 関数で読み込み, コードチャンク内ではそのコードをラベルで使えます. これが例です. 外部スクリプトを読み込む ```{r, include=FALSE, cache=FALSE} knitr::read_chunk(&#39;test.R&#39;) ``` これで, 例えばこのようにコードを使用できる ```{r, test-a, echo=FALSE} ``` ```{r, test-b, fig.height=4} ``` コードチャンクの副産物にも影響するというのが主な理由ですが knitr::read_chunk() を使っていることに注意してください. つまりこの関数を読み込んだコードチャンクがキャッシュされていないことを確認してください (この説明は11.4節参照). 16.1, 16.2節で紹介したように, この方法は別の環境でコード開発できるという柔軟性をもたらしてくれます. "],["child-document.html", "16.4 子文書 (*)", " 16.4 子文書 (*) R Markdown 文書が長過ぎると思った時は, 短い文書に分割することも考えると. そして, チャンクオプション child を使ってメイン文書に子文書として読み込ませましょう. child オプションは子文書のファイルパスを文字列ベクトルとして取ります. 例えばこのように. ```{r, child=c(&#39;one.Rmd&#39;, &#39;two.Rmd&#39;)} ``` knitr のチャンクオプションは任意の R コードから値を取ることができるので, child オプションの応用として条件付で文書を読み込ませる方法があります. 例えばあなたのレポートの中に, 上司が関心を持たないような技術的に詳細な補足文書があるなら, この変数を使えばその補足文書をレポートに含むかどうかを制御できます. あなたのボスにレポートを読ませるなら `BOSS_MODE` を `TRUE` に変える ```{r, include=FALSE} BOSS_MODE &lt;- FALSE ``` 条件付きで補足文書を読み込む ```{r, child=if (!BOSS_MODE) &#39;appendix.Rmd&#39;} ``` あるいはまだ始まってないフットボールの試合の速報レポートを書いているなら, 試合結果に応じて異なる子文書を読み込むようにすることもできます. 例えば child = if (winner == 'ブラジル') 'ブラジル.Rmd' else 'ドイツ.Rmd' のように. これで試合 (ここではドイツ対ブラジル) が終わり次第すぐに, レポートを提出できます. 子文書をコンパイルする別の方法として, knitr::knit_child() 関数があります. この関数は R コードチャンク内部またはインライン R コードで呼び出せます. 例えばこのように. ```{r, echo=FALSE, results=&#39;asis&#39;} res &lt;- knitr::knit_child(&#39;child.Rmd&#39;, quiet = TRUE) cat(res, sep = &#39;\\n&#39;) ``` knit_child() 関数は knit された子文書の文字列ベクトルを返します. これは cat() とチャンクオプション results = \"asis\" を使ってメインの文書に還元することができます. テンプレートとして子文書を使うこともできますし, 毎回異なるパラメータを与えつつ何度でも knit_child() を呼び出すこともできます. 以下の例では mtcars データの mpg を従属変数, そして残りの変数を説明変数として使った回帰分析を実行しています. ```{r, echo=FALSE, results=&#39;asis&#39;} res &lt;- lapply(setdiff(names(mtcars), &#39;mpg&#39;), function(x) { knitr::knit_child(text = c( &#39;## &quot;`r x`&quot; への回帰&#39;, &#39;&#39;, &#39;```{r}&#39;, &#39;lm(mpg ~ ., data = mtcars[, c(&quot;mpg&quot;, x)])&#39;, &#39;```&#39;, &#39;&#39; ), envir = environment(), quiet = TRUE) }) cat(unlist(res), sep = &#39;\\n&#39;) ``` 上記の例を自己完結的なものにするために, knit_child() にファイルを入力するのではなく text 引数に R Markdown コンテンツを渡しました. もちろんファイルにコンテンツを書き出し, knit_child() にファイルパスを渡すこともできます. 例えば以下のコンテンツを template.Rmd という名前のファイルに保存します. ## &quot;`r x`&quot; への回帰 ```{r} lm(mpg ~ ., data = mtcars[, c(&quot;mpg&quot;, x)]) ``` そして代わりにファイルを knit します. res &lt;- lapply(setdiff(names(mtcars), &#39;mpg&#39;), function(x) { knitr::knit_child( &#39;template.Rmd&#39;, envir = environment(), quiet = TRUE ) }) cat(unlist(res), sep = &#39;\\n&#39;) "],["keep-files.html", "16.5 グラフ画像ファイルを残す", " 16.5 グラフ画像ファイルを残す ほとんどの R Markdown 出力フォーマットはデフォルトで self_contained = TRUE オプションを使用しています. これは出力文書に R グラフを埋め込むので, 出力文書を閲覧する時の中間ファイルは必要ありません. その結果, グラフ画像のフォルダ (典型的には _files という接尾語があります) は Rmd 文書がレンダリングされた後に削除されます. ときにはグラフ画像ファイルを残したいことがあります. 例えば学術誌の中には, 画像ファイルを別個に提出するよう著者に求めるものもあります. R Markdown ではこれらのファイルの自動削除を回避する3通りの方法があります. 出力フォーマットがサポートしていれば, 以下のように self_contained = FALSE オプションを使う. output: html_document: self_contained: false しかし, この方法ではグラフ画像ファイルが出力文書に埋め込まれません. それを望まなければ, 次の2つの方法を検討しましょう. 最低いずれか1つのコードチャンクでキャッシュ (11.4節参照) を有効にする. キャッシュが有効な時は R Markdown は画像フォルダを削除しません. 出力フォーマットがサポートしていれば, 以下のように keep_md = TRUE オプションを使用する. output: word_document: keep_md: true R Markdown に対し Markdown 中間出力ファイルを保存するよう指示した時, 同時に画像フォルダも保存されます. "],["working-directory.html", "16.6 R コードチャンク用の作業ディレクトリ", " 16.6 R コードチャンク用の作業ディレクトリ R コードチャンクの作業ディレクトリは, デフォルトでは Rmd 文書のあるディレクトリです. 例えば Rmd ファイルのパスが ~/Downloads/foo.Rmd であるなら, R コードチャンクが評価される作業ディレクトリは ~/Downloads/ になります. ということは, チャンク内で外部ファイルを相対パスで参照するとき, そのパスは Rmd ファイルのあるディレクトリからの相対パスであることを知っておくべきことを意味します. 前述の Rmd ファイルの例では, コードチャンク内での read.csv(\"data/iris.csv\") は ~/Downloads/data/iris.csv から CSV ファイルを読み込むことを意味しています. よく分からない時は, getwd() をコードチャンクに追加して文書をコンパイルし, getwd() の出力を確認できます. 時には他のディレクトリを作業ディレクトリとして使いたいこともあります. 一般的な作業ディレクトリの変更方法は setwd() ですが, setwd() は R Markdown あるいは他の knitr ソース文書で一貫して使えるわけではないことに注意してください. これは setwd() が現在のコードチャンクに限って動作し, 作業ディレクトリはこのコードチャンクが評価された後に元に戻ることを意味します. 全てのコードチャンクに対して作業ディレクトリを変更したい場合, 文書の冒頭で setup コードチャンクを設定できます. ```{r, setup, include=FALSE} knitr::opts_knit$set(root.dir = &#39;/tmp&#39;) ``` これは以降の全てのコードチャンクの作業ディレクトリを変更します. RStudio を使用しているなら, 作業ディレクトリをメニュの Tools -&gt; Global Options -&gt; R Markdown からも選択できます (図16.1参照). デフォルトの作業ディレクトリは Rmd ファイルのディレクトリで, 他に2つの選択肢があります. “Current” オプションで R コンソールの現在の作業ディレクトリを使うか, “Project” オプションで Rmd ファイルが入っているプロジェクトのルートディレクトリを作業ディレクトリとして使うこともできます. 図 16.1: R Studio で R Markdown 文書用のデフォルトの作業ディレクトリを変更する RStudio では, 図16.2で見せるように, 個別の Rmd 文書をそれぞれ固有の作業ディレクトリで knit することもできます. “Knit Directory” を変更し “Knit” ボタンをクリックした後で, knitr は新しい作業ディレクトリを使ってコードチャンクを評価します. これらの全ての設定は既に言及した knitr::opts_knit$set(root.dir = ...) に集約されています. よってあなたがこれまでの選択肢のいずれにも満足しないのなら, knitr::opts_knit$set() を使いご自分でディレクトリを指定できます. 図 16.2: RStudio の他の使用可能な作業ディレクトリで Rmd 文書を knit する 作業ディレクトリに関して完全に正しい選択というものはありません. それぞれに長所と短所があります. (knitr のデフォルト) Rmd 文書のディレクトリをコードチャンクの作業ディレクトリとして使うなら, ファイルパスは Rmd 文書からの相対パスだと想定していることになります. これは ウェブブラウザで相対パスを扱うのと似ています. 例えば https://www.example.org/path/to/page.html という HTML ページでの画像 &lt;img src=\"foo/bar.png\" /&gt; に対して, ウェブブラウザが https://www.example.org/path/to/foo/bar.png から画像を取得するのと似ています. 言い換えるなら, 相対パス foo/bar.png は HTML ファイルのあるディレクトリ https://www.example.org/path/to/ からの相対位置です. このアプローチの利点は Rmd ファイルを Rmd ファイルが参照しているファイルと一緒に, 相対的な位置関係を保っている限りどこへでも自由に移動できることです. 上記の HTML ページと画像の例では, page.html と foo/bar.png を https://www.example.org/another/path/ へ一緒に移動させることができます. そしてあなたは &lt;img /&gt; の src 属性の相対パスを更新する必要はありません. Rmd 文書の相対パスを「Rmd ファイルからの相対位置」とは対照的に「Rコンソールの作業ディレクトリからの相対位置」と考えるのを好むユーザもいます. よって knitr のデフォルトディレクトリは混乱を招きます. 私が knitr を設計する際に R コンソールの作業ディレクトリをデフォルトで使わないようにした理由は, ユーザがいつでも setwd() で作業ディレクトリを変更したければできてしまうからでした. この作業ディレクトリが安定している保証はありません. 毎度のようにユーザが setwd() をコンソールで呼び出すと, Rmd 文書内のファイルパスが無効になるリスクがあります. ファイルパスが Rmd ファイルの制御の手から離れて setwd() という外部要因に依存しているというのは不自然なことでしょう. 相対パスを考慮する際に, Rmd ファイルを「宇宙の中心」として扱えば, Rmd ファイル内にあるパスはもっと安定するでしょう. その上, あなたが相対パスを考慮するのが難しすぎて嫌だと言うなら, 図16.3のように RStudio 上で自動補完機能を使ってファイルパスを入力することもできます. RStudio は Rmd ファイルからの相対パスを補完しようと試みます. R コンソールの作業ディレクトリはプログラミング的あるいは対話的に文書を knit するのに良い選択になりうるでしょう. 例えばループ中に文書を複数回 knit し, そこで毎回で異なる作業ディレクトリを使い, 各々のディレクトリ内の異なるデータファイル(ファイル名は同じとします) を読み込むこともできます. この種の作業ディレクトリは ezknitr パッケージ (Attali 2016) で推奨されており, 実は knitr::opts_knit$set(root.dir) を使って knitr のコードチャンクの作業ディレクトリを変更しています. プロジェクトディレクトリを作業ディレクトリとして使うことには明確な前提が要求されます. そもそもプロジェクト (例えば RStudio のプロジェクトか, バージョン管理プロジェクト) を使わなければならないということです. この点はアプローチにとっての欠点となりえます. この種の作業ディレクトリを使う利点はあらゆる Rmd 文書内の全ての相対パスがプロジェクトのルートディレクトリからの相対パスになることです. よってプロジェクト内で Rmd ファイルがどこにあるかを考えたり, 他のファイルの場所に対応して調整したりする必要はありません. この種の作業ディレクトリは here パッケージ (Müller 2020) で推奨されており, このパッケージでは渡された相対パスを解決し絶対パスを返す here::here() 関数を提供しています (相対パスはプロジェクトのルートからの相対であることを忘れないでください). 欠点となるのは, 参照されているファイルを Rmd ファイルとともにプロジェクト内の他の場所に移動させた時に, Rmd 文書内の参照パスを更新する必要があることです. Rmd ファイルを他の人と共有する時は, プロジェクト全体も共有しなければなりません. これらの種類のパスは HTML でのプロトコルやドメインのない絶対パスと似ています. 例えば https://www.example.org/path/to/page.html というページの画像 &lt;img src=\"/foo/bar.png\" /&gt; はウェブサイトのルートディレクトリ以下の画像を参照しています. つまり https://www.example.org/foo/bar.png です. 画像の src 属性の先頭の / はウェブサイトのルートディレクトリを表しています. HTML の絶対パスと相対パスについてもっと学びたい (あるいはもっと混乱したい) なら, blogdown 本の Appendix B.1 (Xie, Hill, and Thomas 2017) を見てください. 作業ディレクトリのうんざりする問題は, ほとんどの場合, 相対パスに対処している時に抱く 「 何に対して相対的なの? 」という疑問に端を発します. 既に言及したように, いろいろな人がいろいろな好みを持っており, 完全に正しい回答はありません. 図 16.3: RStudio 上で Rmd 文書のファイルパスを自動補完する 参考文献 "],["package-vignette.html", "16.7 R パッケージのビネット", " 16.7 R パッケージのビネット R パッケージの開発を経験したか, プロジェクトで自作関数の明瞭なドキュメントや厳格なテストが要求されたなら, プロジェクトを R パッケージと結びつけてみてはどうでしょうか. R パッケージの作り方が分からないなら, RStudio IDE でメニューバーの File -&gt; New Project をクリックし, プロジェクトの種類に R パッケージを選ぶことで簡単に始めることができます. プロジェクトの管理に R パッケージを使うことには多くの利益があります. 例えば data/ フォルダにデータを置き, R/ に R コードを書き, 例えば roxygen2 パッケージ (Wickham, Danenberg, et al. 2021) を使用して, ドキュメントを man/ に生成し, test/ には単体テストを追加できます. R Markdown のレポートなら vignette/ にパッケージのビネットとして書くことができます. ビネット内ではデータセットを読み込みパッケージ内の関数を呼び出せます. (R CMD build コマンドか RStudio で) パッケージをビルドする時に, ビネットは自動でコンパイルされます. R Markdown でパッケージのビネットを作成するのに最も簡単な方法は, RStudio のメニュー File -&gt; New File -&gt; R Markdown -&gt; From Templateを経由するものです (図16.4参照). それから rmarkdown パッケージから “Package Vignette” を選択すると, ビネットのテンプレートが得られます. テンプレートの, タイトル・著者・その他のメタデータを変更したら, レポートの本文を書き始めましょう. 図 16.4: RStudio でパッケージのビネットを作成する 他の方法としては, usethis (Wickham and Bryan 2021) をインストールし usethis::use_vignette() 関数を使ってビネットのスケルトンを作成できます. 以下はパッケージのビネットの YAML フロントマターの典型的な姿です. --- title: &quot;ビネットのタイトル&quot; author: &quot;ビネットの著者&quot; output: rmarkdown::html_vignette vignette: &gt; %\\VignetteIndexEntry{ビネットのタイトル} %\\VignetteEngine{knitr::rmarkdown} %\\VignetteEncoding{UTF-8} --- title フィールドと \\VignetteIndexEntry{} コマンドの両方で, ビネットのタイトルを変更しなければならないことに注意してください. 上記のビネット情報の他にも, パッケージの DESCRIPTION ファイルにさらに2つすべきことがあります. DESCRIPTION ファイルに VignetteBuilder: knitr を指定する. DESCRIPTION ファイルに Suggests: knitr, rmarkdown を追加する. ビネット出力フォーマットは HTML でなくてもかまいません. PDF でも可能なので, output: pdf_document も使えます. 他の出力フォーマットでも beamer_presentation や tufte::tufte_html のような, HTML か PDF を作成するものであればどれも大丈夫です. ただし, 現時点では R は HTML と PDF のビネットのみを認識します. 参考文献 "],["package-template.html", "16.8 R パッケージの R Markdown テンプレート", " 16.8 R パッケージの R Markdown テンプレート 16.7節の図16.4では, 編集可能なパッケージビネットの HTML テンプレートを rmarkdown パッケージから取得する手順を表しています. この R Markdown ファイルには R パッケージのビネットを作るに当たっての適切なメタデータが詰め込まれています. 同様に, どのような R パッケージであっても, R Markdown テンプレートを同梱して, (この図で示しているように) ユーザが RStudio IDE を通してアクセスしたり, あるいはどのプラットフォーム上でも rmarkdown::draft() 関数でアクセスできるようにするとよいでしょう. 16.8.1 テンプレートのユースケースTemplate use-cases テンプレートはカスタマイズされた文書構造・スタイル・コンテンツを共有するのに便利な方法です. 多くのすばらしい例が世に出回っています. 多くのテンプレートは入力済みのメタデータによって文書構造とスタイルを追加しています. すでに rmarkdown パッケージの (HTML の) ビネットテンプレートを例としてお見せしました. 同様に, rmdformats パッケージ (Barnier 2021) では様々なカスタムスタイル関数を output オプションに渡すテンプレートがいくつも提供されています. その他のテンプレートではパッケージで必要になる文書の構文を例示しているものがあります. 例えば pagedown パッケージ (Xie et al. 2021) はポスター・履歴書・その他のページレイアウト用に無数のテンプレートを同梱しています. 同様に xaringan パッケージ (Xie 2021f) の忍者風のプレゼンテーションテンプレートは様々なスライドフォーマットのオプションに対する構文を例示しています. テンプレートによってはパッケージの機能と構文を例示していることもあります. 例えば flexdashboard パッケージ (Iannone, Allaire, and Borges 2020) と learnr (Schloerke, Allaire, and Borges 2020) パッケージには, サンプルのダッシュボートとチュートリアルをそれぞれ作成するために, パッケージから関数を呼び出すコードチャンク付きのテンプレートを同梱しています. 同様に, テンプレートには定型的なコンテンツの雛形を含んでいるものもあります. 例えば rticles パッケージ (Allaire, Xie, Dervieux, et al. 2021) にはたくさんテンプレートがあって, R Markdown 出力を様々な学術誌で要求されるスタイルとガイドラインに沿って調整できます. コンテンツの雛形は, 四半期レポートを作成するチームのようなところで組織的に設定する際にも便利です. 16.8.2 テンプレートの準備 usethis パッケージ (Wickham and Bryan 2021) にはテンプレートの作成に役に立つ関数があります. usethis::use_rmarkdown_template(\"テンプレート名\") を実行すると, 必要なディレクトリ構造とファイルが自動で作成されます. テンプレート名は自分で付けましょう. 代わりに自分のテンプレートを手動で準備したいなら, inst/rmarkdown/templates のサブディレクトリを作成してください. このディレクトリ内に, 少なくとも2つのファイルを保存する必要があります. template.yaml という名前のファイル. これは RStudio IDE に対して, 人間が判読できるテンプレートの名称などの基本的なメタデータを与えます. 例えば以下のように 最低でも, このファイルは name と description フィールドを持っているべきです. name: テンプレートの例 description: このテンプレートが何をするか テンプレートが選択された時に新しいディレクトリを作成してほしいなら, create_dir: true を含めることもできます. 例えば learnr パッケージのテンプレートは create_dir: true を設定しており, 一方で flexdashboard パッケージのテンプレート はデフォルトの create_dir: false を使用しています. これらのテンプレートを RStudio で開いてみると, 様々なユーザの意図に気付くはずです. skeleton/skeleton.Rmd 内に保存された R Markdown 文書ファイル. これは R Markdown 文書に挿入したいどのようなコンテンツでも含めることができます. オプションとして, skeleton フォルダにはスタイルシートや画像といった, 作ったテンプレートで使われる追加のリソースを含めることができます. これらのファイルはテンプレートとともにユーザのコンピュータに読み込まれます. R Markdown のカスタムテンプレートを作るためのさらに詳細な情報は, RStudio Extensions と R Markdown Definitive Guide (Xie, Allaire, and Grolemund 2018) の Document Templates の章 を参照してください. 参考文献 "],["bookdown.html", "16.9 bookdown で本や長いレポートを書く", " 16.9 bookdown で本や長いレポートを書く bookdown パッケージ (Xie 2021a) は複数の R Markdown 文書で構成される長い文書を作成できるように設計されています. 例えば本を執筆したいなら, 章ごとに別々の Rmd ファイルに書き, bookdown を使ってこれらのファイルを本にコンパイルできます. RStudio ユーザーにとって最も簡単な始め方は, 図16.5にあるように, IDE 上で File -&gt; New Project -&gt; New Directory -&gt; Book Project using bookdown を選んで bookdown プロジェクトを作成することです. RStudio を使っていないか, コンソールから作業するのが好きなら, bookdown:::bookdown_skeleton('本のディレクトリ') 関数を呼べば同じものが作れます. 図 16.5: RStudio で bookdown プロジェクトを作成する 使用法を実演するために, 同じディレクトリに3つのファイルを含めた最低限の例を用意しました. directory |- index.Rmd |- 01-導入.Rmd |- 02-分析.Rmd 以下に各ファイルの中身とそれぞれの役目を示します. index.Rmd: --- title: &quot;最低限の bookdown プロジェクト&quot; site: bookdown::bookdown_site output: bookdown::gitbook --- # はじめに {-} なにか書く 最初のファイルは典型的には index.Rmd と呼ばれます. YAML フロントマターを与える唯一の Rmd ファイルとなるべきです. また, 特殊な YAML フィールド, site: bookdown::bookdown_site を含めて, bookdown を使うべきことを rmarkdown に知らせることで, 単一の Rmd ファイルをレンダリングするのではなく, 全ての Rmd ファイルをビルドさせます. bookdown::gitbook ・ bookdown::pdf_book ・ bookdown::word_document2 ・ bookdown::epub_book といったどのような bookdown 出力フォーマットでも使えます. 次の2つの Rmd ファイルは2つの章になります. 01-導入.Rmd: # 第1章 これは第1章です. 02-分析.Rmd: # 第2章 これは第2章です. これらの Rmd ファイルをレンダリングするためには, rmarkdown::render() の代わりに bookdown::render_book('index.Rmd') を呼ぶべきです. その内部では, デフォルトで bookdown が全ての Rmd ファイルを1つの Rmd に結合し, コンパイルします. ファイルは名前順に結合されます. 上記の例でファイル名の頭に数字を付けたのはそれが理由です. bookdown プロジェクトをカスタマイズできる設定は多くあります. bookdown のより包括的な概要として, rmarkdown 本 (Xie, Allaire, and Grolemund 2018) の Chapter 18 を読んでください. 完全なドキュメントは bookdown 本 (Xie 2016) になります. 参考文献 "],["blogdown.html", "16.10 blogdown でウェブサイトを構築する", " 16.10 blogdown でウェブサイトを構築する R Markdown に基づいたウェブサイトを構築したいなら, blogdown パッケージ (Xie, Dervieux, and Presmanes Hill 2021) の使用を検討しするとよいでしょう. 最も簡単な始め方は図16.5にあるように RStudio メニューから File -&gt; New Project -&gt; New Directory -&gt; Website using blogdown を選ぶことです. これまで blogdown を使ったことがないのなら, ダイアログボックスのデフォルト設定を使うとよいでしょう. そうでないなら, ウェブサイトのテーマのような項目をカスタマイズできます. RStudio を使用していないのなら, 空のディレクトリで blogdown::new_site() 関数を呼び出せば, 新しいウェブサイトが作れます. ウェブサイトのプロジェクトには Rmd 文書をいくつ含めてもかまいません. これらは通常のページか, ブログの記事にできます. あなたのウェブサイトに表示されるものは自動的かつ動的に生成されるので, R Markdown があれば簡単に自分のウェブサイトを管理できるようになります. ウェブサイトの管理の基本的なワークフローとこのパッケージの概要については, blogdown 本 (Xie, Hill, and Thomas 2017) の Chapter 1 を読むことをお薦めします. 参考文献 "],["workflow.html", "17 ワークフロー", " 17 ワークフロー この章では R Markdown プロジェクトの運用のみならず個別の R Markdown 文書で作業する際の豆知識を紹介します. R for Data Science42 (Wickham and Grolemund 2016a) の Chapter 30 も確認するとよいでしょう. ここには (R Markdown 文書を含む) 分析ノートの使用に関する豆知識が簡単に紹介されています. Nicholas Tierney も R Markdown for Scientists. でワークフローについて議論しています. 参考文献 "],["rstudio-shortcuts.html", "17.1 RStudio のキーボード・ショートカットを使う", " 17.1 RStudio のキーボード・ショートカットを使う R・ rmarkdown パッケージ・Pandoc がインストールされているかぎり, R Markdown のフォーマットはあなたの選ぶどんなテキストエディタでも使用できます. しかし, RStudioは R Markdownと深く統合されているので, 円滑に R Markdown を使って作業できます. あらゆる IDE (統合開発環境) と同じく, RStudio にはキーボード・ショートカットがあります. 完全な一覧はメニューの Tools -&gt; Keyboard Shortcuts Help で見られます. R Markdown に関連する最も便利なショートカットを表17.1にまとめました. 表 17.1: R Markdown に関連する RStudio のキーボード・ショートカット Task Windows &amp; Linux macOS R チャンクを挿入 Ctrl+Alt+I Command+Option+I HTML をプレビュー Ctrl+Shift+K Command+Shift+K 文書を knit する (knitr) Ctrl+Shift+K Command+Shift+K Notebook をコンパイル Ctrl+Shift+K Command+Shift+K PDF をコンパイル Ctrl+Shift+K Command+Shift+K ここから上のチャンクをすべて実行 Ctrl+Alt+P Command+Option+P このチャンクを実行 Ctrl+Alt+C Command+Option+C このチャンクを実行 Ctrl+Shift+Enter Command+Shift+Enter 次のチャンクを実行 Ctrl+Alt+N Command+Option+N 全てのチャンクを実行 Ctrl+Alt+R Command+Option+R 次のチャンクかタイトルへ移動 Ctrl+PgDown Command+PgDown 前のチャンクかタイトルへ移動 Ctrl+PgUp Command+PgUp 文書のアウトラインを表示/隠す Ctrl+Shift+O Command+Shift+O 本, ウェブサイトその他のビルド Ctrl+Shift+B Command+Shift+B 加えて, F7 キーを押してあなたの文書のスペルチェックがができます. Ctrl + Alt + F10 (macOS では Command + Option + F10) で R セッションを再起動することもできます. 新しい R セッションから演算するほうが結果はより再現性が高いため, 定期的に再起動することは再現性の確保に役立ちます. これはドロップダウンメニューの Run ボタンの後ろに隠れている, “Restart R and Run All Chunks” を使ってもできます. "],["spell-check.html", "17.2 R Markdown のスペルチェック", " 17.2 R Markdown のスペルチェック RStudio IDE を使っているなら, F7 キーを押すかメニューの Edit -&gt; Check Spelling をクリックして Rmd 文書のスペルチェックができます. リアルタイムなスペルチェックは RStudio v1.3 で使えるようになったので, これ以降のバージョンならば手動でスペルチェックを動作させる必要はなくなりました. RStudio を使っていないなら, spelling パッケージ (Ooms and Hester 2020) に spell_check_files() 関数があります. これは R Markdown を含む一般的な文書フォーマットのスペルチェックができます. Rmd 文書のスペルチェック時は, コードチャンクはスキップされテキストのみチェックされます. 参考文献 "],["rmarkdown-render.html", "17.3 rmarkdown::render() で R Markdown をレンダリングする", " 17.3 rmarkdown::render() で R Markdown をレンダリングする RStudio あるいは他の IDE を使用していないなら, 次の事実を知っておくべきでしょう. R Markdown 文書は rmarkdown::render() 関数によってレンダリングされているのです. つまり, あらゆる R スクリプト内でプログラミングによって R Markdown 文書をレンダリングできることを意味します. 例えば, for ループで連続した調査レポートを州ごとにレンダリングできます. for (state in state.name) { rmarkdown::render( &#39;input.Rmd&#39;, output_file = paste0(state, &#39;.html&#39;) ) } 出力ファイル名は州ごとに異なります. 州を state 変数にして input.Rmd 文書の中で使うこともできます. これが例です. --- title: &quot;`r state` に関するレポート&quot; output: html_document --- `r state` の面積は `r state.area[state.name == state]` 平方マイルである. ?rmarkdown::render のヘルプを読むと他にも使える引数を知ることができます. ここではそれらのうち clean と envir 引数の2つだけを紹介しようと思います. 前者の clean は Pandoc の変換がうまくいかない時のデバッグに特に役立ちます. rmarkdown::render(..., clean = FALSE) を呼び出すと, .md ファイルを含め, .Rmd ファイルから knit された全ての中間ファイルが維持されます. Pandoc がエラーを発していたらこの .md ファイルからデバッグを始めることもできます.. 後者の envir は rmarkdown::render(..., envir = new.env()) を呼び出した時に, 確実に空の新しい環境で文書をレンダリングする方法を提供してくれます. つまりコードチャンク内で作成されたオブジェクトはこの環境内にとどまり, あなたの現在のグローバル環境を汚すことがありません. 一方で, Rmd 文書を新しい R セッションでレンダリングして, いま開いている R セッションのオブジェクトがあなたの Rmd 文書を汚さないようにしたいのであれば, この例のように rmarkdown::render in xfun::Rscript_call() を呼び出せばよいでしょう. xfun::Rscript_call( rmarkdown::render, list(input = &#39;my-file.Rmd&#39;, output_format = &#39;pdf_document&#39;) ) この方法は RStudio で Knit ボタンをクリックする方法と似ています. これも同様に新しい R セッションで Rmd 文書をレンダリングします. Rmd 文書を他の Rmd 文書内でレンダリングする必要がある場合は, コードチャンクで直接 rmarkdown::render() を呼び出すのではなく, 代わりにこちらの方法を使うことを強く勧めます. なぜなら rmarkdown::render() は内部で多くの副産物をもたらし, さらにそれらに依存関係があることから, 同じ R セッションで他の Rmd 文書をレンダリングするのに影響を及ぼすことがあるからです. xfun::Rscript_call() の第2引数は rmarkdown::render() に渡す引数のリストを取ります. 実は xfun::Rscript_call は汎用的な関数で, 新しい R セッションで任意の R 関数（引数はオプション）を呼び出します. 関心があるならヘルプページをご覧になってください. "],["parameterized-reports.html", "17.4 パラメータ化されたレポート", " 17.4 パラメータ化されたレポート 17.3節では for ループ内で一連のレポートをレンダリングする方法を1つ紹介しました. 実際には rmarkdown::render() はこのタスクのために設計された params という名前の引数を持っています. この引数を通じてレポートをパラメータ化することができます. レポート用のパラメータを指定した時は, レポート内でparams 変数が使えます. 例えば, 以下を呼び出したとします. for (state in state.name) { rmarkdown::render(&#39;input.Rmd&#39;, params = list(state = state)) } それから input.Rmd 内部では, オブジェクト params が state 変数を持つリストになります. --- title: &quot;`r params$state` に関するレポート&quot; output: html_document --- `r params$state` の面積は `r state.area[state.name == params$state]` 平方マイルである. レポートに対してパラメータを指定する別の方法として, YAML フィールドで params を使うという手もあります. 例えばこのように. --- title: パラメータ化されたレポート output: html_document params: state: ネブラスカ州 year: 2019 midwest: true --- YAML の params フィールドまたは rmarkdown::render() の params 引数には, いくつでもパラメータを含められることに注目してください. YAML のフィールドと rmarkdown::render() の引数とが両方あるときには, render() の引数の値が対応する YAML フィールドの値を上書きしてしまいます. 例えば先ほどの params フィールドを使った例で rmarkdown::render(..., params = list(state = 'アイオワ州', year = 2018) を呼び出した場合は, R Markdown 文書上の params$state は ネブラスカ州 の代わりに アイオワ州 に, params$year は 2019 の代わりに 2018 になります. 同じ R Markdown 文書を一連のレポート群へとレンダリングする時は, 各レポートのファイル名が一意になるように rmarkdown::render() の output_file 引数を調整する必要があります. そうでないと, うっかりレポートファイルを上書きしてしまいます. 例えば, 各州の各年ごとにレポートを生成できる関数を書きます. render_one &lt;- function(state, year) { # input.Rmd の出力フォーマットが PDF と仮定 rmarkdown::render( &#39;input.Rmd&#39;, output_file = paste0(state, &#39;-&#39;, year, &#39;.pdf&#39;), params = list(state = state, year = year), envir = parent.frame() ) } そして for ループをネストして全てのレポートを生成します. for (state in state.name) { for (year in 2000:2020) { render_one(state, year) } } 最終的に, アラバマ州-2000.pdf, アラバマ州-2001.pdf, …, ワイオミング州-2019.pdf, and ワイオミング州-2020.pdf のように一連のレポートを得られます. パラメータ化されたレポートであれば, Shiny で作成されたグラフィカルユーザーインターフェイス (GUI) を通して対話的にパラメータを入力することも可能です. これは YAML に params フィールドを与えることが必要ですが, 各パラメータに対応する適切な入力ウィジェットを用いた GUI を rmarkdown が自動的に作成してくれます. 例えばチェックボックスはブーリアン型のパラメータに対して用意されます. RStudio を使用していないなら, rmarkdown::render() 呼び出して params = 'ask' を渡せば GUI を開始できます. rmarkdown::render(&quot;input.Rmd&quot;, params = &quot;ask&quot;) RStudio を使用しているなら, メニューの Knit ボタンの中にある Knit with Parameters をクリックすることが可能です. 図17.1はパラメータに対する GUI の例を示しています. 図 17.1: GUI から入力できるパラメータで R Markdown を knit する パラメータ化されたレポートの詳細については, R Markdown Definitive Guide (Xie, Allaire, and Grolemund 2018) の Chapter 15 を読むとよいでしょう. 参考文献 "],["custom-knit.html", "17.5 Knit ボタンをカスタマイズする (*)", " 17.5 Knit ボタンをカスタマイズする (*) RStudio の Knit ボタンをクリックすると, 新規の R セッション内で rmarkdown::render() が呼び出され, 同じディレクトリに入力ファイルと同じ基底名の出力ファイルが出力されます. 例えば出力フォーマット html_document で example.Rmd を knit すると, example.html というファイルが作られます. 文書がどうレンダリングされるかをカスタマイズしたいという状況もあるでしょう. 例えば今日の日付を文書に含めたり, コンパイルした文書を別のディレクトリに出力したいというときです. このようなことは適切な output_file 引数を付けて rmarkdown::render() を呼び出すことで実現できるのですが (17.3節参照) , レポートをコンパイルするのに rmarkdown::render() をいちいち呼び出すことに頼るのは不便かもしれません. 文書の YAML フロントマターで knit フィールドを与えれば Knit ボタンの挙動を制御できます. このフィールドは, 主要な引数 input（ 入力 Rmd 文書のパス）を伴って関数を取ってくれますが, 現時点では他の引数は無視されます. 関数のソースコードを直接 knit コードに書くことも, R パッケージなどどこか別の場所に関数を置いてそれを呼び出すことも可能です. カスタム knit 関数が日常的に必要ならば, 毎度のように R Markdown 文書に関数のソースコードを繰り返し書くのではなく, パッケージに関数を置くことをお薦めします. YAML に直接ソースコードを置くなら, 関数全体をパーレン () で囲まなければなりません. ソースコードが複数行になるなら, 最初の行以外の全ての行にスペース2つ分のインデントをしなければなりません. 例えば出力ファイル名にレンダリングした日付を含めたい場合, 次のような YAML コードが使用可能です. --- knit: (function(input, ...) { rmarkdown::render( input, output_file = paste0( xfun::sans_ext(input), &#39;-&#39;, Sys.Date(), &#39;.html&#39; ), envir = globalenv() ) }) --- 例えば 2019/07/29 に example.Rmd を knit したなら, 出力ファイル名は example-2019-07-29.html となります. 上記のアプローチは単純で直截的ですが, 関数が R Markdown 文書で使われるのが1度限りでないと, YAML に直接関数を埋め込むのは管理が難しくなります. そこで例えばパッケージ内に knit_with_date() という関数を作成するとよいでしょう. #&#39; RStudio 用のカスタム knit 関数 #&#39; #&#39; @export knit_with_date &lt;- function(input, ...) { rmarkdown::render( input, output_file = paste0( xfun::sans_ext(input), &#39;-&#39;, Sys.Date(), &#39;.&#39;, xfun::file_ext(input) ), envir = globalenv() ) } 上記のコードを myPackage という名前のパッケージに追加すれば, 次のような YAML 設定を使いカスタム knit 関数を参照することが可能になります. --- knit: myPackage::knit_with_date --- ?rmarkdown::render のヘルプページを見て, Knit ボタンの背後にある knit 関数のカスタマイズについて, さらなるアイディアを見つけるのもよいでしょう. "],["google-drive.html", "17.6 trackdown で Google ドライブの Rmd 文書を共同編集する", " 17.6 trackdown で Google ドライブの Rmd 文書を共同編集する trackdown パッケージ (Kothe et al. 2021) は R Markdown (または Sweave) 文書の共同執筆・編集に対するシンプルなソリューションを提案してくれます. trackdown は googledrive パッケージ (D’Agostino McGowan and Bryan 2021) を基にして, ローカルの .Rmd (または .Rnw) ファイルをプレーンテキスト形式として Google ドライブにアップロードします. Markdown (あるいは LaTeX) の構文 の可読性のよさ43と Google ドキュメントの提案する広く普及しているオンラインのインターフェースという利点を活かすことで, 共同編集者たちは容易に執筆編集作業に貢献することができます. 全ての著者の貢献を統合したのち, 最終的な文書がローカルにダウンロードされレンダリングされます. trackdown は CRAN から, あるいは開発版を GitHub からインストールしてもいいでしょう. (https://github.com/claudiozandonella/trackdown): # install from CRAN install.packages(&quot;trackdown&quot;) # install the development version remotes::install_github(&quot;claudiozandonella/trackdown&quot;, build_vignettes = TRUE) 17.6.1 trackdown の作業工程 .Rmd (あるいは .Rnw) の共同での読み書き作業では, 異なるコンピュータのコードやナラティブを持つテキストを利用することが重要となります: コード - 共同作業でのコード執筆は伝統的な Git を下地にしたオンラインリポジトリ (GitHub や GitLab) を使用する工程に沿って, 最も効率的になされます. ナラティブ - ナラティブとしてのテキスト共同執筆は, 同じ文書を複数のユーザで同時編集できる, よく知られシンプルなオンラインインターフェースである Google ドキュメント の使用によって最も効率的になされます. したがって, この作業工程のイメージは単純です. .Rmd (または .Rnw) 文書をナラティブの共同編集のため Google ドキュメントとして Google ドライブにアップロードし, Git のバージョン管理と共同作業機能の力を利用しつつコードが機能し続けるようローカルに文書をダウンロードします. この Google ドライブへのアップロード/からのダウンロードの繰り返し作業は納得のいく成果物ができるまで続けられます (図17.2 参照). この作業工程はこのように要約できます. Git による コード の共同執筆と Google ドキュメント による ナラティブの共同執筆 作業工程の詳細な例は https://ekothe.github.io/trackdown/articles/trackdown-workflow.html を見てください. 図 17.2: trackdown の作業工程, コードの共同執筆は Git を使いローカルで行い, ナラティブの共同執筆は Google ドキュメントを使いオンラインで行う 関数と特別な機能 trackdown は作業工程の管理のために様々な関数を提供します. upload_file() は Google ドライブへ最初にファイルをアップロードする際に使います. update_file() は Google ドライブにアップロード済みのファイルをローカルファイルで更新します. download_file() はローカルファイルを, ダウンロードした Google ドライブのファイルの編集済みバージョンで更新します. render_file() はGoogle ドライブのファイルをダウンロードしローカルでレンダリングします. さらにそれ以外にも trackdown は Google ドキュメントの文書の共同執筆・編集を円滑にする機能を提案します. コードを隠す: 文書のヘッダにあるコード (YAML ヘッダや LaTeX プリアンブル) やコードチャンクは Google ドライブへのアップロード時に除去され, ダウンロード時まで自動保存されます. これによって共同編集者がコードをうっかり変更してファイルを破損してしまうのを防ぎ, ナラティブに意識を集中させることができます. 出力のアップロード: 実際の出力文書, つまりレンダリングされたファイルは Goodle ドライブに .Rmd (または .Rnw) ファイルとまとめてアップロードされます. これは共同編集者が図や表を含む全体のレイアウトを見通すのに役立ち, コメントの追加や変更の提案・議論を可能にします. Google ドライブの共有ドライブを使用する: 文書を個人用の Google ドライブにも, 共同作業促進のために共有ドライブにもアップロードできます. Google ドキュメントの利点 Google ドキュメントはユーザに親しみやすく直感的な, 無償の web ベースのインターフェースを提案しており, 複数ユーザが同時に同じ文書を編集することが可能です. Google ドキュメントでは以下が可能です. 変更箇所の追跡 (提案の採用・却下履歴を含む) 変更の提案と議論についてのコメントの追加 スペル・文法ミスのチェック (Grammarly のようなサードパーティのサービスとの統合も可能) さらに Google ドキュメントは誰でも文書の共同編集に貢献することが可能です. プログラミング経験も要求せず, ユーザは単にナラティブの編集にだけ集中することができます. 全ての共同編集者が Google アカウントを持つ必要がないことも知っておいてください (ただし Google ドキュメントの全ての機能を活用するために持っておくことをお勧めします). trackdown の作業工程を管理する人物だけが, ファイル Google ドライブにアップロードするためにアカウントを持つ必要があります. 共有リンクを使用して他の共同編集者を文書の編集に招待することができます. 参考文献 "],["workflowr.html", "17.7 workflowr で R Markdown プロジェクトを研究用サイトでまとめる", " 17.7 workflowr で R Markdown プロジェクトを研究用サイトでまとめる workflowr パッケージ (J. Blischak, Carbonetto, and Stephens 2020; J. D. Blischak, Carbonetto, and Stephens 2019)は (データ分析の) プロジェクトをテンプレートとバージョン管理ツールである GIT を使って体系的に編成することが可能です. プロジェクトに変更を加えるたびに, 変更の記録を残すことができるので, workflowr はプロジェクトの特定のバージョンと対応するウェブサイトを構築できます. これはあなたの分析結果の履歴をすべて閲覧できることを意味します. このパッケージはバージョン管理のためバックエンドで GIT を使用していますが, 特に GIT に詳しくなる必要はありません. このパッケージは, 内部で GIT の操作を行う R の関数を提供し, あなたはこれらの関数を呼び出せばいいだけです. そのうえ, workflowr は自動的に再現可能なコードへのベストプラクティスを自動化します. R Markdown 文書がレンダリングされるたびに, workflowr は set.seed() でシード値を設定, sessionInfo() でセッション情報を記録, そして絶対ファイルパスをスキャンする, などなど, といったことを自動的に行います. このパッケージの導入方法と詳細はパッケージのドキュメントをご覧ください. workflowr の主著者である John Blischak は, R プロジェクトのワークフローと関連のあるパッケージとガイドを網羅的ではないですがリストにまとめています. これは GitHub レポジトリ https://github.com/jdblischak/r-project-workflows で見ることができます. 参考文献 "],["blastula-email.html", "17.8 R Markdown から Eメールを送信する Send emails based on R Markdown", " 17.8 R Markdown から Eメールを送信する Send emails based on R Markdown blastula パッケージ (Iannone and Cheng 2020)があれば Rmd 文書を Eメールの本文にして送信できます. Rmd 文書を Eメールへレンダリングするには, 文書に出力フォーマット blastula::blastula_email を使用する必要があります. --- title: 週次レポート output: blastula::blastula_email --- ボスへ お疲れ様です. 以下が `iris` データの分析になります. ```{r} summary(iris) plot(iris[, -5]) ``` もううんざりだというのなら知らせていただきたく. よろしくお願いします ジョン この Rmd 文書は blastula::render_email() 関数でレンダリングされ, 出力は blastula::smtp_send() に渡されます. これはEメールを送信する関数です. smtp_send() にはEメールサーバとあなたの認証が必要であることに注意してください. RStudio Connect を使用しているなら, https://solutions.rstudio.com/r/blastula/ で, 自動化したもの, 条件付けたもの, パラメータ化したEメールを含め, さらなる例が見つかります. 参考文献 "],["参考文献.html", "参考文献", " 参考文献 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
