# コンセプトについての概論 {#conceptual-overview}

このテキストの目標は R Markdown を最大限活用するために多くの豆知識と小ワザを見せることです. 以降の各章ではより効率的で簡潔なコードを書き, 出力をカスタマイズする技術を実演します. これを始める前に, これらを理解し, 覚え, 応用し, 「リミックス」できる助けになるよう, R Markdown の動作がどうなっているかを少しだけ学んでおくと役に立つでしょう. この節では文書を knit する処理と出力を変更する「重要な切り替えレバー」について簡潔に概観します. この資料は後に続く章の内容理解に必要ではありません. 読み飛ばすのは自由です. しかし全てのピースをどう当てはめるかについて, より豊かなメンタルモデルを構築する助けになるかもしれません.

## レンダリング時に何が起こっているのか {#rmarkdown-process}

R Markdown はいくつかの異なるプロセスを合わせて文書を作成しています. これが R Markdown の全てのパーツがどう連動してるか理解するのに混乱する主な元凶です.^[Allison Horst が R Markdown の処理を魔法になぞらえたすばらしいイラストに描き出してくれました (https://github.com/allisonhorst/stats-illustrations/raw/master/rstats-artwork/rmarkdown_wizards.png). そして, この絵はまさに本書の扉絵に使われました.] 幸運にも, ユーザーが文書を作成できるようになるためにはこれらの処理の内部の挙動を全て理解することは必須ではありません. しかし, 文書の挙動を変えようとするだろうユーザーにとっては, どのパーツがどの挙動を担当しているかを理解することは重要です. あなたが検索する適切な範囲を絞れるようになれば, ヘルプを探すのがより簡単になります.

R Markdown 文書に対する基本的なワークフローの構造を図\@ref(fig:rmdworkflow)に示します. ステップ (矢印) と, 出力ファイルが生成される前に作成される中間ファイルを強調しています. 全ての処理は `rmarkdown::render()` 関数内に実装されています. 以降は各ステップを詳細に説明します.

```{r rmdworkflow, echo = FALSE, fig.cap = "R Markdown 文書がどのように最終的な出力文書に変換されるかを表すダイアグラム", out.width='100%'}
knitr::include_graphics(file.path(BOOKLANG, "images/workflow.png"), dpi = NA)
```

`.Rmd` 文書は, 文書の本来の形式です. YAML (メタデータ)\index{YAML}, テキスト (ナラティブ), コードチャンク\index{こーどちゃんく@コードチャンク} を含んでいます.

最初に **knitr**\index{knitr} [@R-knitr] の `knit()` 関数が `.Rmd` ファイルに埋め込まれた全てのコードを実行し, 出力文書に出力コードを表示します. 全ての結果は, 一時的に作られた `.md` ファイルに含まれるよう, 適正なマークアップ言語へと変換されます.

その後 `.md` ファイルは, あるマークアップ言語のファイルから別のものへと変換するための多用途なツールである Pandoc\index{Pandoc} によって処理されます. Pandoc は文書の YAML フロントマターで指定された何らかのパラメータ (例: `title`, `author`, `date`) を受け取り, 文書を `output` パラメータで指定された出力フォーマット (HTML へ出力する `html_document` のような) へ変換します.

出力形式が PDF ならば, さらに処理が1層追加され, Pandoc が中間ファイルの `.md` を もう一つの中間ファイル `.tex` に変換します. このファイルはその後, 最終的な PDF 文書を形成するため LaTeX によって処理されます. \@ref(install-latex) 節で話したように, **rmarkdown** パッケージは **tinytex** パッケージ [@R-tinytex] の `latexmk()` 関数を呼び出し, これが次々に LaTeX を呼び出して `.tex` をコンパイルし `.pdf` にします.

簡潔にまとめると, `rmarkdown::render()` = `knitr::knit()` + Pandoc (PDF の場合のみ + LaTeX) ということです.

Robin Linacre が https://stackoverflow.com/q/40563479/559676 で R Markdown と **knitr** と Pandoc の関係について良い要約を書いてくれました. この投稿には上記の概観よりも技術的に細かい話も含まれています.

全ての R Markdown 文書が常に Pandoc を通してコンパイルされるわけではないことに注意してください. 中間ファイル `.md` は他の Markdown レンダラによってもコンパイルできます. 例えば2つ例を挙げます. 

- **xaringan**\index{xaringan} パッケージ [@R-xaringan] は出力された `.md` をウェブブラウザ上で Markdown コンテンツを表示するための JavaScript ライブラリに渡します.^[**訳注**: **xaringan** について日本語で言及している例は少ないですが, 次のページが用法・技術的な説明の両面で優れています. https://qiita.com/nozma/items/21c56c7319e4fefceb79]

- **blogdown**\index{blogdown} パッケージは [@R-blogdown] `.Rmarkdown` 文書形式をサポートし,  `.Rmarkdown` を knit して `.markdown` にします.  通常であれば、Markdown 文書は外部のサイトジェネレータによって HTML にレンダリングされます.

## R Markdown の解剖学 {#rmarkdown-anatomy}

R Markdown にあるいくつかの部品を考慮することで, 我々はさらに1レベル深く掘り下げることができます. では, この部品がレンダリング作業中にいつどのように処理を変化させるかに注目してみましょう.

### YAML メタデータ {#yaml-metadata}

YAML metadata\index{YAML} (YAML ヘッダとも呼びます) はレンダリング作業中の多くのステージで処理され, 様々な形で最終的な文書に作用することができます. YAML メタデータは Pandoc, **rmarkdown**, そして **knitr** のそれぞれで読み込まれます. その過程で, YAML メタデータに含まれる情報は、コード, コンテンツ, そしてレンダリング処理に影響をあたえます.

典型的な YAML ヘッダは以下のような形をして、文書とレンダリング操作指示の基礎となるメタデータを含んでいます.

```yaml
---
title: My R Markdown Report
author: Yihui Xie
output: html_document
---
```

上記の場合,  `title`, `author` フィールドは Pandoc によって処理され, テンプレートの変数の値が設定されます. デフォルトのテンプレートでは, `title` と `author` の情報は得られた文書の冒頭に現れます. Pandoc が YAML ヘッダの情報をどう扱うかのより詳細な話は, Pandoc マニュアルの [YAML metadata block.](https://pandoc.org/MANUAL.html#extension-yaml_metadata_block) に関するセクションで見られます.^[**訳注**: 日本語訳での対応箇所はこちら: https://pandoc-doc-ja.readthedocs.io/ja/latest/users-guide.html#metadata-blocks]

対照的に `output` フィールドは **rmarkdown** によるレンダリング処理中に出力フォーマット関数 `rmarkdown::html_document()` に適用されます. `output` に指定した出力フォーマットに引数を与えることで, 以降のレンダリング処理に影響させることができます. 例えばこのように書きます.

```yaml
output:
  html_document:
    toc: true
    toc_float: true
```

これは `rmarkdown::render()` に, `rmarkdown::html_document(toc = TRUE, toc_float = TRUE)` と指示することと同じです. これらのオプションが何をするのか知るために, あるいは使える他のオプションを知るためには, R コンソールで `?rmarkdown::html_document` を実行してヘルプページを読むとよいでしょう. `output: html_document` は `output: rmarkdown::html_document` と等価であることに注意してください. 出力フォーマットが `rmarkdown::` のような修飾子を持たない場合, R Makrodown はこれを **rmarkdown** パッケージ由来のものと想定します. そうでないなら, R パッケージ名のプレフィックスが必要です. 例えば `bookdown::html_document2` のような.

\@ref(parameterized-reports) 節に書いたように, YAML ヘッダ内でパラメータを選択したのなら, コンテンツとコードにも影響することができます. 簡潔に言うと, R Markdown ドキュメント全体で参照可能な変数や R 評価式をヘッダに含めることができるということです. 例えば以下のヘッダでは `start_date` と `end_date` パラメータを定義することで, 以降の R Markdown 文書内で `params` というリスト内に反映されます. つまり, R コード内でこれらの値を使いたければ, `params$start_date` と `params$end_date` でアクセスできるということです.

```yaml
---
title: My RMarkdown
author: Yihui Xie
output: html_document
params:
  start_date: '2020-01-01'
  end_date: '2020-06-01'
---
```

### ナラティブ {#narrative}

ナラティブ (物語術) としてのテキスト要素は YAML メタデータやコードチャンクよりは理解が簡単でしょう. 典型的には, これはテキストエディタで書いているような感覚でしょう. しかし Markdown コンテンツは, どのようにコンテンツが作られるか, そこからどうやって文書の構造が作られるか, の両方に関して, 単純なテキストよりも強力で面白いものに違いありません.

世のナラティブの多くは人の手で書かれていますが, 多くの R Markdown 文書では、用いられているコードと分析を参照しようとします. この理由として, \@ref(document-elements) 章において, コードがテキストの一部を生成するのを助ける様々な方法が実演されています. 例えば、単語を結合してリストにしたり (\@ref(combine-words)節), 参考文献リストを書いたり (\@ref(bibliography)節)といった方法です. この変換は `.Rmd` から `.md` への変換と同様に **knitr**\index{knitr} で制御されます.

Markdown のテキストは文書に構造を与えることもできます. Markdown の構文をこの場で復習するには紙面が足りませんが,^[Markdown の復習には, 代わりに, https://bookdown.org/yihui/bookdown/markdown-syntax.html をご覧になってください.] 特に関連深い概念の1つとしてセクション見出しがあります. これは 1つ以上の, 対応したレベルの数のハッシュ (`#`) で表現されます. 例えば, 以下のように.

```md
# 第1水準の見出し

## 第2水準の見出し

### 第3水準の見出し
```

これらの見出しは **rmarkdown** が `.md` を最終的な出力フォーマットに変換する際に文書全体に構造を与えます. この構造は, ある属性を付与することでセクション (章や節) を参照し整形するのに役立ちます. Pandoc 構文は, 見出しの記述に `{#id}` の表記にしたがってユニークな識別子をつけることで参照が作成できますし,  `{.クラス名}` のように書くことで、セクションに一つないし複数のクラスを付与できます. 例えば以下のように.

```md
## 第2水準の見出し {#introduction .important .large}
```

これから学ぶいくつもの方法で, 例えば ID やクラスを参照することで, このセクションにアクセスすることができるようになります. 具体例として, \@ref(cross-ref)節ではセクションIDを使って文書内のどこでも相互参照する方法を実演していますし, \@ref(html-tabs)節では小節を再構成させる `.tabset` クラスを紹介しています.

R Markdown のテキスト部分で見られる最後の興味深いコンテンツのタイプとして, 特定の出力したいフォーマットに対して「生のコンテンツ」をそのまま書き出す方法, 例えば LaTeX 出力に対して LaTeX コードを直接書く (\@ref(raw-latex) 節), HTML 出力に対して HTML コードを直接書く (\@ref(raw-content) 節), 等を挙げます. 生のコンテンツは基本的な Markdown ではできないことが達成できますが, 出力フォーマットが異なるとたいていは無視されてしまうことに留意してください. 例えば生の LaTeX コマンドは出力が HTML の場合, 無視されます.

### コードチャンク {#code-chunks}

コードチャンク\index{こーどちゃんく@コードチャンク}は R Markdown にとっての心臓の鼓動です. チャンク内のコードは **knitr** によって実行され, 出力は Markdown に翻訳され, レポートは現在のスクリプトとデータに動的に同期します. 各コードチャンクは言語エンジン (\@ref(other-languages)章), 任意に指定できるラベル, チャンクオプション (\@ref(chunk-options)章), そしてコードで構成されます.

コードチャンクに対してできるいくつかの修正について理解するためには, **knitr** の処理を少しだけ詳しく知ることが有意義です. 各チャンクでは, **knitr** 言語エンジンは3つの入力の部品を得ます. knit 環境 (`knitr::knit_global()`), 入力されたコード, そしてチャンクオプションのリストです. コードチャンクはコードの出力とともに見た目も整形して返します. 副作用として, knit 環境も修正されます. 例えばコードチャンク内のソースコードを介してこの環境内で新しい変数がつくられます. この処理は図\@ref(fig:knitr-workflow)のように表せます.

```{r knitr-workflow, echo = FALSE, fig.cap = '言語エンジンへの入出力フローチャート', out.width = '100%', fig.dim=c(7, 3.5), fig.align='center', cache=TRUE}
nomnoml::nomnoml(
  "
  [<frame>コードチャンク|
  [コード]->[言語エンジン]
  [チャンクオプション]->[言語エンジン]
  [環境]->[言語エンジン]
  [言語エンジン]->[整形されたコード]
  [言語エンジン]->[整形された出力]
  [言語エンジン]->[(変更された) 環境]
  ]")
```

この処理は以下の方法で修正できます.

- 言語エンジンを変更する

- チャンクオプションを, グローバル, ローカル, あるいは言語エンジンに特定のものに修正する

- フックやチャプターを使用して、入出力にさらなる処理を追加する

例えば\@ref(hook-hide)節で, 後処理をするフックを加えてソースコードの特定行を編集する方法を学べるでしょう.

コードチャンクには\@ref(narrative)節でつぶさに見てきたナラティブのクラスと識別子に類似するコンセプトがあります. コードチャンクは識別子 (よく「チャンクラベル」と呼ばれます) を言語エンジンの直後に任意で指定することができます. チャンクオプション `class.source` と `class.output` でそれぞれコードブロックとテキスト出力ブロックに対するクラスを設定することもできます (\@ref(chunk-styling)節参照). 例えばチャンクヘッダ ```` ```{r summary-stats, class.output = 'large-text'}```` はチャンクラベルに `summary-stats` を与え, テキスト出力ブロックに `large-text` というクラスを与えています. チャンクのラベルは1つだけですが, クラスは複数持つことができます.

### 文書の本文 {#document-body}
 
文書を執筆し編集する際に理解すべき重要なことは, コードとナラティブの小片が文書内のいくつもの節やコンテナを作る方法です. 例えばこのような文書があったとします.

````md
# タイトル

## X 節

ここから導入文

```{r chunk-x}`r ''`
x <- 1
print(x)
```

### 第1小節

ここに詳細な話

### 第2小節

ここにさらに詳しい話

## Y 節

ここから新しい節

```{r chunk-y}`r ''`
y <- 2
print(y)
```
````

この文書を書いていると, それぞれの小片は, テキストとコードを含む独立した節を一直線上に並べたものだとみなせるでしょう. しかし我々が実際にしているのは, 概念としては図\@ref(fig:rmd-containers)でより細かく描いているように, 入れ子 (ネスト) になったコンテナの作成です^[実際にはここで見えているよりも多くのコンテナがあります. 例えば knit されたコードチャンクや, コードと出力がそれぞれ別のコンテナとして存在し, そしてこれらは親要素を共有しています.]

```{r rmd-containers, echo = FALSE, fig.cap = '入れ子状のコンテナとして表現された単純な R Markdown 文書の例', out.width = '50%', fig.align='center', cache=TRUE}
nomnoml::nomnoml(
  "
  [タイトル (レベル 1)|
  
    [節 X (レベル 2)| - テキスト | - コード (チャンク-x) | - 第1小節 | - 第2小節]
    [節 Y (レベル 2)| - テキスト | - コード (チャンク-y) ]

  ]")
```

この図に関する2つの重要な特徴は (1) テキストやコードのどのセクションも個別のコンテナであり, (2) コンテナは他の別のコンテナを入れ子にできる, ということです. この入れ子は R Markdown 文書を RStudio IDE で執筆し, 文書のアウトラインを展開^[**訳注**: エディタ右上にあるボタンで表示を切り替えることができます.]しているとはっきりと分かります.

図\@ref(fig:rmd-containers)では同じレベルのヘッダは同じレベルの入れ子を表していることに注意してください. より低いレベルのヘッダはより高レベルなヘッダのコンテナ内部にあります. この場合, 通常は高レベルの節を「親」といい, 低レベルの節を「子」といいます. 例えば「小節」は「節」の子です. \@ref(multi-column)節で実演するように, ヘッダだけでなく `:::` を使ってまとまりの単位を作ることができます.

このテキストで説明されているフォーマットやスタイルのオプションを適用するとき, この構造は重要な意味を持ちます. 例えば, Pandoc が抽象構文木 (AST) でどのように文書を表現するかを我々が学ぶ時 (\@ref(lua-filters)節) や, HTML出力のスタイルを決めるために CSS セレクタを使用する時 (\@ref(html-css)節ほか), 入れ子構造の概念が現れます.

フォーマットとスタイルは類似するいずれのタイプのコンテナ (例えばコードブロック) や, あるコンテナの内部にある全てのコンテナ (例: 「Y 節」以下にある全てのコンテナ) に対して適用できます. 加えて\@ref(narrative)節で説明したように, 同一のクラスを特定の節に対して適用し同様のものとして扱うよう明示できますが, この場合の共通するクラス名は、節と節に共通のプロパティや共通の意図を示すようになります.

本書を読みながら, 特定の「レシピ」がどんな種類のコンテナに対して作用しているのかを自問し思いを馳せることは役に立つでしょう.

## 結果を変えるために変更できるのはなにか? {#what-to-change}

では, ここまでで概観してきたものを要約し, これから何をすべきかを下見していきましょう.

**rmarkdown** で R Markdown 文書をレンダリングする処理は **knitr** で `.Rmd` を `.md` で変換する処理, それから (典型的には) Pandoc で `.md` を望む出力に変換する処理で構成されます.

`.Rmd` から `.md` への変換のステップではレポート内の全てのコードの実行と「翻訳」を取り扱うことから, ここでの「コンテンツ」への変更はほぼ, `.Rmd` のうち **knitr** が翻訳するコードを編集する作業に絡んできます. これらのステップ全体を操作するツールには **knitr** チャンクオプションおよびフックがあります.

`.md` はフォーマットされていないプレーンテキストです. ここで Pandoc が登場し, HTML や PDF, Word といった最終的な出力フォーマットへ変換されます. この流れに沿って構造とスタイルを付与します. この処理では スタイルシート (CSS), 生 LaTeX または HTML コード, Pandoc テンプレート, Lua フィルタといった様々なツールが助けになります. R Markdown 文書の入れ子構造を理解し, よく考えて識別子とクラスを使うことで, これらのツールを取捨選択して出力の目標となる箇所に応用することができます.

最後に, YAML メタデータはこれらのステップの切り替えに役に立つことでしょう. パラメータを変更することでコードがどう動作するかを変更でき, メタデータを変更すればテキストの内容を変化させ, 出力オプションの変更は異なる命令のセットを備える `render()` 関数を与えます.

もちろんこれらは全て大まかな経験則であり, 絶対的な事実として扱うべきでありません. 究極的には, 機能を完璧にきれいに分類することはできません. 本書全体を通じて, 説明されている結果の多くは, しばしば実現までの道筋が複数あり, さらにそのパイプラインの様々なステージの説明に立ち入ることになることが分かるでしょう. 例えば文書内に画像を挿入する作業では, `.Rmd` から `.md` への変換の段階で R コード `knitr::include_graphics()` を使うこともあれば, Markdown 構文 (`![]()`) を直接使うこともあるでしょう. ややこしく思えるかもしれませんし, アプローチごとに異なる利点を持つこともあります. しかし悩まないでください. なんにせよ, あなたの問題を解決する多くの有効な方法が存在し, あなたはその中から自分にとって最も理にかなうアプローチに従うことができます.

さあこの辺にしておきましょう. 本書の残りの部分で, これまで議論してきた R Markdown を最大限活用するための, あらゆるコンポネントを変更する方法のより具体的な例を使って, あなたの絵の下書きに色をつけることができます.
